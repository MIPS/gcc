/*

   Copyright (C) 2006-2008 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.

Authors:
   Andrea Ornstein
   Erven Rohou
   Gabriele Svelto

Contact information at STMicroelectronics:
Andrea C. Ornstein      <andrea.ornstein@st.com>
Erven Rohou             <erven.rohou@st.com>
*/

#include "config.h"
#include "system.h"
#include "coretypes.h"
#include "tree.h"
#include "langhooks.h"

#include "cil-builtins.h"
#include "cil-refs.h"

tree cil32_builtins[CIL32_MAX_BUILT_IN] = {NULL_TREE};

tree cil32_va_list_type = NULL_TREE;
tree cil32_arg_iterator_type;

static GTY(()) tree cil32_complex_char_type = NULL_TREE;
static GTY(()) tree cil32_complex_uchar_type = NULL_TREE;
static GTY(()) tree cil32_complex_short_type = NULL_TREE;
static GTY(()) tree cil32_complex_ushort_type = NULL_TREE;
static GTY(()) tree cil32_complex_int_type = NULL_TREE;
static GTY(()) tree cil32_complex_uint_type = NULL_TREE;
static GTY(()) tree cil32_complex_long_type = NULL_TREE;
static GTY(()) tree cil32_complex_ulong_type = NULL_TREE;
static GTY(()) tree cil32_complex_float_type = NULL_TREE;
static GTY(()) tree cil32_complex_double_type = NULL_TREE;

static GTY((param_is (union tree_node))) htab_t builtin_types = NULL;

static void cil_add_builtin (enum cil32_builtin, const char *, tree, int, ...);
static void cil_build_builtin_types (void);
static void cil_build_complex_types (void);

static void
cil_add_builtin (enum cil32_builtin bi, const char *name,
		tree ret_type, int n, ...)
{
  tree arglist;
  va_list va;

  va_start (va, n);
  arglist = NULL_TREE;

  while (n-- > 0)
    arglist = tree_cons (NULL_TREE, va_arg(va, tree), arglist);

  va_end (va);

  arglist = tree_cons (NULL_TREE, void_type_node, arglist);
  arglist = nreverse (arglist);

  cil32_builtins[bi] = add_builtin_function (name,
					     build_function_type (ret_type,
								  arglist),
					     bi,
					     BUILT_IN_MD,
					     NULL,
					     NULL_TREE);
}

void
cil_init_builtins (void)
{
  /* Vector types */
  tree float2_type_node = build_vector_type (float_type_node, 2);
  tree float4_type_node = build_vector_type (float_type_node, 4);
  tree intQI4_type_node = build_vector_type (intQI_type_node, 4);
  tree intHI2_type_node = build_vector_type (intHI_type_node, 2);
  tree intQI8_type_node = build_vector_type (intQI_type_node, 8);
  tree intHI4_type_node = build_vector_type (intHI_type_node, 4);
  tree intSI2_type_node = build_vector_type (intSI_type_node, 2);
  tree intSI4_type_node = build_vector_type (intSI_type_node, 4);
  tree intHI8_type_node = build_vector_type (intHI_type_node, 8);
  tree intQI16_type_node = build_vector_type (intQI_type_node, 16);

  /* Complex types */
  tree complex_char_type_node = build_complex_type (char_type_node);
  tree complex_short_integer_type_node = build_complex_type (short_integer_type_node);
  tree complex_long_integer_type_node = build_complex_type (long_long_integer_type_node);
  tree complex_unsigned_char_type_node = build_complex_type (unsigned_char_type_node);
  tree complex_short_unsigned_type_node = build_complex_type (short_unsigned_type_node);
  tree complex_unsigned_type_node = build_complex_type (unsigned_type_node);
  tree complex_long_unsigned_type_node = build_complex_type (long_long_unsigned_type_node);

  cil_build_builtin_types ();

#define DEF_CILBUILTIN(bid, name, ret_type, ...) \
  cil_add_builtin (CIL32_##bid, name, ret_type, ## __VA_ARGS__);
#include "cil-builtins.def"
#undef DEF_CILBUILTIN
}

/* Records a builtin type generated by the CIL back end.  */

void
cil_record_builtin_type (tree type)
{
  void **slot;

  if (builtin_types == NULL)
    builtin_types = htab_create_ggc (16, htab_hash_pointer, htab_eq_pointer,
				     NULL);

  type = TYPE_MAIN_VARIANT (type);

  /* If the type was already recorded, nothing else to do */
  slot = htab_find_slot (builtin_types, type, INSERT);

  if (*slot == NULL)
    *slot = type;
}

/* Returns true if TYPE is a builtin type of the CIL back end.  */

bool
cil_builtin_type_p (tree type)
{
  void **slot;

  type = TYPE_MAIN_VARIANT (type);
  slot = htab_find_slot (builtin_types, type, NO_INSERT);

  if (slot != NULL)
    return true;
  else
    return false;
}

static void
cil_build_builtin_types (void)
{
  cil_build_builtin_va_list ();
  cil_build_complex_types ();
}

tree
cil_build_builtin_va_list (void)
{
  tree f_dummy, record, type_decl;

  if (cil32_va_list_type == NULL_TREE)
    {
      record = (*lang_hooks.types.make_type) (RECORD_TYPE);
      type_decl = build_decl (TYPE_DECL, get_identifier ("__arg_iterator"),
			      record);

      f_dummy = build_decl (FIELD_DECL, get_identifier ("__dummy"),
			    ptr_type_node);

      DECL_FIELD_CONTEXT (f_dummy) = record;

      TREE_CHAIN (record) = type_decl;
      TYPE_NAME (record)  = type_decl;
      TYPE_FIELDS (record) = f_dummy;

      layout_type (record);

      cil32_arg_iterator_type = record;

      cil32_va_list_type = build_pointer_type (cil32_arg_iterator_type);
      cil_record_builtin_type (cil32_va_list_type);
    }

  return cil32_va_list_type;
}

static void
cil_build_complex_types (void)
{
  tree real, imag, real_id, imag_id;

  if (cil32_complex_char_type == NULL)
    {
      real_id = get_identifier ("re");
      imag_id = get_identifier ("im");

      cil32_complex_char_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, char_type_node);
      imag = build_decl (FIELD_DECL, imag_id, char_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_char_type, "complex_char",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_char_type);

      cil32_complex_uchar_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, unsigned_char_type_node);
      imag = build_decl (FIELD_DECL, imag_id, unsigned_char_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_uchar_type, "complex_uchar",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_uchar_type);

      cil32_complex_short_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, short_integer_type_node);
      imag = build_decl (FIELD_DECL, imag_id, short_integer_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_short_type, "complex_short",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_short_type);

      cil32_complex_ushort_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, short_unsigned_type_node);
      imag = build_decl (FIELD_DECL, imag_id, short_unsigned_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_ushort_type, "complex_ushort",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_ushort_type);

      cil32_complex_int_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, integer_type_node);
      imag = build_decl (FIELD_DECL, imag_id, integer_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_int_type, "complex_int",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_int_type);

      cil32_complex_uint_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, unsigned_type_node);
      imag = build_decl (FIELD_DECL, imag_id, unsigned_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_uint_type, "complex_uint",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_uint_type);

      cil32_complex_long_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, long_long_integer_type_node);
      imag = build_decl (FIELD_DECL, imag_id, long_long_integer_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_long_type, "complex_long",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_long_type);

      cil32_complex_ulong_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, long_long_unsigned_type_node);
      imag = build_decl (FIELD_DECL, imag_id, long_long_unsigned_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_ulong_type, "complex_ulong",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_ulong_type);

      cil32_complex_float_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, float_type_node);
      imag = build_decl (FIELD_DECL, imag_id, float_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_float_type, "complex_float",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_float_type);

      cil32_complex_double_type = lang_hooks.types.make_type (RECORD_TYPE);
      real = build_decl (FIELD_DECL, real_id, double_type_node);
      imag = build_decl (FIELD_DECL, imag_id, double_type_node);
      TREE_CHAIN (imag) = real;
      finish_builtin_struct (cil32_complex_double_type, "complex_double",
			     imag, NULL_TREE);
      cil_record_builtin_type (cil32_complex_double_type);
    }
}

tree
cil_get_builtin_complex_real_fld (tree type)
{
  unsigned HOST_WIDE_INT size = tree_low_cst (TYPE_SIZE (type), 1);
  bool unsignedp;

  if (INTEGRAL_TYPE_P (type))
    {
      unsignedp = TYPE_UNSIGNED (type);

      switch (size)
	{
	case 8:
	  if (unsignedp)
	    return TYPE_FIELDS (cil32_complex_uchar_type);
	  else
	    return TYPE_FIELDS (cil32_complex_char_type);
	  break;

	case 16:
	  if (unsignedp)
	    return TYPE_FIELDS (cil32_complex_ushort_type);
	  else
	    return TYPE_FIELDS (cil32_complex_short_type);
	  break;

	case 32:
	  if (unsignedp)
	    return TYPE_FIELDS (cil32_complex_uint_type);
	  else
	    return TYPE_FIELDS (cil32_complex_int_type);
	  break;

	case 64:
	  if (unsignedp)
	    return TYPE_FIELDS (cil32_complex_ulong_type);
	  else
	    return TYPE_FIELDS (cil32_complex_long_type);
	  break;

	default:
	  gcc_unreachable ();
	}
    }
  else
    {
      if (size == 32)
	return TYPE_FIELDS (cil32_complex_float_type);
      else
	return TYPE_FIELDS (cil32_complex_double_type);
    }
}

tree
cil_get_builtin_complex_imag_fld (tree type)
{
  unsigned HOST_WIDE_INT size = tree_low_cst (TYPE_SIZE (type), 1);
  bool unsignedp;

  if (INTEGRAL_TYPE_P (type))
    {
      unsignedp = TYPE_UNSIGNED (type);

      switch (size)
	{
	case 8:
	  if (unsignedp)
	    return TREE_CHAIN (TYPE_FIELDS (cil32_complex_uchar_type));
	  else
	    return TREE_CHAIN (TYPE_FIELDS (cil32_complex_char_type));
	  break;

	case 16:
	  if (unsignedp)
	    return TREE_CHAIN (TYPE_FIELDS (cil32_complex_ushort_type));
	  else
	    return TREE_CHAIN (TYPE_FIELDS (cil32_complex_short_type));
	  break;

	case 32:
	  if (unsignedp)
	    return TREE_CHAIN (TYPE_FIELDS (cil32_complex_uint_type));
	  else
	    return TREE_CHAIN (TYPE_FIELDS (cil32_complex_int_type));
	  break;

	case 64:
	  if (unsignedp)
	    return TREE_CHAIN (TYPE_FIELDS (cil32_complex_ulong_type));
	  else
	    return TREE_CHAIN (TYPE_FIELDS (cil32_complex_long_type));
	  break;

	default:
	  gcc_unreachable ();
	}
    }
  else
    {
      if (size == 32)
	return TREE_CHAIN (TYPE_FIELDS (cil32_complex_float_type));
      else
	return TREE_CHAIN (TYPE_FIELDS (cil32_complex_double_type));
    }
}

#include "gt-cil-builtins.h"
