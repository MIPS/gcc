2008-02-29  Richard Guenther  <rguenther@suse.de>

	* fold-const.c (fold_unary): Fold VIEW_CONVERT_EXPR of
	integral and pointer arguments which do not change the
	precision to NOP_EXPRs.
	[* tree-ssa-loop-ivopts.c (may_be_nonaddressable_p): Adjust
	VIEW_CONVERT_EXPR case.
	-- obsoleted by later 4.3 commit ]

Index: gcc/fold-const.c
===================================================================
*** gcc/fold-const.c.orig	2008-02-27 15:07:55.000000000 +0100
--- gcc/fold-const.c	2008-03-11 13:51:09.000000000 +0100
*************** fold_unary (enum tree_code code, tree ty
*** 8263,8275 ****
      case VIEW_CONVERT_EXPR:
        if (TREE_TYPE (op0) == type)
  	return op0;
!       if (TREE_CODE (op0) == VIEW_CONVERT_EXPR
! 	  || (TREE_CODE (op0) == NOP_EXPR
! 	      && INTEGRAL_TYPE_P (TREE_TYPE (op0))
! 	      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))
! 	      && TYPE_PRECISION (TREE_TYPE (op0))
! 		 == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))))
  	return fold_build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));
        return fold_view_convert_expr (type, op0);
  
      case NEGATE_EXPR:
--- 8263,8295 ----
      case VIEW_CONVERT_EXPR:
        if (TREE_TYPE (op0) == type)
  	return op0;
!       if (TREE_CODE (op0) == VIEW_CONVERT_EXPR)
  	return fold_build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));
+ 
+       /* For integral conversions with the same precision or pointer
+ 	 conversions use a NOP_EXPR instead.  */
+       if ((INTEGRAL_TYPE_P (type)
+ 	   || POINTER_TYPE_P (type))
+ 	  && (INTEGRAL_TYPE_P (TREE_TYPE (op0))
+ 	      || POINTER_TYPE_P (TREE_TYPE (op0)))
+ 	  && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (op0))
+ 	  /* Do not muck with VIEW_CONVERT_EXPRs that convert from
+ 	     a sub-type to its base type as generated by the Ada FE.  */
+ 	  && !(INTEGRAL_TYPE_P (TREE_TYPE (op0))
+ 	       && TREE_TYPE (TREE_TYPE (op0))))
+ 	return fold_convert (type, op0);
+ 
+       /* Strip inner integral conversions that do not change the precision.  */
+       if ((TREE_CODE (op0) == NOP_EXPR
+ 	   || TREE_CODE (op0) == CONVERT_EXPR)
+ 	  && (INTEGRAL_TYPE_P (TREE_TYPE (op0))
+ 	      || POINTER_TYPE_P (TREE_TYPE (op0)))
+ 	  && (INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))
+ 	      || POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0))))
+ 	  && (TYPE_PRECISION (TREE_TYPE (op0))
+ 	      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))))
+ 	return fold_build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));
+ 
        return fold_view_convert_expr (type, op0);
  
      case NEGATE_EXPR:
Index: gcc/tree-ssa-loop-im.c
===================================================================
*** gcc/tree-ssa-loop-im.c.orig	2008-02-19 10:55:59.000000000 +0100
--- gcc/tree-ssa-loop-im.c	2008-03-11 14:44:25.000000000 +0100
*************** for_each_index (tree *addr_p, bool (*cbc
*** 208,213 ****
--- 208,217 ----
  	case CONSTRUCTOR:
  	  return true;
  
+ 	case ADDR_EXPR:
+ 	  gcc_assert (is_gimple_min_invariant (*addr_p));
+ 	  return true;
+ 
  	case TARGET_MEM_REF:
  	  idx = &TMR_BASE (*addr_p);
  	  if (*idx
