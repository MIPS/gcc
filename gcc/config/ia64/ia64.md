;; IA-64 Machine description template
;; Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
;; Contributed by James E. Wilson <wilson@cygnus.com> and
;;		  David Mosberger <davidm@hpl.hp.com>.

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.

;; ??? register_operand accepts (subreg:DI (mem:SI X)) which forces later
;; reload.  This will be fixed once scheduling support is turned on.

;; ??? Optimize for post-increment addressing modes.

;; ??? fselect is not supported, because there is no integer register
;; equivalent.

;; ??? fp abs/min/max instructions may also work for integer values.

;; ??? Would a predicate_reg_operand predicate be useful?  The HP one is buggy,
;; it assumes the operand is a register and takes REGNO of it without checking.

;; ??? Would a branch_reg_operand predicate be useful?  The HP one is buggy,
;; it assumes the operand is a register and takes REGNO of it without checking.

;; ??? Go through list of documented named patterns and look for more to
;; implement.

;; ??? Go through instruction manual and look for more instructions that
;; can be emitted.

;; ??? Add function unit scheduling info for Itanium (TM) processor.

;; ??? Need a better way to describe alternate fp status registers.

;; Unspec usage:
;;
;; unspec:
;;	1	gr_spill
;;	2	gr_restore
;;	3	fr_spill
;;	4	fr_restore
;;	5	recip_approx
;;	7	pred_rel_mutex
;;	8	popcnt
;;	9	pic call
;;	12	mf
;;	13	cmpxchg_acq
;;	19	fetchadd_acq
;;	20	bsp_value
;;	21	flushrs
;;	22      bundle selector
;;	23      cycle display
;;      24      addp4
;;	25	prologue_use

;; More unspec:

(define_constants
  [; Relocations
   (UNSPEC_LTOFF_DTPMOD		14)
   (UNSPEC_LTOFF_DTPREL		15)
   (UNSPEC_DTPREL		16)
   (UNSPEC_LTOFF_TPREL		17)
   (UNSPEC_TPREL		18)
   (UNSPEC_LD_BASE		26)
   (UNSPEC_RET_ADDR		27)
  ])

;; unspec_volatile:
;;	0	alloc
;;	1	blockage
;;	2	insn_group_barrier
;;	3	break
;;	5	set_bsp
;;	8	pred.safe_across_calls all
;;	9	pred.safe_across_calls normal

;; ::::::::::::::::::::
;; ::
;; :: Attributes
;; ::
;; ::::::::::::::::::::

;; Processor type.  This attribute must exactly match the processor_type
;; enumeration in ia64.h.
(define_attr "cpu" "itanium,itanium2" (const (symbol_ref "ia64_tune")))

;; Instruction type.  This primarily determines how instructions can be
;; packed in bundles, and secondarily affects scheduling to function units.

;; A alu, can go in I or M syllable of a bundle
;; I integer
;; M memory
;; F floating-point
;; B branch
;; L long immediate, takes two syllables
;; S stop bit

;; ??? Should not have any pattern with type unknown.  Perhaps add code to
;; check this in md_reorg?  Currently use unknown for patterns which emit
;; multiple instructions, patterns which emit 0 instructions, and patterns
;; which emit instruction that can go in any slot (e.g. nop).

(define_attr "itanium_class" "unknown,ignore,stop_bit,br,fcmp,fcvtfx,fld,fmac,fmisc,frar_i,frar_m,frbr,frfr,frpr,ialu,icmp,ilog,ishf,ld,chk_s,long_i,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,st,syst_m0,syst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop,nop_b,nop_f,nop_i,nop_m,nop_x,lfetch,pre_cycle"
  (const_string "unknown"))

;; chk_s has an I and an M form; use type A for convenience.
(define_attr "type" "unknown,A,I,M,F,B,L,X,S"
  (cond [(eq_attr "itanium_class" "ld,st,fld,stf,sem,nop_m") (const_string "M")
	 (eq_attr "itanium_class" "rse_m,syst_m,syst_m0") (const_string "M")
	 (eq_attr "itanium_class" "frar_m,toar_m,frfr,tofr") (const_string "M")
	 (eq_attr "itanium_class" "lfetch") (const_string "M")
	 (eq_attr "itanium_class" "chk_s,ialu,icmp,ilog") (const_string "A")
	 (eq_attr "itanium_class" "fmisc,fmac,fcmp,xmpy") (const_string "F")
	 (eq_attr "itanium_class" "fcvtfx,nop_f") (const_string "F")
	 (eq_attr "itanium_class" "frar_i,toar_i,frbr,tobr") (const_string "I")
	 (eq_attr "itanium_class" "frpr,topr,ishf,xtd,tbit") (const_string "I")
	 (eq_attr "itanium_class" "mmmul,mmshf,mmshfi,nop_i") (const_string "I")
	 (eq_attr "itanium_class" "br,scall,nop_b") (const_string "B")
	 (eq_attr "itanium_class" "stop_bit") (const_string "S")
	 (eq_attr "itanium_class" "nop_x") (const_string "X")
	 (eq_attr "itanium_class" "long_i") (const_string "L")]
	(const_string "unknown")))

;; Predication.  True iff this instruction can be predicated.

(define_attr "predicable" "no,yes" (const_string "yes"))



;; DFA descriptions of ia64 processors used for insn scheduling and
;; bundling.

(automata_option "ndfa")

;; Uncomment the following line to output automata for debugging.
;; (automata_option "v")

(automata_option "w")

;;(automata_option "no-minimization")


/* This is description of pipeline hazards based on DFA.  The
   following constructions can be used for this:
   
   o define_cpu_unit string [string]) describes a cpu functional unit
     (separated by comma).

     1st operand: Names of cpu function units.
     2nd operand: Name of automaton (see comments for
     DEFINE_AUTOMATON).

     All define_reservations and define_cpu_units should have unique
     names which can not be "nothing".

   o (exclusion_set string string) means that each CPU function unit
     in the first string can not be reserved simultaneously with each
     unit whose name is in the second string and vise versa.  CPU
     units in the string are separated by commas. For example, it is
     useful for description CPU with fully pipelined floating point
     functional unit which can execute simultaneously only single
     floating point insns or only double floating point insns.

   o (presence_set string string) means that each CPU function unit in
     the first string can not be reserved unless at least one of
     pattern of units whose names are in the second string is
     reserved.  This is an asymmetric relation.  CPU units or unit
     patterns in the strings are separated by commas.  Pattern is one
     unit name or unit names separated by white-spaces.
 
     For example, it is useful for description that slot1 is reserved
     after slot0 reservation for a VLIW processor.  We could describe
     it by the following construction

         (presence_set "slot1" "slot0")

     Or slot1 is reserved only after slot0 and unit b0 reservation.
     In this case we could write

         (presence_set "slot1" "slot0 b0")

     All CPU functional units in a set should belong to the same
     automaton.

   o (final_presence_set string string) is analogous to
     `presence_set'.  The difference between them is when checking is
     done.  When an instruction is issued in given automaton state
     reflecting all current and planned unit reservations, the
     automaton state is changed.  The first state is a source state,
     the second one is a result state.  Checking for `presence_set' is
     done on the source state reservation, checking for
     `final_presence_set' is done on the result reservation.  This
     construction is useful to describe a reservation which is
     actually two subsequent reservations.  For example, if we use

         (presence_set "slot1" "slot0")

     the following insn will be never issued (because slot1 requires
     slot0 which is absent in the source state).

         (define_reservation "insn_and_nop" "slot0 + slot1")

     but it can be issued if we use analogous `final_presence_set'.

   o (absence_set string string) means that each CPU function unit in
     the first string can be reserved only if each pattern of units
     whose names are in the second string is not reserved.  This is an
     asymmetric relation (actually exclusion set is analogous to this
     one but it is symmetric).  CPU units or unit patterns in the
     string are separated by commas.  Pattern is one unit name or unit
     names separated by white-spaces.

     For example, it is useful for description that slot0 can not be
     reserved after slot1 or slot2 reservation for a VLIW processor.
     We could describe it by the following construction

        (absence_set "slot2" "slot0, slot1")

     Or slot2 can not be reserved if slot0 and unit b0 are reserved or
     slot1 and unit b1 are reserved .  In this case we could write

        (absence_set "slot2" "slot0 b0, slot1 b1")

     All CPU functional units in a set should to belong the same
     automaton.

   o (final_absence_set string string) is analogous to `absence_set' but
     checking is done on the result (state) reservation.  See comments
     for final_presence_set.

   o (define_bypass number out_insn_names in_insn_names) names bypass with
     given latency (the first number) from insns given by the first
     string (see define_insn_reservation) into insns given by the
     second string.  Insn names in the strings are separated by
     commas.

   o (define_automaton string) describes names of an automaton
     generated and used for pipeline hazards recognition.  The names
     are separated by comma.  Actually it is possibly to generate the
     single automaton but unfortunately it can be very large.  If we
     use more one automata, the summary size of the automata usually
     is less than the single one.  The automaton name is used in
     define_cpu_unit.  All automata should have unique names.

   o (automata_option string) describes option for generation of
     automata.  Currently there are the following options:

     o "no-minimization" which makes no minimization of automata.
       This is only worth to do when we are debugging the description
       and need to look more accurately at reservations of states.

     o "ndfa" which makes automata with nondetermenistic reservation
        by insns.

   o (define_reservation string string) names reservation (the first
     string) of cpu functional units (the 2nd string).  Sometimes unit
     reservations for different insns contain common parts.  In such
     case, you describe common part and use one its name (the 1st
     parameter) in regular expression in define_insn_reservation.  All
     define_reservations, define results and define_cpu_units should
     have unique names which can not be "nothing".

   o (define_insn_reservation name default_latency condition regexpr)
     describes reservation of cpu functional units (the 3nd operand)
     for instruction which is selected by the condition (the 2nd
     parameter).  The first parameter is used for output of debugging
     information.  The reservations are described by a regular
     expression according the following syntax:

       regexp = regexp "," oneof
              | oneof

       oneof = oneof "|" allof
             | allof

       allof = allof "+" repeat
             | repeat
 
       repeat = element "*" number
              | element

       element = cpu_function_name
               | reservation_name
               | result_name
               | "nothing"
               | "(" regexp ")"

       1. "," is used for describing start of the next cycle in
          reservation.

       2. "|" is used for describing the reservation described by the
          first regular expression *or* the reservation described by
          the second regular expression *or* etc.

       3. "+" is used for describing the reservation described by the
          first regular expression *and* the reservation described by
          the second regular expression *and* etc.

       4. "*" is used for convinience and simply means sequence in
          which the regular expression are repeated NUMBER times with
          cycle advancing (see ",").

       5. cpu function unit name which means reservation.

       6. reservation name -- see define_reservation.

       7. string "nothing" means no units reservation.

*/

(define_automaton "one")

;;   All possible combinations of bundles/syllables
(define_cpu_unit "1_0m.ii, 1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb,\
                  1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx" "one")
(define_cpu_unit "1_0mi.i, 1_0mm.i, 1_0mf.i, 1_0mm.f, 1_0bb.b, 1_0mb.b,\
                  1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx." "one")
(define_cpu_unit "1_0mii., 1_0mmi., 1_0mfi., 1_0mmf., 1_0bbb., 1_0mbb.,\
                  1_0mib., 1_0mmb., 1_0mfb." "one")

(define_cpu_unit "1_1m.ii, 1_1m.mi, 1_1m.fi, 1_1b.bb, 1_1m.bb,\
                  1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx" "one")
(define_cpu_unit "1_1mi.i, 1_1mm.i, 1_1mf.i, 1_1bb.b, 1_1mb.b,\
                  1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx." "one")
(define_cpu_unit "1_1mii., 1_1mmi., 1_1mfi., 1_1bbb., 1_1mbb.,\
                  1_1mib., 1_1mmb., 1_1mfb." "one")

;; Slot 1
(exclusion_set "1_0m.ii"
   "1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb,\
    1_0m.lx")
(exclusion_set "1_0m.mi"
   "1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx")
(exclusion_set "1_0m.fi"
   "1_0m.mf, 1_0b.bb, 1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx")
(exclusion_set "1_0m.mf"
   "1_0b.bb, 1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx")
(exclusion_set "1_0b.bb" "1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx")
(exclusion_set "1_0m.bb" "1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx")
(exclusion_set "1_0m.ib" "1_0m.mb, 1_0m.fb, 1_0m.lx")
(exclusion_set "1_0m.mb" "1_0m.fb, 1_0m.lx")
(exclusion_set "1_0m.fb" "1_0m.lx")

;; Slot 2
(exclusion_set "1_0mi.i"
   "1_0mm.i, 1_0mf.i, 1_0mm.f, 1_0bb.b, 1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b,\
    1_0mlx.")
(exclusion_set "1_0mm.i"
   "1_0mf.i, 1_0mm.f, 1_0bb.b, 1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.")
(exclusion_set "1_0mf.i"
   "1_0mm.f, 1_0bb.b, 1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.")
(exclusion_set "1_0mm.f"
   "1_0bb.b, 1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.")
(exclusion_set "1_0bb.b" "1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.")
(exclusion_set "1_0mb.b" "1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.")
(exclusion_set "1_0mi.b" "1_0mm.b, 1_0mf.b, 1_0mlx.")
(exclusion_set "1_0mm.b" "1_0mf.b, 1_0mlx.")
(exclusion_set "1_0mf.b" "1_0mlx.")

;; Slot 3
(exclusion_set "1_0mii."
   "1_0mmi., 1_0mfi., 1_0mmf., 1_0bbb., 1_0mbb., 1_0mib., 1_0mmb., 1_0mfb.,\
    1_0mlx.")
(exclusion_set "1_0mmi."
   "1_0mfi., 1_0mmf., 1_0bbb., 1_0mbb., 1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.")
(exclusion_set "1_0mfi."
   "1_0mmf., 1_0bbb., 1_0mbb., 1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.")
(exclusion_set "1_0mmf."
   "1_0bbb., 1_0mbb., 1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.")
(exclusion_set "1_0bbb." "1_0mbb., 1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.")
(exclusion_set "1_0mbb." "1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.")
(exclusion_set "1_0mib." "1_0mmb., 1_0mfb., 1_0mlx.")
(exclusion_set "1_0mmb." "1_0mfb., 1_0mlx.")
(exclusion_set "1_0mfb." "1_0mlx.")

;; Slot 4
(exclusion_set "1_1m.ii"
   "1_1m.mi, 1_1m.fi, 1_1b.bb, 1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx")
(exclusion_set "1_1m.mi"
   "1_1m.fi, 1_1b.bb, 1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx")
(exclusion_set "1_1m.fi"
   "1_1b.bb, 1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx")
(exclusion_set "1_1b.bb" "1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx")
(exclusion_set "1_1m.bb" "1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx")
(exclusion_set "1_1m.ib" "1_1m.mb, 1_1m.fb, 1_1m.lx")
(exclusion_set "1_1m.mb" "1_1m.fb, 1_1m.lx")
(exclusion_set "1_1m.fb" "1_1m.lx")

;; Slot 5
(exclusion_set "1_1mi.i"
   "1_1mm.i, 1_1mf.i, 1_1bb.b, 1_1mb.b, 1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.")
(exclusion_set "1_1mm.i"
   "1_1mf.i, 1_1bb.b, 1_1mb.b, 1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.")
(exclusion_set "1_1mf.i"
   "1_1bb.b, 1_1mb.b, 1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.")
(exclusion_set "1_1bb.b" "1_1mb.b, 1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.")
(exclusion_set "1_1mb.b" "1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.")
(exclusion_set "1_1mi.b" "1_1mm.b, 1_1mf.b, 1_1mlx.")
(exclusion_set "1_1mm.b" "1_1mf.b, 1_1mlx.")
(exclusion_set "1_1mf.b" "1_1mlx.")

;; Slot 6
(exclusion_set "1_1mii."
   "1_1mmi., 1_1mfi., 1_1bbb., 1_1mbb., 1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.")
(exclusion_set "1_1mmi."
   "1_1mfi., 1_1bbb., 1_1mbb., 1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.")
(exclusion_set "1_1mfi."
   "1_1bbb., 1_1mbb., 1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.")
(exclusion_set "1_1bbb." "1_1mbb., 1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.")
(exclusion_set "1_1mbb." "1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.")
(exclusion_set "1_1mib." "1_1mmb., 1_1mfb., 1_1mlx.")
(exclusion_set "1_1mmb." "1_1mfb., 1_1mlx.")
(exclusion_set "1_1mfb." "1_1mlx.")

(final_presence_set "1_0mi.i" "1_0m.ii")
(final_presence_set "1_0mii." "1_0mi.i")
(final_presence_set "1_1mi.i" "1_1m.ii")
(final_presence_set "1_1mii." "1_1mi.i")

(final_presence_set "1_0mm.i" "1_0m.mi")
(final_presence_set "1_0mmi." "1_0mm.i")
(final_presence_set "1_1mm.i" "1_1m.mi")
(final_presence_set "1_1mmi." "1_1mm.i")

(final_presence_set "1_0mf.i" "1_0m.fi")
(final_presence_set "1_0mfi." "1_0mf.i")
(final_presence_set "1_1mf.i" "1_1m.fi")
(final_presence_set "1_1mfi." "1_1mf.i")

(final_presence_set "1_0mm.f" "1_0m.mf")
(final_presence_set "1_0mmf." "1_0mm.f")

(final_presence_set "1_0bb.b" "1_0b.bb")
(final_presence_set "1_0bbb." "1_0bb.b")
(final_presence_set "1_1bb.b" "1_1b.bb")
(final_presence_set "1_1bbb." "1_1bb.b")

(final_presence_set "1_0mb.b" "1_0m.bb")
(final_presence_set "1_0mbb." "1_0mb.b")
(final_presence_set "1_1mb.b" "1_1m.bb")
(final_presence_set "1_1mbb." "1_1mb.b")

(final_presence_set "1_0mi.b" "1_0m.ib")
(final_presence_set "1_0mib." "1_0mi.b")
(final_presence_set "1_1mi.b" "1_1m.ib")
(final_presence_set "1_1mib." "1_1mi.b")

(final_presence_set "1_0mm.b" "1_0m.mb")
(final_presence_set "1_0mmb." "1_0mm.b")
(final_presence_set "1_1mm.b" "1_1m.mb")
(final_presence_set "1_1mmb." "1_1mm.b")

(final_presence_set "1_0mf.b" "1_0m.fb")
(final_presence_set "1_0mfb." "1_0mf.b")
(final_presence_set "1_1mf.b" "1_1m.fb")
(final_presence_set "1_1mfb." "1_1mf.b")

(final_presence_set "1_0mlx." "1_0m.lx")
(final_presence_set "1_1mlx." "1_1m.lx")

(final_presence_set
   "1_1m.ii,1_1m.mi,1_1m.fi,1_1b.bb,1_1m.bb,1_1m.ib,1_1m.mb,1_1m.fb,1_1m.lx"
   "1_0mii.,1_0mmi.,1_0mfi.,1_0mmf.,1_0bbb.,1_0mbb.,1_0mib.,1_0mmb.,1_0mfb.,\
    1_0mlx.")

;;  Microarchitecture units:
(define_cpu_unit
   "1_um0, 1_um1, 1_ui0, 1_ui1, 1_uf0, 1_uf1, 1_ub0, 1_ub1, 1_ub2,\
    1_unb0, 1_unb1, 1_unb2" "one")

(exclusion_set "1_ub0" "1_unb0")
(exclusion_set "1_ub1" "1_unb1")
(exclusion_set "1_ub2" "1_unb2")

;; The following rules are used to decrease number of alternatives.
;; They are consequences of Itanium microarchitecture.  They also
;; describe the following rules mentioned in Itanium
;; microarchitecture: rules mentioned in Itanium microarchitecture:
;; o "MMF: Always splits issue before the first M and after F regardless
;;   of surrounding bundles and stops".
;; o "BBB/MBB: Always splits issue after either of these bundles".
;; o "MIB BBB: Split issue after the first bundle in this pair".

(exclusion_set "1_0m.mf,1_0mm.f,1_0mmf."
   "1_1m.ii,1_1m.mi,1_1m.fi,1_1b.bb,1_1m.bb,1_1m.ib,1_1m.mb,1_1m.fb,1_1m.lx")
(exclusion_set "1_0b.bb,1_0bb.b,1_0bbb.,1_0m.bb,1_0mb.b,1_0mbb."
   "1_1m.ii,1_1m.mi,1_1m.fi,1_1b.bb,1_1m.bb,1_1m.ib,1_1m.mb,1_1m.fb,1_1m.lx")
(exclusion_set "1_0m.ib,1_0mi.b,1_0mib." "1_1b.bb")

;;  For exceptions of M, I, B, F insns:
(define_cpu_unit "1_not_um1, 1_not_ui1, 1_not_uf1" "one")

(final_absence_set "1_not_um1"  "1_um1")
(final_absence_set "1_not_ui1"  "1_ui1")
(final_absence_set "1_not_uf1"  "1_uf1")

;;; "MIB/MFB/MMB: Splits issue after any of these bundles unless the
;;; B-slot contains a nop.b or a brp instruction".
;;;   "The B in an MIB/MFB/MMB bundle disperses to B0 if it is a brp or
;;; nop.b, otherwise it disperses to B2".
(final_absence_set
   "1_1m.ii, 1_1m.mi, 1_1m.fi, 1_1b.bb, 1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb,\
    1_1m.lx"
   "1_0mib. 1_ub2, 1_0mfb. 1_ub2, 1_0mmb. 1_ub2")

;; This is necessary to start new processor cycle when we meet stop bit.
(define_cpu_unit "1_stop" "one")
(final_absence_set
   "1_0m.ii,1_0mi.i,1_0mii.,1_0m.mi,1_0mm.i,1_0mmi.,1_0m.fi,1_0mf.i,1_0mfi.,\
    1_0m.mf,1_0mm.f,1_0mmf.,1_0b.bb,1_0bb.b,1_0bbb.,1_0m.bb,1_0mb.b,1_0mbb.,\
    1_0m.ib,1_0mi.b,1_0mib.,1_0m.mb,1_0mm.b,1_0mmb.,1_0m.fb,1_0mf.b,1_0mfb.,\
    1_0m.lx,1_0mlx., \
    1_1m.ii,1_1mi.i,1_1mii.,1_1m.mi,1_1mm.i,1_1mmi.,1_1m.fi,1_1mf.i,1_1mfi.,\
    1_1b.bb,1_1bb.b,1_1bbb.,1_1m.bb,1_1mb.b,1_1mbb.,1_1m.ib,1_1mi.b,1_1mib.,\
    1_1m.mb,1_1mm.b,1_1mmb.,1_1m.fb,1_1mf.b,1_1mfb.,1_1m.lx,1_1mlx."
   "1_stop")

;; M and I instruction is dispersed to the lowest numbered M or I unit
;; not already in use.  An I slot in the 3rd position of 2nd bundle is
;; always dispersed to I1
(final_presence_set "1_um1" "1_um0")
(final_presence_set "1_ui1" "1_ui0, 1_1mii., 1_1mmi., 1_1mfi.")

;; Insns

;; M and I instruction is dispersed to the lowest numbered M or I unit
;; not already in use.  An I slot in the 3rd position of 2nd bundle is
;; always dispersed to I1
(define_reservation "1_M0"
  "1_0m.ii+1_um0|1_0m.mi+1_um0|1_0mm.i+(1_um0|1_um1)\
   |1_0m.fi+1_um0|1_0m.mf+1_um0|1_0mm.f+1_um1\
   |1_0m.bb+1_um0|1_0m.ib+1_um0|1_0m.mb+1_um0\
   |1_0mm.b+1_um1|1_0m.fb+1_um0|1_0m.lx+1_um0\
   |1_1mm.i+1_um1|1_1mm.b+1_um1\
   |(1_1m.ii|1_1m.mi|1_1m.fi|1_1m.bb|1_1m.ib|1_1m.mb|1_1m.fb|1_1m.lx)\
    +(1_um0|1_um1)")

(define_reservation "1_M1"
  "(1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0\
    |1_0mib.+1_unb0|1_0mfb.+1_unb0|1_0mmb.+1_unb0)\
     +(1_1m.ii|1_1m.mi|1_1m.fi|1_1m.bb|1_1m.ib|1_1m.mb|1_1m.fb|1_1m.lx)\
     +(1_um0|1_um1)")

(define_reservation "1_M" "1_M0|1_M1")

;;  Exceptions for dispersal rules.
;; "An I slot in the 3rd position of 2nd bundle is always dispersed to I1".
(define_reservation "1_I0"
  "1_0mi.i+1_ui0|1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0\
   |1_0mi.b+1_ui0|(1_1mi.i|1_1mi.b)+(1_ui0|1_ui1)\
   |1_1mii.+1_ui1|1_1mmi.+1_ui1|1_1mfi.+1_ui1")

(define_reservation "1_I1"
  "1_0m.ii+1_um0+1_0mi.i+1_ui0|1_0mm.i+(1_um0|1_um1)+1_0mmi.+1_ui0\
   |1_0mf.i+1_uf0+1_0mfi.+1_ui0|1_0m.ib+1_um0+1_0mi.b+1_ui0\
   |(1_1m.ii+(1_um0|1_um1)+1_1mi.i\
   |1_1m.ib+(1_um0|1_um1)+1_1mi.b)+(1_ui0|1_ui1)\
   |1_1mm.i+1_um1+1_1mmi.+1_ui1|1_1mf.i+1_uf1+1_1mfi.+1_ui1")

(define_reservation "1_I" "1_I0|1_I1")

;; "An F slot in the 1st bundle disperses to F0".
;; "An F slot in the 2st bundle disperses to F1".
(define_reservation "1_F0"
   "1_0mf.i+1_uf0|1_0mmf.+1_uf0|1_0mf.b+1_uf0|1_1mf.i+1_uf1|1_1mf.b+1_uf1")

(define_reservation "1_F1"
   "1_0m.fi+1_um0+1_0mf.i+1_uf0|1_0mm.f+(1_um0|1_um1)+1_0mmf.+1_uf0\
    |1_0m.fb+1_um0+1_0mf.b+1_uf0|1_1m.fi+(1_um0|1_um1)+1_1mf.i+1_uf1\
    |1_1m.fb+(1_um0|1_um1)+1_1mf.b+1_uf1")

(define_reservation "1_F2"
   "1_0m.mf+1_um0+1_0mm.f+1_um1+1_0mmf.+1_uf0\
    |(1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0\
      |1_0mib.+1_unb0|1_0mmb.+1_unb0|1_0mfb.+1_unb0)\
     +(1_1m.fi+(1_um0|1_um1)+1_1mf.i+1_uf1\
       |1_1m.fb+(1_um0|1_um1)+1_1mf.b+1_uf1)")

(define_reservation "1_F" "1_F0|1_F1|1_F2")

;;; "Each B slot in MBB or BBB bundle disperses to the corresponding B
;;; unit. That is, a B slot in 1st position is despersed to B0.  In the
;;; 2nd position it is dispersed to B2".
(define_reservation "1_NB"
    "1_0b.bb+1_unb0|1_0bb.b+1_unb1|1_0bbb.+1_unb2\
     |1_0mb.b+1_unb1|1_0mbb.+1_unb2\
     |1_0mib.+1_unb0|1_0mmb.+1_unb0|1_0mfb.+1_unb0\
     |1_1b.bb+1_unb0|1_1bb.b+1_unb1\
     |1_1bbb.+1_unb2|1_1mb.b+1_unb1|1_1mbb.+1_unb2|1_1mib.+1_unb0\
     |1_1mmb.+1_unb0|1_1mfb.+1_unb0")

(define_reservation "1_B0"
   "1_0b.bb+1_ub0|1_0bb.b+1_ub1|1_0bbb.+1_ub2\
    |1_0mb.b+1_ub1|1_0mbb.+1_ub2|1_0mib.+1_ub2\
    |1_0mfb.+1_ub2|1_1b.bb+1_ub0|1_1bb.b+1_ub1\
    |1_1bbb.+1_ub2|1_1mb.b+1_ub1\
    |1_1mib.+1_ub2|1_1mmb.+1_ub2|1_1mfb.+1_ub2")

(define_reservation "1_B1"
   "1_0m.bb+1_um0+1_0mb.b+1_ub1|1_0mi.b+1_ui0+1_0mib.+1_ub2\
    |1_0mf.b+1_uf0+1_0mfb.+1_ub2\
    |(1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0)+1_1b.bb+1_ub0\
    |1_1m.bb+(1_um0|1_um1)+1_1mb.b+1_ub1\
    |1_1mi.b+(1_ui0|1_ui1)+1_1mib.+1_ub2\
    |1_1mm.b+1_um1+1_1mmb.+1_ub2\
    |1_1mf.b+1_uf1+1_1mfb.+1_ub2")

(define_reservation "1_B" "1_B0|1_B1")

;; MLX bunlde uses ports equivalent to MFI bundles.
(define_reservation "1_L0" "1_0mlx.+1_ui0+1_uf0|1_1mlx.+(1_ui0|1_ui1)+1_uf1")
(define_reservation "1_L1"
   "1_0m.lx+1_um0+1_0mlx.+1_ui0+1_uf0\
   |1_1m.lx+(1_um0|1_um1)+1_1mlx.+(1_ui0|1_ui1)+1_uf1")
(define_reservation "1_L2"
   "(1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0\
     |1_0mib.+1_unb0|1_0mmb.+1_unb0|1_0mfb.+1_unb0)
    +1_1m.lx+(1_um0|1_um1)+1_1mlx.+1_ui1+1_uf1")
(define_reservation "1_L" "1_L0|1_L1|1_L2")

(define_reservation "1_A" "1_M|1_I")

(define_insn_reservation "1_stop_bit" 0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "stop_bit"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_stop|1_m0_stop|1_m1_stop|1_mi0_stop|1_mi1_stop")

(define_insn_reservation "1_br"      0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "br"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_B")
(define_insn_reservation "1_scall"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "scall"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_B")
(define_insn_reservation "1_fcmp"    2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fcmp"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_F+1_not_uf1")
(define_insn_reservation "1_fcvtfx"  7
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fcvtfx"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_F")
(define_insn_reservation "1_fld"     9
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fld"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_M")
(define_insn_reservation "1_fmac"    5
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fmac"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_F")
(define_insn_reservation "1_fmisc"   5
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fmisc"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_F+1_not_uf1")

;; There is only one insn `mov = ar.bsp' for frar_i:
(define_insn_reservation "1_frar_i" 13
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frar_i"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_I+1_not_ui1")
;; There is only two insns `mov = ar.unat' or `mov = ar.ccv' for frar_m:
(define_insn_reservation "1_frar_m"  6
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frar_m"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_M+1_not_um1")
(define_insn_reservation "1_frbr"    2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frbr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_I+1_not_ui1")
(define_insn_reservation "1_frfr"    2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frfr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_M+1_not_um1")
(define_insn_reservation "1_frpr"    2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frpr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_I+1_not_ui1")

(define_insn_reservation "1_ialu"      1
    (and (and (eq_attr "cpu" "itanium")
              (eq_attr "itanium_class" "ialu"))
         (eq (symbol_ref
              "bundling_p || ia64_produce_address_p (insn)")
              (const_int 0)))
    "1_A")
(define_insn_reservation "1_ialu_addr" 1
    (and (and (eq_attr "cpu" "itanium")
              (eq_attr "itanium_class" "ialu"))
         (eq (symbol_ref
              "!bundling_p && ia64_produce_address_p (insn)")
             (const_int 1)))
    "1_M")
(define_insn_reservation "1_icmp"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "icmp"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_A")
(define_insn_reservation "1_ilog"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "ilog"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_A")
(define_insn_reservation "1_ishf"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "ishf"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
    "1_I+1_not_ui1")
(define_insn_reservation "1_ld"      2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "ld"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_M")
(define_insn_reservation "1_long_i"  1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "long_i"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_L")
(define_insn_reservation "1_mmmul"   2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "mmmul"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_I+1_not_ui1")
(define_insn_reservation "1_mmshf"   2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "mmshf"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_I")
(define_insn_reservation "1_mmshfi"  1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "mmshfi"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_I")

;; Now we have only one insn (flushrs) of such class.  We assume that flushrs
;; is the 1st syllable of the bundle after stop bit.
(define_insn_reservation "1_rse_m"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "rse_m"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "(1_0m.ii|1_0m.mi|1_0m.fi|1_0m.mf|1_0b.bb|1_0m.bb\
    |1_0m.ib|1_0m.mb|1_0m.fb|1_0m.lx)+1_um0")
(define_insn_reservation "1_sem"     0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "sem"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_M+1_not_um1")
(define_insn_reservation "1_stf"     1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "stf"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_M")
(define_insn_reservation "1_st"      1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "st"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_M")
(define_insn_reservation "1_syst_m0" 0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "syst_m0"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_M+1_not_um1")
(define_insn_reservation "1_syst_m"  0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "syst_m"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_M")
(define_insn_reservation "1_tbit"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "tbit"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_I+1_not_ui1")

;; There is only ony insn `mov ar.pfs =' for toar_i:
(define_insn_reservation "1_toar_i"  0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "toar_i"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_I+1_not_ui1")
;; There are only ony 2 insns `mov ar.ccv =' and `mov ar.unat =' for toar_m:
(define_insn_reservation "1_toar_m"  5
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "toar_m"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_M+1_not_um1")
(define_insn_reservation "1_tobr"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "tobr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_I+1_not_ui1")
(define_insn_reservation "1_tofr"    9
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "tofr"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_M")
(define_insn_reservation "1_topr"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "topr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_I+1_not_ui1")
(define_insn_reservation "1_xmpy"    7
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "xmpy"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_F")
(define_insn_reservation "1_xtd"     1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "xtd"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_I")

(define_insn_reservation "1_chk_s"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "chk_s"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_A")
(define_insn_reservation "1_lfetch"  0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "lfetch"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_M")

(define_insn_reservation "1_nop_m"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_m"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_M0")
(define_insn_reservation "1_nop_b"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_b"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_NB")
(define_insn_reservation "1_nop_i"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_i"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_I0")
(define_insn_reservation "1_nop_f"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_f"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_F0")
(define_insn_reservation "1_nop_x"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_x"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_L0")

;; We assume that there is no insn issued on the same cycle as unknown insn.
(define_cpu_unit "1_empty" "one")
(exclusion_set "1_empty"
    "1_0m.ii,1_0m.mi,1_0m.fi,1_0m.mf,1_0b.bb,1_0m.bb,1_0m.ib,1_0m.mb,1_0m.fb,\
     1_0m.lx")

(define_insn_reservation "1_unknown" 1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "unknown"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "1_empty")

(define_insn_reservation "1_nop" 1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "1_M0|1_NB|1_I0|1_F0")

(define_insn_reservation "1_ignore" 0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "ignore"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "nothing")


(define_cpu_unit
   "1_0m_bs, 1_0mi_bs, 1_0mm_bs, 1_0mf_bs, 1_0b_bs, 1_0bb_bs, 1_0mb_bs"
   "one")
(define_cpu_unit
   "1_1m_bs, 1_1mi_bs, 1_1mm_bs, 1_1mf_bs, 1_1b_bs, 1_1bb_bs, 1_1mb_bs"
   "one")

(define_cpu_unit "1_m_cont, 1_mi_cont, 1_mm_cont, 1_mf_cont, 1_mb_cont,\
	          1_b_cont, 1_bb_cont" "one")

;; For stop in the middle of the bundles.
(define_cpu_unit "1_m_stop, 1_m0_stop, 1_m1_stop, 1_0mmi_cont" "one")
(define_cpu_unit "1_mi_stop, 1_mi0_stop, 1_mi1_stop, 1_0mii_cont" "one")

(final_presence_set "1_0m_bs"
   "1_0m.ii, 1_0m.mi, 1_0m.mf, 1_0m.fi, 1_0m.bb,\
    1_0m.ib, 1_0m.fb, 1_0m.mb, 1_0m.lx")
(final_presence_set "1_1m_bs"
   "1_1m.ii, 1_1m.mi, 1_1m.fi, 1_1m.bb, 1_1m.ib, 1_1m.fb, 1_1m.mb,\
    1_1m.lx")
(final_presence_set "1_0mi_bs"  "1_0mi.i, 1_0mi.i")
(final_presence_set "1_1mi_bs"  "1_1mi.i, 1_1mi.i")
(final_presence_set "1_0mm_bs"  "1_0mm.i, 1_0mm.f, 1_0mm.b")
(final_presence_set "1_1mm_bs"  "1_1mm.i, 1_1mm.b")
(final_presence_set "1_0mf_bs"  "1_0mf.i, 1_0mf.b")
(final_presence_set "1_1mf_bs"  "1_1mf.i, 1_1mf.b")
(final_presence_set "1_0b_bs"  "1_0b.bb")
(final_presence_set "1_1b_bs"  "1_1b.bb")
(final_presence_set "1_0bb_bs"  "1_0bb.b")
(final_presence_set "1_1bb_bs"  "1_1bb.b")
(final_presence_set "1_0mb_bs"  "1_0mb.b")
(final_presence_set "1_1mb_bs"  "1_1mb.b")

(exclusion_set "1_0m_bs"
   "1_0mi.i, 1_0mm.i, 1_0mm.f, 1_0mf.i, 1_0mb.b,\
    1_0mi.b, 1_0mf.b, 1_0mm.b, 1_0mlx., 1_m0_stop")
(exclusion_set "1_1m_bs"
   "1_1mi.i, 1_1mm.i, 1_1mf.i, 1_1mb.b, 1_1mi.b, 1_1mf.b, 1_1mm.b,\
    1_1mlx., 1_m1_stop")
(exclusion_set "1_0mi_bs"  "1_0mii., 1_0mib., 1_mi0_stop")
(exclusion_set "1_1mi_bs"  "1_1mii., 1_1mib., 1_mi1_stop")
(exclusion_set "1_0mm_bs"  "1_0mmi., 1_0mmf., 1_0mmb.")
(exclusion_set "1_1mm_bs"  "1_1mmi., 1_1mmb.")
(exclusion_set "1_0mf_bs"  "1_0mfi., 1_0mfb.")
(exclusion_set "1_1mf_bs"  "1_1mfi., 1_1mfb.")
(exclusion_set "1_0b_bs"  "1_0bb.b")
(exclusion_set "1_1b_bs"  "1_1bb.b")
(exclusion_set "1_0bb_bs"  "1_0bbb.")
(exclusion_set "1_1bb_bs"  "1_1bbb.")
(exclusion_set "1_0mb_bs"  "1_0mbb.")
(exclusion_set "1_1mb_bs"  "1_1mbb.")

(exclusion_set
   "1_0m_bs, 1_0mi_bs, 1_0mm_bs, 1_0mf_bs, 1_0b_bs, 1_0bb_bs, 1_0mb_bs,
    1_1m_bs, 1_1mi_bs, 1_1mm_bs, 1_1mf_bs, 1_1b_bs, 1_1bb_bs, 1_1mb_bs"
   "1_stop")

(final_presence_set
   "1_0mi.i, 1_0mm.i, 1_0mf.i, 1_0mm.f, 1_0mb.b,\
    1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx."
   "1_m_cont")
(final_presence_set "1_0mii., 1_0mib." "1_mi_cont")
(final_presence_set "1_0mmi., 1_0mmf., 1_0mmb." "1_mm_cont")
(final_presence_set "1_0mfi., 1_0mfb." "1_mf_cont")
(final_presence_set "1_0bb.b" "1_b_cont")
(final_presence_set "1_0bbb." "1_bb_cont")
(final_presence_set "1_0mbb." "1_mb_cont")

(exclusion_set
   "1_0m.ii, 1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb,\
    1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx"
   "1_m_cont, 1_mi_cont, 1_mm_cont, 1_mf_cont,\
    1_mb_cont, 1_b_cont, 1_bb_cont")

(exclusion_set "1_empty"
               "1_m_cont,1_mi_cont,1_mm_cont,1_mf_cont,\
                1_mb_cont,1_b_cont,1_bb_cont")

;; For m;mi bundle
(final_presence_set "1_m0_stop" "1_0m.mi")
(final_presence_set "1_0mm.i" "1_0mmi_cont")
(exclusion_set "1_0mmi_cont"
   "1_0m.ii, 1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb,\
    1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx")
(exclusion_set "1_m0_stop" "1_0mm.i")
(final_presence_set "1_m1_stop" "1_1m.mi")
(exclusion_set "1_m1_stop" "1_1mm.i")
(final_presence_set "1_m_stop" "1_m0_stop, 1_m1_stop")

;; For mi;i bundle
(final_presence_set "1_mi0_stop" "1_0mi.i")
(final_presence_set "1_0mii." "1_0mii_cont")
(exclusion_set "1_0mii_cont"
   "1_0m.ii, 1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb,\
    1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx")
(exclusion_set "1_mi0_stop" "1_0mii.")
(final_presence_set "1_mi1_stop" "1_1mi.i")
(exclusion_set "1_mi1_stop" "1_1mii.")
(final_presence_set "1_mi_stop" "1_mi0_stop, 1_mi1_stop")

(final_absence_set
   "1_0m.ii,1_0mi.i,1_0mii.,1_0m.mi,1_0mm.i,1_0mmi.,1_0m.fi,1_0mf.i,1_0mfi.,\
    1_0m.mf,1_0mm.f,1_0mmf.,1_0b.bb,1_0bb.b,1_0bbb.,1_0m.bb,1_0mb.b,1_0mbb.,\
    1_0m.ib,1_0mi.b,1_0mib.,1_0m.mb,1_0mm.b,1_0mmb.,1_0m.fb,1_0mf.b,1_0mfb.,\
    1_0m.lx,1_0mlx., \
    1_1m.ii,1_1mi.i,1_1mii.,1_1m.mi,1_1mm.i,1_1mmi.,1_1m.fi,1_1mf.i,1_1mfi.,\
    1_1b.bb,1_1bb.b,1_1bbb.,1_1m.bb,1_1mb.b,1_1mbb.,\
    1_1m.ib,1_1mi.b,1_1mib.,1_1m.mb,1_1mm.b,1_1mmb.,1_1m.fb,1_1mf.b,1_1mfb.,\
    1_1m.lx,1_1mlx."
   "1_m0_stop,1_m1_stop,1_mi0_stop,1_mi1_stop")

(define_cpu_unit "1_m_cont_only, 1_b_cont_only" "one")
(define_cpu_unit "1_mi_cont_only, 1_mm_cont_only, 1_mf_cont_only" "one")
(define_cpu_unit "1_mb_cont_only, 1_bb_cont_only" "one")

(final_presence_set "1_m_cont_only" "1_m_cont")
(exclusion_set "1_m_cont_only"
  "1_0mi.i, 1_0mm.i, 1_0mf.i, 1_0mm.f, 1_0mb.b,\
   1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.")

(final_presence_set "1_b_cont_only" "1_b_cont")
(exclusion_set "1_b_cont_only"  "1_0bb.b")

(final_presence_set "1_mi_cont_only" "1_mi_cont")
(exclusion_set "1_mi_cont_only" "1_0mii., 1_0mib.")

(final_presence_set "1_mm_cont_only" "1_mm_cont")
(exclusion_set "1_mm_cont_only" "1_0mmi., 1_0mmf., 1_0mmb.")

(final_presence_set "1_mf_cont_only" "1_mf_cont")
(exclusion_set "1_mf_cont_only" "1_0mfi., 1_0mfb.")

(final_presence_set "1_mb_cont_only" "1_mb_cont")
(exclusion_set "1_mb_cont_only" "1_0mbb.")

(final_presence_set "1_bb_cont_only" "1_bb_cont")
(exclusion_set "1_bb_cont_only" "1_0bbb.")

(define_insn_reservation "1_pre_cycle" 0
   (and (and (eq_attr "cpu" "itanium")
             (eq_attr "itanium_class" "pre_cycle"))
        (eq (symbol_ref "bundling_p") (const_int 0)))
                         "(1_0m_bs, 1_m_cont)                     \
                          | (1_0mi_bs, (1_mi_cont|nothing))       \
                          | (1_0mm_bs, 1_mm_cont)                 \
                          | (1_0mf_bs, (1_mf_cont|nothing))       \
                          | (1_0b_bs, (1_b_cont|nothing))         \
                          | (1_0bb_bs, (1_bb_cont|nothing))       \
                          | (1_0mb_bs, (1_mb_cont|nothing))       \
                          | (1_1m_bs, 1_m_cont)                   \
                          | (1_1mi_bs, (1_mi_cont|nothing))       \
                          | (1_1mm_bs, 1_mm_cont)                 \
                          | (1_1mf_bs, (1_mf_cont|nothing))       \
                          | (1_1b_bs, (1_b_cont|nothing))         \
                          | (1_1bb_bs, (1_bb_cont|nothing))       \
                          | (1_1mb_bs, (1_mb_cont|nothing))       \
                          | (1_m_cont_only, (1_m_cont|nothing))   \
                          | (1_b_cont_only,  (1_b_cont|nothing))  \
                          | (1_mi_cont_only, (1_mi_cont|nothing)) \
                          | (1_mm_cont_only, (1_mm_cont|nothing)) \
                          | (1_mf_cont_only, (1_mf_cont|nothing)) \
                          | (1_mb_cont_only, (1_mb_cont|nothing)) \
                          | (1_bb_cont_only, (1_bb_cont|nothing)) \
                          | (1_m_stop, (1_0mmi_cont|nothing))     \
                          | (1_mi_stop, (1_0mii_cont|nothing))")

;; Bypasses:
(define_bypass  1 "1_fcmp" "1_br,1_scall")
;; ??? I found 7 cycle dealy for 1_fmac -> 1_fcmp for Itanium1
(define_bypass  7 "1_fmac" "1_fmisc,1_fcvtfx,1_xmpy,1_fcmp")

;; ???
(define_bypass  3 "1_frbr" "1_mmmul,1_mmshf")
(define_bypass 14 "1_frar_i" "1_mmmul,1_mmshf")
(define_bypass  7 "1_frar_m" "1_mmmul,1_mmshf")

;; ????
;; There is only one insn `mov ar.pfs =' for toar_i.
(define_bypass  0 "1_tobr,1_topr,1_toar_i" "1_br,1_scall")

(define_bypass  3 "1_ialu,1_ialu_addr" "1_mmmul,1_mmshf")
;; ??? howto describe ialu for I slot only.  We use ialu_addr for that
;;(define_bypass  2 "1_ialu" "1_ld"  "ia64_ld_address_bypass_p")
;; ??? howto describe ialu st/address for I slot only.  We use ialu_addr
;;   for that.
;;(define_bypass  2 "1_ialu" "1_st"  "ia64_st_address_bypass_p")

(define_bypass  0 "1_icmp" "1_br,1_scall")

(define_bypass  3 "1_ilog" "1_mmmul,1_mmshf")

(define_bypass  2 "1_ilog,1_xtd" "1_ld"  "ia64_ld_address_bypass_p")
(define_bypass  2 "1_ilog,1_xtd" "1_st"  "ia64_st_address_bypass_p")

(define_bypass  3 "1_ld" "1_mmmul,1_mmshf")
(define_bypass  3 "1_ld" "1_ld"  "ia64_ld_address_bypass_p")
(define_bypass  3 "1_ld" "1_st"  "ia64_st_address_bypass_p")

;; Intel docs say only LD, ST, IALU, ILOG, ISHF consumers have latency 4,
;;      but HP engineers say any non-MM operation.
(define_bypass  4 "1_mmmul,1_mmshf"
     "1_br,1_fcmp,1_fcvtfx,1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,\
      1_frbr,1_frfr,1_frpr,1_ialu,1_icmp,1_ilog,1_ishf,1_ld,1_chk_s,\
      1_long_i,1_rse_m,1_sem,1_stf,1_st,1_syst_m0,1_syst_m,\
      1_tbit,1_toar_i,1_toar_m,1_tobr,1_tofr,1_topr,1_xmpy,1_xtd")

;; ??? how to describe that if scheduled < 4 cycle then latency is 10 cycles.
;; (define_bypass  10 "1_mmmul,1_mmshf" "1_ialu,1_ilog,1_ishf,1_st,1_ld")

(define_bypass  0 "1_tbit" "1_br,1_scall")

(define_bypass  8 "1_tofr"  "1_frfr,1_stf")
(define_bypass  7 "1_fmisc,1_fcvtfx,1_fmac,1_xmpy"  "1_frfr")
(define_bypass  8 "1_fmisc,1_fcvtfx,1_fmac,1_xmpy"  "1_stf")

;; We don't use here fcmp because scall may be predicated.
(define_bypass  0 "1_fcvtfx,1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,\
                   1_frbr,1_frfr,1_frpr,1_ialu,1_ialu_addr,1_ilog,1_ishf,\
	           1_ld,1_long_i,1_mmmul,1_mmshf,1_mmshfi,1_toar_m,1_tofr,\
                   1_xmpy,1_xtd" "1_scall")

(define_bypass  0 "1_unknown,1_ignore,1_stop_bit,1_br,1_fcmp,1_fcvtfx,\
                   1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,1_frbr,1_frfr,\
                   1_frpr,1_ialu,1_ialu_addr,1_icmp,1_ilog,1_ishf,1_ld,\
                   1_chk_s,1_long_i,1_mmmul,1_mmshf,1_mmshfi,1_nop,\
                   1_nop_b,1_nop_f,1_nop_i,1_nop_m,1_nop_x,1_rse_m,1_scall,\
                   1_sem,1_stf,1_st,1_syst_m0,1_syst_m,1_tbit,1_toar_i,\
                   1_toar_m,1_tobr,1_tofr,1_topr,1_xmpy,1_xtd,1_lfetch"
                  "1_ignore")


;; Bundling

(define_automaton "oneb")

;; Pseudo units for quicker searching for position in two packet window.  */
(define_query_cpu_unit "1_1,1_2,1_3,1_4,1_5,1_6" "oneb")

;;   All possible combinations of bundles/syllables
(define_cpu_unit
   "1b_0m.ii, 1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\
    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx" "oneb")
(define_cpu_unit
   "1b_0mi.i, 1b_0mm.i, 1b_0mf.i, 1b_0mm.f, 1b_0bb.b, 1b_0mb.b,\
    1b_0mi.b, 1b_0mm.b, 1b_0mf.b" "oneb")
(define_query_cpu_unit
   "1b_0mii., 1b_0mmi., 1b_0mfi., 1b_0mmf., 1b_0bbb., 1b_0mbb.,\
    1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx." "oneb")

(define_cpu_unit "1b_1m.ii, 1b_1m.mi, 1b_1m.fi, 1b_1b.bb, 1b_1m.bb,\
                  1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx" "oneb")
(define_cpu_unit "1b_1mi.i, 1b_1mm.i, 1b_1mf.i, 1b_1bb.b, 1b_1mb.b,\
                  1b_1mi.b, 1b_1mm.b, 1b_1mf.b" "oneb")
(define_query_cpu_unit "1b_1mii., 1b_1mmi., 1b_1mfi., 1b_1bbb., 1b_1mbb.,\
                        1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx." "oneb")

;; Slot 1
(exclusion_set "1b_0m.ii"
   "1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\
    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_0m.mi"
   "1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb, 1b_0m.ib,\
    1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_0m.fi"
   "1b_0m.mf, 1b_0b.bb, 1b_0m.bb, 1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_0m.mf"
   "1b_0b.bb, 1b_0m.bb, 1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_0b.bb" "1b_0m.bb, 1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_0m.bb" "1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_0m.ib" "1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_0m.mb" "1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_0m.fb" "1b_0m.lx")

;; Slot 2
(exclusion_set "1b_0mi.i"
   "1b_0mm.i, 1b_0mf.i, 1b_0mm.f, 1b_0bb.b, 1b_0mb.b,\
    1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.")
(exclusion_set "1b_0mm.i"
   "1b_0mf.i, 1b_0mm.f, 1b_0bb.b, 1b_0mb.b,\
    1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.")
(exclusion_set "1b_0mf.i"
   "1b_0mm.f, 1b_0bb.b, 1b_0mb.b, 1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.")
(exclusion_set "1b_0mm.f"
   "1b_0bb.b, 1b_0mb.b, 1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.")
(exclusion_set "1b_0bb.b" "1b_0mb.b, 1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.")
(exclusion_set "1b_0mb.b" "1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.")
(exclusion_set "1b_0mi.b" "1b_0mm.b, 1b_0mf.b, 1b_0mlx.")
(exclusion_set "1b_0mm.b" "1b_0mf.b, 1b_0mlx.")
(exclusion_set "1b_0mf.b" "1b_0mlx.")

;; Slot 3
(exclusion_set "1b_0mii."
   "1b_0mmi., 1b_0mfi., 1b_0mmf., 1b_0bbb., 1b_0mbb.,\
    1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.")
(exclusion_set "1b_0mmi."
   "1b_0mfi., 1b_0mmf., 1b_0bbb., 1b_0mbb.,\
    1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.")
(exclusion_set "1b_0mfi."
   "1b_0mmf., 1b_0bbb., 1b_0mbb., 1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.")
(exclusion_set "1b_0mmf."
   "1b_0bbb., 1b_0mbb., 1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.")
(exclusion_set "1b_0bbb." "1b_0mbb., 1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.")
(exclusion_set "1b_0mbb." "1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.")
(exclusion_set "1b_0mib." "1b_0mmb., 1b_0mfb., 1b_0mlx.")
(exclusion_set "1b_0mmb." "1b_0mfb., 1b_0mlx.")
(exclusion_set "1b_0mfb." "1b_0mlx.")

;; Slot 4
(exclusion_set "1b_1m.ii"
   "1b_1m.mi, 1b_1m.fi, 1b_1b.bb, 1b_1m.bb,\
    1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx")
(exclusion_set "1b_1m.mi"
   "1b_1m.fi, 1b_1b.bb, 1b_1m.bb, 1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx")
(exclusion_set "1b_1m.fi"
   "1b_1b.bb, 1b_1m.bb, 1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx")
(exclusion_set "1b_1b.bb" "1b_1m.bb, 1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx")
(exclusion_set "1b_1m.bb" "1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx")
(exclusion_set "1b_1m.ib" "1b_1m.mb, 1b_1m.fb, 1b_1m.lx")
(exclusion_set "1b_1m.mb" "1b_1m.fb, 1b_1m.lx")
(exclusion_set "1b_1m.fb" "1b_1m.lx")

;; Slot 5
(exclusion_set "1b_1mi.i"
   "1b_1mm.i, 1b_1mf.i, 1b_1bb.b, 1b_1mb.b,\
    1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.")
(exclusion_set "1b_1mm.i"
   "1b_1mf.i, 1b_1bb.b, 1b_1mb.b, 1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.")
(exclusion_set "1b_1mf.i"
   "1b_1bb.b, 1b_1mb.b, 1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.")
(exclusion_set "1b_1bb.b" "1b_1mb.b, 1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.")
(exclusion_set "1b_1mb.b" "1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.")
(exclusion_set "1b_1mi.b" "1b_1mm.b, 1b_1mf.b, 1b_1mlx.")
(exclusion_set "1b_1mm.b" "1b_1mf.b, 1b_1mlx.")
(exclusion_set "1b_1mf.b" "1b_1mlx.")

;; Slot 6
(exclusion_set "1b_1mii."
   "1b_1mmi., 1b_1mfi., 1b_1bbb., 1b_1mbb.,\
    1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.")
(exclusion_set "1b_1mmi."
   "1b_1mfi., 1b_1bbb., 1b_1mbb., 1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.")
(exclusion_set "1b_1mfi."
   "1b_1bbb., 1b_1mbb., 1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.")
(exclusion_set "1b_1bbb." "1b_1mbb., 1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.")
(exclusion_set "1b_1mbb." "1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.")
(exclusion_set "1b_1mib." "1b_1mmb., 1b_1mfb., 1b_1mlx.")
(exclusion_set "1b_1mmb." "1b_1mfb., 1b_1mlx.")
(exclusion_set "1b_1mfb." "1b_1mlx.")

(final_presence_set "1b_0mi.i" "1b_0m.ii")
(final_presence_set "1b_0mii." "1b_0mi.i")
(final_presence_set "1b_1mi.i" "1b_1m.ii")
(final_presence_set "1b_1mii." "1b_1mi.i")

(final_presence_set "1b_0mm.i" "1b_0m.mi")
(final_presence_set "1b_0mmi." "1b_0mm.i")
(final_presence_set "1b_1mm.i" "1b_1m.mi")
(final_presence_set "1b_1mmi." "1b_1mm.i")

(final_presence_set "1b_0mf.i" "1b_0m.fi")
(final_presence_set "1b_0mfi." "1b_0mf.i")
(final_presence_set "1b_1mf.i" "1b_1m.fi")
(final_presence_set "1b_1mfi." "1b_1mf.i")

(final_presence_set "1b_0mm.f" "1b_0m.mf")
(final_presence_set "1b_0mmf." "1b_0mm.f")

(final_presence_set "1b_0bb.b" "1b_0b.bb")
(final_presence_set "1b_0bbb." "1b_0bb.b")
(final_presence_set "1b_1bb.b" "1b_1b.bb")
(final_presence_set "1b_1bbb." "1b_1bb.b")

(final_presence_set "1b_0mb.b" "1b_0m.bb")
(final_presence_set "1b_0mbb." "1b_0mb.b")
(final_presence_set "1b_1mb.b" "1b_1m.bb")
(final_presence_set "1b_1mbb." "1b_1mb.b")

(final_presence_set "1b_0mi.b" "1b_0m.ib")
(final_presence_set "1b_0mib." "1b_0mi.b")
(final_presence_set "1b_1mi.b" "1b_1m.ib")
(final_presence_set "1b_1mib." "1b_1mi.b")

(final_presence_set "1b_0mm.b" "1b_0m.mb")
(final_presence_set "1b_0mmb." "1b_0mm.b")
(final_presence_set "1b_1mm.b" "1b_1m.mb")
(final_presence_set "1b_1mmb." "1b_1mm.b")

(final_presence_set "1b_0mf.b" "1b_0m.fb")
(final_presence_set "1b_0mfb." "1b_0mf.b")
(final_presence_set "1b_1mf.b" "1b_1m.fb")
(final_presence_set "1b_1mfb." "1b_1mf.b")

(final_presence_set "1b_0mlx." "1b_0m.lx")
(final_presence_set "1b_1mlx." "1b_1m.lx")

(final_presence_set
   "1b_1m.ii,1b_1m.mi,1b_1m.fi,1b_1b.bb,1b_1m.bb,\
    1b_1m.ib,1b_1m.mb,1b_1m.fb,1b_1m.lx"
   "1b_0mii.,1b_0mmi.,1b_0mfi.,1b_0mmf.,1b_0bbb.,1b_0mbb.,\
    1b_0mib.,1b_0mmb.,1b_0mfb.,1b_0mlx.")

;;  Microarchitecture units:
(define_cpu_unit
   "1b_um0, 1b_um1, 1b_ui0, 1b_ui1, 1b_uf0, 1b_uf1, 1b_ub0, 1b_ub1, 1b_ub2,\
    1b_unb0, 1b_unb1, 1b_unb2" "oneb")

(exclusion_set "1b_ub0" "1b_unb0")
(exclusion_set "1b_ub1" "1b_unb1")
(exclusion_set "1b_ub2" "1b_unb2")

;; The following rules are used to decrease number of alternatives.
;; They are consequences of Itanium microarchitecture.  They also
;; describe the following rules mentioned in Itanium
;; microarchitecture: rules mentioned in Itanium microarchitecture:
;; o "MMF: Always splits issue before the first M and after F regardless
;;   of surrounding bundles and stops".
;; o "BBB/MBB: Always splits issue after either of these bundles".
;; o "MIB BBB: Split issue after the first bundle in this pair".

(exclusion_set "1b_0m.mf,1b_0mm.f,1b_0mmf."
   "1b_1m.ii,1b_1m.mi,1b_1m.fi,1b_1b.bb,1b_1m.bb,\
    1b_1m.ib,1b_1m.mb,1b_1m.fb,1b_1m.lx")
(exclusion_set "1b_0b.bb,1b_0bb.b,1b_0bbb.,1b_0m.bb,1b_0mb.b,1b_0mbb."
   "1b_1m.ii,1b_1m.mi,1b_1m.fi,1b_1b.bb,1b_1m.bb,\
    1b_1m.ib,1b_1m.mb,1b_1m.fb,1b_1m.lx")
(exclusion_set "1b_0m.ib,1b_0mi.b,1b_0mib." "1b_1b.bb")

;;  For exceptions of M, I, B, F insns:
(define_cpu_unit "1b_not_um1, 1b_not_ui1, 1b_not_uf1" "oneb")

(final_absence_set "1b_not_um1"  "1b_um1")
(final_absence_set "1b_not_ui1"  "1b_ui1")
(final_absence_set "1b_not_uf1"  "1b_uf1")

;;; "MIB/MFB/MMB: Splits issue after any of these bundles unless the
;;; B-slot contains a nop.b or a brp instruction".
;;;   "The B in an MIB/MFB/MMB bundle disperses to B0 if it is a brp or
;;; nop.b, otherwise it disperses to B2".
(final_absence_set
   "1b_1m.ii, 1b_1m.mi, 1b_1m.fi, 1b_1b.bb, 1b_1m.bb,\
    1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx"
   "1b_0mib. 1b_ub2, 1b_0mfb. 1b_ub2, 1b_0mmb. 1b_ub2")

;; This is necessary to start new processor cycle when we meet stop bit.
(define_cpu_unit "1b_stop" "oneb")
(final_absence_set
   "1b_0m.ii,1b_0mi.i,1b_0mii.,1b_0m.mi,1b_0mm.i,1b_0mmi.,\
    1b_0m.fi,1b_0mf.i,1b_0mfi.,\
    1b_0m.mf,1b_0mm.f,1b_0mmf.,1b_0b.bb,1b_0bb.b,1b_0bbb.,\
    1b_0m.bb,1b_0mb.b,1b_0mbb.,\
    1b_0m.ib,1b_0mi.b,1b_0mib.,1b_0m.mb,1b_0mm.b,1b_0mmb.,\
    1b_0m.fb,1b_0mf.b,1b_0mfb.,1b_0m.lx,1b_0mlx., \
    1b_1m.ii,1b_1mi.i,1b_1mii.,1b_1m.mi,1b_1mm.i,1b_1mmi.,\
    1b_1m.fi,1b_1mf.i,1b_1mfi.,\
    1b_1b.bb,1b_1bb.b,1b_1bbb.,1b_1m.bb,1b_1mb.b,1b_1mbb.,\
    1b_1m.ib,1b_1mi.b,1b_1mib.,\
    1b_1m.mb,1b_1mm.b,1b_1mmb.,1b_1m.fb,1b_1mf.b,1b_1mfb.,1b_1m.lx,1b_1mlx."
   "1b_stop")

;; M and I instruction is dispersed to the lowest numbered M or I unit
;; not already in use.  An I slot in the 3rd position of 2nd bundle is
;; always dispersed to I1
(final_presence_set "1b_um1" "1b_um0")
(final_presence_set "1b_ui1" "1b_ui0, 1b_1mii., 1b_1mmi., 1b_1mfi.")

;; Insns

;; M and I instruction is dispersed to the lowest numbered M or I unit
;; not already in use.  An I slot in the 3rd position of 2nd bundle is
;; always dispersed to I1
(define_reservation "1b_M"
  "1b_0m.ii+1_1+1b_um0|1b_0m.mi+1_1+1b_um0|1b_0mm.i+1_2+(1b_um0|1b_um1)\
   |1b_0m.fi+1_1+1b_um0|1b_0m.mf+1_1+1b_um0|1b_0mm.f+1_2+1b_um1\
   |1b_0m.bb+1_1+1b_um0|1b_0m.ib+1_1+1b_um0|1b_0m.mb+1_1+1b_um0\
   |1b_0mm.b+1_2+1b_um1|1b_0m.fb+1_1+1b_um0|1b_0m.lx+1_1+1b_um0\
   |1b_1mm.i+1_5+1b_um1|1b_1mm.b+1_5+1b_um1\
   |(1b_1m.ii+1_4|1b_1m.mi+1_4|1b_1m.fi+1_4|1b_1m.bb+1_4|1b_1m.ib+1_4\
     |1b_1m.mb+1_4|1b_1m.fb+1_4|1b_1m.lx+1_4)\
    +(1b_um0|1b_um1)")

;;  Exceptions for dispersal rules.
;; "An I slot in the 3rd position of 2nd bundle is always dispersed to I1".
(define_reservation "1b_I"
  "1b_0mi.i+1_2+1b_ui0|1b_0mii.+1_3+(1b_ui0|1b_ui1)|1b_0mmi.+1_3+1b_ui0\
   |1b_0mfi.+1_3+1b_ui0|1b_0mi.b+1_2+1b_ui0\
   |(1b_1mi.i+1_5|1b_1mi.b+1_5)+(1b_ui0|1b_ui1)\
   |1b_1mii.+1_6+1b_ui1|1b_1mmi.+1_6+1b_ui1|1b_1mfi.+1_6+1b_ui1")

;; "An F slot in the 1st bundle disperses to F0".
;; "An F slot in the 2st bundle disperses to F1".
(define_reservation "1b_F"
   "1b_0mf.i+1_2+1b_uf0|1b_0mmf.+1_3+1b_uf0|1b_0mf.b+1_2+1b_uf0\
    |1b_1mf.i+1_5+1b_uf1|1b_1mf.b+1_5+1b_uf1")

;;; "Each B slot in MBB or BBB bundle disperses to the corresponding B
;;; unit. That is, a B slot in 1st position is despersed to B0.  In the
;;; 2nd position it is dispersed to B2".
(define_reservation "1b_NB"
    "1b_0b.bb+1_1+1b_unb0|1b_0bb.b+1_2+1b_unb1|1b_0bbb.+1_3+1b_unb2\
     |1b_0mb.b+1_2+1b_unb1|1b_0mbb.+1_3+1b_unb2\
     |1b_0mib.+1_3+1b_unb0|1b_0mmb.+1_3+1b_unb0|1b_0mfb.+1_3+1b_unb0\
     |1b_1b.bb+1_4+1b_unb0|1b_1bb.b+1_5+1b_unb1\
     |1b_1bbb.+1_6+1b_unb2|1b_1mb.b+1_5+1b_unb1|1b_1mbb.+1_6+1b_unb2\
     |1b_1mib.+1_6+1b_unb0|1b_1mmb.+1_6+1b_unb0|1b_1mfb.+1_6+1b_unb0")

(define_reservation "1b_B"
   "1b_0b.bb+1_1+1b_ub0|1b_0bb.b+1_2+1b_ub1|1b_0bbb.+1_3+1b_ub2\
    |1b_0mb.b+1_2+1b_ub1|1b_0mbb.+1_3+1b_ub2|1b_0mib.+1_3+1b_ub2\
    |1b_0mfb.+1_3+1b_ub2|1b_1b.bb+1_4+1b_ub0|1b_1bb.b+1_5+1b_ub1\
    |1b_1bbb.+1_6+1b_ub2|1b_1mb.b+1_5+1b_ub1\
    |1b_1mib.+1_6+1b_ub2|1b_1mmb.+1_6+1b_ub2|1b_1mfb.+1_6+1b_ub2")

(define_reservation "1b_L" "1b_0mlx.+1_3+1b_ui0+1b_uf0\
                           |1b_1mlx.+1_6+(1b_ui0|1b_ui1)+1b_uf1")

;; We assume that there is no insn issued on the same cycle as unknown insn.
(define_cpu_unit "1b_empty" "oneb")
(exclusion_set "1b_empty"
    "1b_0m.ii,1b_0m.mi,1b_0m.fi,1b_0m.mf,1b_0b.bb,1b_0m.bb,\
     1b_0m.ib,1b_0m.mb,1b_0m.fb,1b_0m.lx")

(define_cpu_unit
   "1b_0m_bs, 1b_0mi_bs, 1b_0mm_bs, 1b_0mf_bs, 1b_0b_bs, 1b_0bb_bs, 1b_0mb_bs"
   "oneb")
(define_cpu_unit
   "1b_1m_bs, 1b_1mi_bs, 1b_1mm_bs, 1b_1mf_bs, 1b_1b_bs, 1b_1bb_bs, 1b_1mb_bs"
   "oneb")

(define_cpu_unit "1b_m_cont, 1b_mi_cont, 1b_mm_cont, 1b_mf_cont, 1b_mb_cont,\
	          1b_b_cont, 1b_bb_cont" "oneb")

;; For stop in the middle of the bundles.
(define_cpu_unit "1b_m_stop, 1b_m0_stop, 1b_m1_stop, 1b_0mmi_cont" "oneb")
(define_cpu_unit "1b_mi_stop, 1b_mi0_stop, 1b_mi1_stop, 1b_0mii_cont" "oneb")

(final_presence_set "1b_0m_bs"
   "1b_0m.ii, 1b_0m.mi, 1b_0m.mf, 1b_0m.fi, 1b_0m.bb,\
    1b_0m.ib, 1b_0m.fb, 1b_0m.mb, 1b_0m.lx")
(final_presence_set "1b_1m_bs"
   "1b_1m.ii, 1b_1m.mi, 1b_1m.fi, 1b_1m.bb, 1b_1m.ib, 1b_1m.fb, 1b_1m.mb,\
    1b_1m.lx")
(final_presence_set "1b_0mi_bs"  "1b_0mi.i, 1b_0mi.i")
(final_presence_set "1b_1mi_bs"  "1b_1mi.i, 1b_1mi.i")
(final_presence_set "1b_0mm_bs"  "1b_0mm.i, 1b_0mm.f, 1b_0mm.b")
(final_presence_set "1b_1mm_bs"  "1b_1mm.i, 1b_1mm.b")
(final_presence_set "1b_0mf_bs"  "1b_0mf.i, 1b_0mf.b")
(final_presence_set "1b_1mf_bs"  "1b_1mf.i, 1b_1mf.b")
(final_presence_set "1b_0b_bs"  "1b_0b.bb")
(final_presence_set "1b_1b_bs"  "1b_1b.bb")
(final_presence_set "1b_0bb_bs"  "1b_0bb.b")
(final_presence_set "1b_1bb_bs"  "1b_1bb.b")
(final_presence_set "1b_0mb_bs"  "1b_0mb.b")
(final_presence_set "1b_1mb_bs"  "1b_1mb.b")

(exclusion_set "1b_0m_bs"
   "1b_0mi.i, 1b_0mm.i, 1b_0mm.f, 1b_0mf.i, 1b_0mb.b,\
    1b_0mi.b, 1b_0mf.b, 1b_0mm.b, 1b_0mlx., 1b_m0_stop")
(exclusion_set "1b_1m_bs"
   "1b_1mi.i, 1b_1mm.i, 1b_1mf.i, 1b_1mb.b, 1b_1mi.b, 1b_1mf.b, 1b_1mm.b,\
    1b_1mlx., 1b_m1_stop")
(exclusion_set "1b_0mi_bs"  "1b_0mii., 1b_0mib., 1b_mi0_stop")
(exclusion_set "1b_1mi_bs"  "1b_1mii., 1b_1mib., 1b_mi1_stop")
(exclusion_set "1b_0mm_bs"  "1b_0mmi., 1b_0mmf., 1b_0mmb.")
(exclusion_set "1b_1mm_bs"  "1b_1mmi., 1b_1mmb.")
(exclusion_set "1b_0mf_bs"  "1b_0mfi., 1b_0mfb.")
(exclusion_set "1b_1mf_bs"  "1b_1mfi., 1b_1mfb.")
(exclusion_set "1b_0b_bs"  "1b_0bb.b")
(exclusion_set "1b_1b_bs"  "1b_1bb.b")
(exclusion_set "1b_0bb_bs"  "1b_0bbb.")
(exclusion_set "1b_1bb_bs"  "1b_1bbb.")
(exclusion_set "1b_0mb_bs"  "1b_0mbb.")
(exclusion_set "1b_1mb_bs"  "1b_1mbb.")

(exclusion_set
   "1b_0m_bs, 1b_0mi_bs, 1b_0mm_bs, 1b_0mf_bs, 1b_0b_bs, 1b_0bb_bs, 1b_0mb_bs,
    1b_1m_bs, 1b_1mi_bs, 1b_1mm_bs, 1b_1mf_bs, 1b_1b_bs, 1b_1bb_bs, 1b_1mb_bs"
   "1b_stop")

(final_presence_set
   "1b_0mi.i, 1b_0mm.i, 1b_0mf.i, 1b_0mm.f, 1b_0mb.b,\
    1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx."
   "1b_m_cont")
(final_presence_set "1b_0mii., 1b_0mib." "1b_mi_cont")
(final_presence_set "1b_0mmi., 1b_0mmf., 1b_0mmb." "1b_mm_cont")
(final_presence_set "1b_0mfi., 1b_0mfb." "1b_mf_cont")
(final_presence_set "1b_0bb.b" "1b_b_cont")
(final_presence_set "1b_0bbb." "1b_bb_cont")
(final_presence_set "1b_0mbb." "1b_mb_cont")

(exclusion_set
   "1b_0m.ii, 1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\
    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx"
   "1b_m_cont, 1b_mi_cont, 1b_mm_cont, 1b_mf_cont,\
    1b_mb_cont, 1b_b_cont, 1b_bb_cont")

(exclusion_set "1b_empty"
               "1b_m_cont,1b_mi_cont,1b_mm_cont,1b_mf_cont,\
                1b_mb_cont,1b_b_cont,1b_bb_cont")

;; For m;mi bundle
(final_presence_set "1b_m0_stop" "1b_0m.mi")
(final_presence_set "1b_0mm.i" "1b_0mmi_cont")
(exclusion_set "1b_0mmi_cont"
   "1b_0m.ii, 1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\
    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_m0_stop" "1b_0mm.i")
(final_presence_set "1b_m1_stop" "1b_1m.mi")
(exclusion_set "1b_m1_stop" "1b_1mm.i")
(final_presence_set "1b_m_stop" "1b_m0_stop, 1b_m1_stop")

;; For mi;i bundle
(final_presence_set "1b_mi0_stop" "1b_0mi.i")
(final_presence_set "1b_0mii." "1b_0mii_cont")
(exclusion_set "1b_0mii_cont"
   "1b_0m.ii, 1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\
    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx")
(exclusion_set "1b_mi0_stop" "1b_0mii.")
(final_presence_set "1b_mi1_stop" "1b_1mi.i")
(exclusion_set "1b_mi1_stop" "1b_1mii.")
(final_presence_set "1b_mi_stop" "1b_mi0_stop, 1b_mi1_stop")

(final_absence_set
   "1b_0m.ii,1b_0mi.i,1b_0mii.,1b_0m.mi,1b_0mm.i,1b_0mmi.,\
    1b_0m.fi,1b_0mf.i,1b_0mfi.,1b_0m.mf,1b_0mm.f,1b_0mmf.,\
    1b_0b.bb,1b_0bb.b,1b_0bbb.,1b_0m.bb,1b_0mb.b,1b_0mbb.,\
    1b_0m.ib,1b_0mi.b,1b_0mib.,1b_0m.mb,1b_0mm.b,1b_0mmb.,\
    1b_0m.fb,1b_0mf.b,1b_0mfb.,1b_0m.lx,1b_0mlx., \
    1b_1m.ii,1b_1mi.i,1b_1mii.,1b_1m.mi,1b_1mm.i,1b_1mmi.,\
    1b_1m.fi,1b_1mf.i,1b_1mfi.,\
    1b_1b.bb,1b_1bb.b,1b_1bbb.,1b_1m.bb,1b_1mb.b,1b_1mbb.,\
    1b_1m.ib,1b_1mi.b,1b_1mib.,1b_1m.mb,1b_1mm.b,1b_1mmb.,\
    1b_1m.fb,1b_1mf.b,1b_1mfb.,1b_1m.lx,1b_1mlx."
   "1b_m0_stop,1b_m1_stop,1b_mi0_stop,1b_mi1_stop")

(define_reservation "1b_A" "1b_M|1b_I")

(define_insn_reservation "1b_stop_bit" 0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "stop_bit"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_stop|1b_m0_stop|1b_m1_stop|1b_mi0_stop|1b_mi1_stop")
(define_insn_reservation "1b_br"      0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "br"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_B")
(define_insn_reservation "1b_scall"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "scall"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_B")
(define_insn_reservation "1b_fcmp"    2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fcmp"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_F+1b_not_uf1")
(define_insn_reservation "1b_fcvtfx"  7
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fcvtfx"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_F")
(define_insn_reservation "1b_fld"     9
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fld"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_M")
(define_insn_reservation "1b_fmac"    5
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fmac"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_F")
(define_insn_reservation "1b_fmisc"   5
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "fmisc"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_F+1b_not_uf1")
(define_insn_reservation "1b_frar_i" 13
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frar_i"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_frar_m"  6
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frar_m"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_M+1b_not_um1")
(define_insn_reservation "1b_frbr"    2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frbr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_frfr"    2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frfr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_M+1b_not_um1")
(define_insn_reservation "1b_frpr"    2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "frpr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_ialu"      1
    (and (and (eq_attr "cpu" "itanium")
              (eq_attr "itanium_class" "ialu"))
         (ne (symbol_ref
	      "bundling_p && !ia64_produce_address_p (insn)")
             (const_int 0)))
    "1b_A")
(define_insn_reservation "1b_ialu_addr" 1
    (and (and (eq_attr "cpu" "itanium")
              (eq_attr "itanium_class" "ialu"))
         (eq (symbol_ref
              "bundling_p && ia64_produce_address_p (insn)")
             (const_int 1)))
    "1b_M")
(define_insn_reservation "1b_icmp"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "icmp"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_A")
(define_insn_reservation "1b_ilog"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "ilog"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_A")
(define_insn_reservation "1b_ishf"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "ishf"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_ld"      2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "ld"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_M")
(define_insn_reservation "1b_long_i"  1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "long_i"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_L")
(define_insn_reservation "1b_mmmul"   2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "mmmul"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_mmshf"   2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "mmshf"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_I")
(define_insn_reservation "1b_mmshfi"  2
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "mmshfi"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_I")
(define_insn_reservation "1b_rse_m"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "rse_m"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
   "(1b_0m.ii|1b_0m.mi|1b_0m.fi|1b_0m.mf|1b_0b.bb|1b_0m.bb\
     |1b_0m.ib|1b_0m.mb|1b_0m.fb|1b_0m.lx)+1_1+1b_um0")
(define_insn_reservation "1b_sem"     0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "sem"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_M+1b_not_um1")
(define_insn_reservation "1b_stf"     1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "stf"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_M")
(define_insn_reservation "1b_st"      1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "st"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_M")
(define_insn_reservation "1b_syst_m0" 0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "syst_m0"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_M+1b_not_um1")
(define_insn_reservation "1b_syst_m"  0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "syst_m"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_M")
(define_insn_reservation "1b_tbit"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "tbit"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_toar_i"  0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "toar_i"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_toar_m"  5
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "toar_m"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_M+1b_not_um1")
(define_insn_reservation "1b_tobr"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "tobr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_tofr"    9
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "tofr"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_M")
(define_insn_reservation "1b_topr"    1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "topr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_I+1b_not_ui1")
(define_insn_reservation "1b_xmpy"    7
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "xmpy"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_F")
(define_insn_reservation "1b_xtd"     1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "xtd"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_I")
(define_insn_reservation "1b_chk_s"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "chk_s"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_A")
(define_insn_reservation "1b_lfetch"  0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "lfetch"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_M")
(define_insn_reservation "1b_nop_m"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_m"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_M")
(define_insn_reservation "1b_nop_b"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_b"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_NB")
(define_insn_reservation "1b_nop_i"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_i"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_I")
(define_insn_reservation "1b_nop_f"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_f"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_F")
(define_insn_reservation "1b_nop_x"   0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop_x"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "1b_L")
(define_insn_reservation "1b_unknown" 1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "unknown"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_empty")
(define_insn_reservation "1b_nop" 1
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "nop"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "1b_M|1b_NB|1b_I|1b_F")
(define_insn_reservation "1b_ignore" 0
  (and (and (eq_attr "cpu" "itanium")
            (eq_attr "itanium_class" "ignore"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "nothing")

(define_insn_reservation "1b_pre_cycle" 0
   (and (and (eq_attr "cpu" "itanium")
             (eq_attr "itanium_class" "pre_cycle"))
        (ne (symbol_ref "bundling_p") (const_int 0)))
                         "(1b_0m_bs, 1b_m_cont)     \
                          | (1b_0mi_bs, 1b_mi_cont) \
                          | (1b_0mm_bs, 1b_mm_cont) \
                          | (1b_0mf_bs, 1b_mf_cont) \
                          | (1b_0b_bs, 1b_b_cont)   \
                          | (1b_0bb_bs, 1b_bb_cont) \
                          | (1b_0mb_bs, 1b_mb_cont) \
                          | (1b_1m_bs, 1b_m_cont)   \
                          | (1b_1mi_bs, 1b_mi_cont) \
                          | (1b_1mm_bs, 1b_mm_cont) \
                          | (1b_1mf_bs, 1b_mf_cont) \
                          | (1b_1b_bs, 1b_b_cont)   \
                          | (1b_1bb_bs, 1b_bb_cont) \
                          | (1b_1mb_bs, 1b_mb_cont) \
                          | (1b_m_stop, 1b_0mmi_cont)   \
                          | (1b_mi_stop, 1b_0mii_cont)")



(define_automaton "two")

;;   All possible combinations of bundles/syllables
(define_cpu_unit "2_0m.ii, 2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\
                  2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx" "two")
(define_cpu_unit "2_0mi.i, 2_0mm.i, 2_0mf.i, 2_0mm.f, 2_0bb.b, 2_0mb.b,\
                  2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx." "two")
(define_cpu_unit "2_0mii., 2_0mmi., 2_0mfi., 2_0mmf., 2_0bbb., 2_0mbb.,\
                  2_0mib., 2_0mmb., 2_0mfb." "two")

(define_cpu_unit "2_1m.ii, 2_1m.mi, 2_1m.fi, 2_1m.mf, 2_1b.bb, 2_1m.bb,\
                  2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx" "two")
(define_cpu_unit "2_1mi.i, 2_1mm.i, 2_1mf.i, 2_1mm.f, 2_1bb.b, 2_1mb.b,\
                  2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx." "two")
(define_cpu_unit "2_1mii., 2_1mmi., 2_1mfi., 2_1mmf., 2_1bbb., 2_1mbb.,\
                  2_1mib., 2_1mmb., 2_1mfb." "two")

;; Slot 1
(exclusion_set "2_0m.ii" "2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\
                          2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx")
(exclusion_set "2_0m.mi" "2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb, 2_0m.ib,\
                          2_0m.mb, 2_0m.fb, 2_0m.lx")
(exclusion_set "2_0m.fi" "2_0m.mf, 2_0b.bb, 2_0m.bb, 2_0m.ib, 2_0m.mb,\
                          2_0m.fb, 2_0m.lx")
(exclusion_set "2_0m.mf" "2_0b.bb, 2_0m.bb, 2_0m.ib, 2_0m.mb, 2_0m.fb,\
	                  2_0m.lx")
(exclusion_set "2_0b.bb" "2_0m.bb, 2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx")
(exclusion_set "2_0m.bb" "2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx")
(exclusion_set "2_0m.ib" "2_0m.mb, 2_0m.fb, 2_0m.lx")
(exclusion_set "2_0m.mb" "2_0m.fb, 2_0m.lx")
(exclusion_set "2_0m.fb" "2_0m.lx")

;; Slot 2
(exclusion_set "2_0mi.i" "2_0mm.i, 2_0mf.i, 2_0mm.f, 2_0bb.b, 2_0mb.b,\
                          2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.")
(exclusion_set "2_0mm.i" "2_0mf.i, 2_0mm.f, 2_0bb.b, 2_0mb.b,\
                          2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.")
(exclusion_set "2_0mf.i" "2_0mm.f, 2_0bb.b, 2_0mb.b, 2_0mi.b, 2_0mm.b,\
                          2_0mf.b, 2_0mlx.")
(exclusion_set "2_0mm.f" "2_0bb.b, 2_0mb.b, 2_0mi.b, 2_0mm.b, 2_0mf.b,\
                          2_0mlx.")
(exclusion_set "2_0bb.b" "2_0mb.b, 2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.")
(exclusion_set "2_0mb.b" "2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.")
(exclusion_set "2_0mi.b" "2_0mm.b, 2_0mf.b, 2_0mlx.")
(exclusion_set "2_0mm.b" "2_0mf.b, 2_0mlx.")
(exclusion_set "2_0mf.b" "2_0mlx.")

;; Slot 3
(exclusion_set "2_0mii." "2_0mmi., 2_0mfi., 2_0mmf., 2_0bbb., 2_0mbb.,\
                          2_0mib., 2_0mmb., 2_0mfb., 2_0mlx.")
(exclusion_set "2_0mmi." "2_0mfi., 2_0mmf., 2_0bbb., 2_0mbb.,\
                          2_0mib., 2_0mmb., 2_0mfb., 2_0mlx.")
(exclusion_set "2_0mfi." "2_0mmf., 2_0bbb., 2_0mbb., 2_0mib., 2_0mmb.,\
                          2_0mfb., 2_0mlx.")
(exclusion_set "2_0mmf." "2_0bbb., 2_0mbb., 2_0mib., 2_0mmb., 2_0mfb.,\
                          2_0mlx.")
(exclusion_set "2_0bbb." "2_0mbb., 2_0mib., 2_0mmb., 2_0mfb., 2_0mlx.")
(exclusion_set "2_0mbb." "2_0mib., 2_0mmb., 2_0mfb., 2_0mlx.")
(exclusion_set "2_0mib." "2_0mmb., 2_0mfb., 2_0mlx.")
(exclusion_set "2_0mmb." "2_0mfb., 2_0mlx.")
(exclusion_set "2_0mfb." "2_0mlx.")

;; Slot 4
(exclusion_set "2_1m.ii" "2_1m.mi, 2_1m.fi, 2_1m.mf, 2_1b.bb, 2_1m.bb,\
                          2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx")
(exclusion_set "2_1m.mi" "2_1m.fi, 2_1m.mf, 2_1b.bb, 2_1m.bb, 2_1m.ib,\
                          2_1m.mb, 2_1m.fb, 2_1m.lx")
(exclusion_set "2_1m.fi" "2_1m.mf, 2_1b.bb, 2_1m.bb, 2_1m.ib, 2_1m.mb,\
                          2_1m.fb, 2_1m.lx")
(exclusion_set "2_1m.mf" "2_1b.bb, 2_1m.bb, 2_1m.ib, 2_1m.mb, 2_1m.fb,\
                          2_1m.lx")
(exclusion_set "2_1b.bb" "2_1m.bb, 2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx")
(exclusion_set "2_1m.bb" "2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx")
(exclusion_set "2_1m.ib" "2_1m.mb, 2_1m.fb, 2_1m.lx")
(exclusion_set "2_1m.mb" "2_1m.fb, 2_1m.lx")
(exclusion_set "2_1m.fb" "2_1m.lx")

;; Slot 5
(exclusion_set "2_1mi.i" "2_1mm.i, 2_1mf.i, 2_1mm.f, 2_1bb.b, 2_1mb.b,\
                          2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.")
(exclusion_set "2_1mm.i" "2_1mf.i, 2_1mm.f, 2_1bb.b, 2_1mb.b,\
                          2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.")
(exclusion_set "2_1mf.i" "2_1mm.f, 2_1bb.b, 2_1mb.b, 2_1mi.b, 2_1mm.b,\
                          2_1mf.b, 2_1mlx.")
(exclusion_set "2_1mm.f" "2_1bb.b, 2_1mb.b, 2_1mi.b, 2_1mm.b, 2_1mf.b,\
                          2_1mlx.")
(exclusion_set "2_1bb.b" "2_1mb.b, 2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.")
(exclusion_set "2_1mb.b" "2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.")
(exclusion_set "2_1mi.b" "2_1mm.b, 2_1mf.b, 2_1mlx.")
(exclusion_set "2_1mm.b" "2_1mf.b, 2_1mlx.")
(exclusion_set "2_1mf.b" "2_1mlx.")

;; Slot 6
(exclusion_set "2_1mii." "2_1mmi., 2_1mfi., 2_1mmf., 2_1bbb., 2_1mbb.,\
                          2_1mib., 2_1mmb., 2_1mfb., 2_1mlx.")
(exclusion_set "2_1mmi." "2_1mfi., 2_1mmf., 2_1bbb., 2_1mbb.,\
                          2_1mib., 2_1mmb., 2_1mfb., 2_1mlx.")
(exclusion_set "2_1mfi." "2_1mmf., 2_1bbb., 2_1mbb., 2_1mib., 2_1mmb.,\
                          2_1mfb., 2_1mlx.")
(exclusion_set "2_1mmf." "2_1bbb., 2_1mbb., 2_1mib., 2_1mmb., 2_1mfb.,\
                          2_1mlx.")
(exclusion_set "2_1bbb." "2_1mbb., 2_1mib., 2_1mmb., 2_1mfb., 2_1mlx.")
(exclusion_set "2_1mbb." "2_1mib., 2_1mmb., 2_1mfb., 2_1mlx.")
(exclusion_set "2_1mib." "2_1mmb., 2_1mfb., 2_1mlx.")
(exclusion_set "2_1mmb." "2_1mfb., 2_1mlx.")
(exclusion_set "2_1mfb." "2_1mlx.")

(final_presence_set "2_0mi.i" "2_0m.ii")
(final_presence_set "2_0mii." "2_0mi.i")
(final_presence_set "2_1mi.i" "2_1m.ii")
(final_presence_set "2_1mii." "2_1mi.i")

(final_presence_set "2_0mm.i" "2_0m.mi")
(final_presence_set "2_0mmi." "2_0mm.i")
(final_presence_set "2_1mm.i" "2_1m.mi")
(final_presence_set "2_1mmi." "2_1mm.i")

(final_presence_set "2_0mf.i" "2_0m.fi")
(final_presence_set "2_0mfi." "2_0mf.i")
(final_presence_set "2_1mf.i" "2_1m.fi")
(final_presence_set "2_1mfi." "2_1mf.i")

(final_presence_set "2_0mm.f" "2_0m.mf")
(final_presence_set "2_0mmf." "2_0mm.f")
(final_presence_set "2_1mm.f" "2_1m.mf")
(final_presence_set "2_1mmf." "2_1mm.f")

(final_presence_set "2_0bb.b" "2_0b.bb")
(final_presence_set "2_0bbb." "2_0bb.b")
(final_presence_set "2_1bb.b" "2_1b.bb")
(final_presence_set "2_1bbb." "2_1bb.b")

(final_presence_set "2_0mb.b" "2_0m.bb")
(final_presence_set "2_0mbb." "2_0mb.b")
(final_presence_set "2_1mb.b" "2_1m.bb")
(final_presence_set "2_1mbb." "2_1mb.b")

(final_presence_set "2_0mi.b" "2_0m.ib")
(final_presence_set "2_0mib." "2_0mi.b")
(final_presence_set "2_1mi.b" "2_1m.ib")
(final_presence_set "2_1mib." "2_1mi.b")

(final_presence_set "2_0mm.b" "2_0m.mb")
(final_presence_set "2_0mmb." "2_0mm.b")
(final_presence_set "2_1mm.b" "2_1m.mb")
(final_presence_set "2_1mmb." "2_1mm.b")

(final_presence_set "2_0mf.b" "2_0m.fb")
(final_presence_set "2_0mfb." "2_0mf.b")
(final_presence_set "2_1mf.b" "2_1m.fb")
(final_presence_set "2_1mfb." "2_1mf.b")

(final_presence_set "2_0mlx." "2_0m.lx")
(final_presence_set "2_1mlx." "2_1m.lx")

;;   The following reflects the dual issue bundle types table.
;;   We could place all possible combinations here because impossible
;; combinations would go away by the subsequent constrains.
(final_presence_set
   "2_1m.lx"
   "2_0mmi.,2_0mfi.,2_0mmf.,2_0mib.,2_0mmb.,2_0mfb.,2_0mlx.")
(final_presence_set "2_1b.bb" "2_0mii.,2_0mmi.,2_0mfi.,2_0mmf.,2_0mlx.")
(final_presence_set
   "2_1m.ii,2_1m.mi,2_1m.fi,2_1m.mf,2_1m.bb,2_1m.ib,2_1m.mb,2_1m.fb"
   "2_0mii.,2_0mmi.,2_0mfi.,2_0mmf.,2_0mib.,2_0mmb.,2_0mfb.,2_0mlx.")

;;  Ports/units (nb means nop.b insn issued into given port):
(define_cpu_unit
   "2_um0, 2_um1, 2_um2, 2_um3, 2_ui0, 2_ui1, 2_uf0, 2_uf1,\
    2_ub0, 2_ub1, 2_ub2, 2_unb0, 2_unb1, 2_unb2" "two")

(exclusion_set "2_ub0" "2_unb0")
(exclusion_set "2_ub1" "2_unb1")
(exclusion_set "2_ub2" "2_unb2")

;; The following rules are used to decrease number of alternatives.
;; They are consequences of Itanium2 microarchitecture.  They also
;; describe the following rules mentioned in Itanium2
;; microarchitecture: rules mentioned in Itanium2 microarchitecture:
;; o "BBB/MBB: Always splits issue after either of these bundles".
;; o "MIB BBB: Split issue after the first bundle in this pair".
(exclusion_set
   "2_0b.bb,2_0bb.b,2_0bbb.,2_0m.bb,2_0mb.b,2_0mbb."
   "2_1m.ii,2_1m.mi,2_1m.fi,2_1m.mf,2_1b.bb,2_1m.bb,\
    2_1m.ib,2_1m.mb,2_1m.fb,2_1m.lx")
(exclusion_set "2_0m.ib,2_0mi.b,2_0mib." "2_1b.bb")

;;; "MIB/MFB/MMB: Splits issue after any of these bundles unless the
;;; B-slot contains a nop.b or a brp instruction".
;;;   "The B in an MIB/MFB/MMB bundle disperses to B0 if it is a brp or
;;; nop.b, otherwise it disperses to B2".
(final_absence_set
   "2_1m.ii, 2_1m.mi, 2_1m.fi, 2_1m.mf, 2_1b.bb, 2_1m.bb,\
    2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx"
   "2_0mib. 2_ub2, 2_0mfb. 2_ub2, 2_0mmb. 2_ub2")

;; This is necessary to start new processor cycle when we meet stop bit.
(define_cpu_unit "2_stop" "two")
(final_absence_set
   "2_0m.ii,2_0mi.i,2_0mii.,2_0m.mi,2_0mm.i,2_0mmi.,2_0m.fi,2_0mf.i,2_0mfi.,\
    2_0m.mf,2_0mm.f,2_0mmf.,2_0b.bb,2_0bb.b,2_0bbb.,2_0m.bb,2_0mb.b,2_0mbb.,\
    2_0m.ib,2_0mi.b,2_0mib.,2_0m.mb,2_0mm.b,2_0mmb.,2_0m.fb,2_0mf.b,2_0mfb.,\
    2_0m.lx,2_0mlx., \
    2_1m.ii,2_1mi.i,2_1mii.,2_1m.mi,2_1mm.i,2_1mmi.,2_1m.fi,2_1mf.i,2_1mfi.,\
    2_1m.mf,2_1mm.f,2_1mmf.,2_1b.bb,2_1bb.b,2_1bbb.,2_1m.bb,2_1mb.b,2_1mbb.,\
    2_1m.ib,2_1mi.b,2_1mib.,2_1m.mb,2_1mm.b,2_1mmb.,2_1m.fb,2_1mf.b,2_1mfb.,\
    2_1m.lx,2_1mlx."
   "2_stop")

;;   The issue logic can reorder M slot insns between different subtypes
;; but can not reorder insn within the same subtypes.  The following
;; constraint is enough to describe this.
(final_presence_set "2_um1" "2_um0")
(final_presence_set "2_um3" "2_um2")

;;   The insn in the 1st I slot of the two bundle issue group will issue
;; to I0.  The second I slot insn will issue to I1.
(final_presence_set "2_ui1" "2_ui0")

;;  For exceptions of I insns:
(define_cpu_unit "2_only_ui0" "two")
(final_absence_set "2_only_ui0"  "2_ui1")

;; Insns

(define_reservation "2_M0"
  "(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\
    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\
    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\
   +(2_um0|2_um1|2_um2|2_um3)")

(define_reservation "2_M1"
  "(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\
    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\
   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\
   +(2_um0|2_um1|2_um2|2_um3)")

(define_reservation "2_M" "2_M0|2_M1")

(define_reservation "2_M0_only_um0"
  "(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\
    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\
    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\
   +2_um0")

(define_reservation "2_M1_only_um0"
  "(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\
    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\
   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\
   +2_um0")

(define_reservation "2_M_only_um0" "2_M0_only_um0|2_M1_only_um0")

(define_reservation "2_M0_only_um2"
  "(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\
    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\
    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\
   +2_um2")

(define_reservation "2_M1_only_um2"
  "(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\
    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\
   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\
   +2_um2")

(define_reservation "2_M_only_um2" "2_M0_only_um2|2_M1_only_um2")

(define_reservation "2_M0_only_um23"
  "(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\
    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\
    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\
   +(2_um2|2_um3)")

(define_reservation "2_M1_only_um23"
  "(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\
    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\
   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\
   +(2_um2|2_um3)")

(define_reservation "2_M_only_um23" "2_M0_only_um23|2_M1_only_um23")

(define_reservation "2_M0_only_um01"
  "(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\
    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\
    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\
   +(2_um0|2_um1)")

(define_reservation "2_M1_only_um01"
  "(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\
    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\
   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\
   +(2_um0|2_um1)")

(define_reservation "2_M_only_um01" "2_M0_only_um01|2_M1_only_um01")

;; I instruction is dispersed to the lowest numbered I unit
;; not already in use.  Remeber about possible spliting.
(define_reservation "2_I0"
  "2_0mi.i+2_ui0|2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0\
   |2_0mfi.+2_ui0|2_0mi.b+2_ui0|(2_1mi.i|2_1mi.b)+(2_ui0|2_ui1)\
   |(2_1mii.|2_1mmi.|2_1mfi.)+(2_ui0|2_ui1)")

(define_reservation "2_I1"
  "2_0m.ii+(2_um0|2_um1|2_um2|2_um3)+2_0mi.i+2_ui0\
   |2_0mm.i+(2_um0|2_um1|2_um2|2_um3)+2_0mmi.+2_ui0\
   |2_0mf.i+2_uf0+2_0mfi.+2_ui0\
   |2_0m.ib+(2_um0|2_um1|2_um2|2_um3)+2_0mi.b+2_ui0\
   |(2_1m.ii+2_1mi.i|2_1m.ib+2_1mi.b)+(2_um0|2_um1|2_um2|2_um3)+(2_ui0|2_ui1)\
   |2_1mm.i+(2_um0|2_um1|2_um2|2_um3)+2_1mmi.+(2_ui0|2_ui1)\
   |2_1mf.i+2_uf1+2_1mfi.+(2_ui0|2_ui1)")

(define_reservation "2_I" "2_I0|2_I1")

;; "An F slot in the 1st bundle disperses to F0".
;; "An F slot in the 2st bundle disperses to F1".
(define_reservation "2_F0"
   "2_0mf.i+2_uf0|2_0mmf.+2_uf0|2_0mf.b+2_uf0\
    |2_1mf.i+2_uf1|2_1mmf.+2_uf1|2_1mf.b+2_uf1")

(define_reservation "2_F1"
   "(2_0m.fi+2_0mf.i|2_0mm.f+2_0mmf.|2_0m.fb+2_0mf.b)\
    +(2_um0|2_um1|2_um2|2_um3)+2_uf0\
    |(2_1m.fi+2_1mf.i|2_1mm.f+2_1mmf.|2_1m.fb+2_1mf.b)\
     +(2_um0|2_um1|2_um2|2_um3)+2_uf1")

(define_reservation "2_F2"
   "(2_0m.mf+2_0mm.f+2_0mmf.+2_uf0|2_1m.mf+2_1mm.f+2_1mmf.+2_uf1)\
    +(2_um0|2_um1|2_um2|2_um3)+(2_um0|2_um1|2_um2|2_um3)\
    |(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0\
      |2_0mmf.+(2_um0|2_um1|2_um2|2_um3)\
      |2_0mib.+2_unb0|2_0mmb.+2_unb0|2_0mfb.+2_unb0)\
     +(2_1m.fi+2_1mf.i|2_1m.fb+2_1mf.b)+(2_um0|2_um1|2_um2|2_um3)+2_uf1")

(define_reservation "2_F" "2_F0|2_F1|2_F2")

;;; "Each B slot in MBB or BBB bundle disperses to the corresponding B
;;; unit. That is, a B slot in 1st position is despersed to B0.  In the
;;; 2nd position it is dispersed to B2".
(define_reservation "2_NB"
    "2_0b.bb+2_unb0|2_0bb.b+2_unb1|2_0bbb.+2_unb2\
     |2_0mb.b+2_unb1|2_0mbb.+2_unb2|2_0mib.+2_unb0\
     |2_0mmb.+2_unb0|2_0mfb.+2_unb0\
     |2_1b.bb+2_unb0|2_1bb.b+2_unb1
     |2_1bbb.+2_unb2|2_1mb.b+2_unb1|2_1mbb.+2_unb2\
     |2_1mib.+2_unb0|2_1mmb.+2_unb0|2_1mfb.+2_unb0")

(define_reservation "2_B0"
   "2_0b.bb+2_ub0|2_0bb.b+2_ub1|2_0bbb.+2_ub2\
    |2_0mb.b+2_ub1|2_0mbb.+2_ub2|2_0mib.+2_ub2\
    |2_0mfb.+2_ub2|2_1b.bb+2_ub0|2_1bb.b+2_ub1\
    |2_1bbb.+2_ub2|2_1mb.b+2_ub1\
    |2_1mib.+2_ub2|2_1mmb.+2_ub2|2_1mfb.+2_ub2")

(define_reservation "2_B1"
   "2_0m.bb+(2_um0|2_um1|2_um2|2_um3)+2_0mb.b+2_ub1\
    |2_0mi.b+2_ui0+2_0mib.+2_ub2\
    |2_0mm.b+(2_um0|2_um1|2_um2|2_um3)+2_0mmb.+2_ub2\
    |2_0mf.b+2_uf0+2_0mfb.+2_ub2\
    |(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0)\
     +2_1b.bb+2_ub0\
    |2_1m.bb+(2_um0|2_um1|2_um2|2_um3)+2_1mb.b+2_ub1\
    |2_1mi.b+(2_ui0|2_ui1)+2_1mib.+2_ub2\
    |2_1mm.b+(2_um0|2_um1|2_um2|2_um3)+2_1mmb.+2_ub2\
    |2_1mf.b+2_uf1+2_1mfb.+2_ub2")

(define_reservation "2_B" "2_B0|2_B1")

;; MLX bunlde uses ports equivalent to MFI bundles.

;;   For the MLI template, the I slot insn is always assigned to port I0
;; if it is in the first bundle or it is assigned to port I1 if it is in
;; the second bundle.
(define_reservation "2_L0" "2_0mlx.+2_ui0+2_uf0|2_1mlx.+2_ui1+2_uf1")

(define_reservation "2_L1"
   "2_0m.lx+(2_um0|2_um1|2_um2|2_um3)+2_0mlx.+2_ui0+2_uf0\
   |2_1m.lx+(2_um0|2_um1|2_um2|2_um3)+2_1mlx.+2_ui1+2_uf1")

(define_reservation "2_L2"
   "(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\
     |2_0mib.+2_unb0|2_0mmb.+2_unb0|2_0mfb.+2_unb0)
    +2_1m.lx+(2_um0|2_um1|2_um2|2_um3)+2_1mlx.+2_ui1+2_uf1")

(define_reservation "2_L" "2_L0|2_L1|2_L2")

;;   Should we describe that A insn in I slot can be issued into M
;; ports?  I think it is not necessary because of multipass
;; scheduling.  For example, the multipass scheduling could use
;; MMI-MMI instead of MII-MII where the two last I slots contain A
;; insns (even if the case is complicated by use-def conflicts).
;;
;; In any case we could describe it as
;;    (define_cpu_unit "2_ui1_0pres,2_ui1_1pres,2_ui1_2pres,2_ui1_3pres" "two")
;;    (final_presence_set "2_ui1_0pres,2_ui1_1pres,2_ui1_2pres,2_ui1_3pres"
;;                        "2_ui1")
;;    (define_reservation "b_A"
;;       "b_M|b_I\
;;        |(2_1mi.i|2_1mii.|2_1mmi.|2_1mfi.|2_1mi.b)+(2_um0|2_um1|2_um2|2_um3)\
;;         +(2_ui1_0pres|2_ui1_1pres|2_ui1_2pres|2_ui1_3pres)")

(define_reservation "2_A" "2_M|2_I")

;; We assume that there is no insn issued on the same cycle as the
;; unknown insn.
(define_cpu_unit "2_empty" "two")
(exclusion_set "2_empty"
    "2_0m.ii,2_0m.mi,2_0m.fi,2_0m.mf,2_0b.bb,2_0m.bb,2_0m.ib,2_0m.mb,2_0m.fb,\
     2_0m.lx")

(define_cpu_unit
   "2_0m_bs, 2_0mi_bs, 2_0mm_bs, 2_0mf_bs, 2_0b_bs, 2_0bb_bs, 2_0mb_bs"
   "two")
(define_cpu_unit
   "2_1m_bs, 2_1mi_bs, 2_1mm_bs, 2_1mf_bs, 2_1b_bs, 2_1bb_bs, 2_1mb_bs"
   "two")

(define_cpu_unit "2_m_cont, 2_mi_cont, 2_mm_cont, 2_mf_cont, 2_mb_cont,\
	          2_b_cont, 2_bb_cont" "two")

;; For stop in the middle of the bundles.
(define_cpu_unit "2_m_stop, 2_m0_stop, 2_m1_stop, 2_0mmi_cont" "two")
(define_cpu_unit "2_mi_stop, 2_mi0_stop, 2_mi1_stop, 2_0mii_cont" "two")

(final_presence_set "2_0m_bs"
   "2_0m.ii, 2_0m.mi, 2_0m.mf, 2_0m.fi, 2_0m.bb,\
    2_0m.ib, 2_0m.fb, 2_0m.mb, 2_0m.lx")
(final_presence_set "2_1m_bs"
   "2_1m.ii, 2_1m.mi, 2_1m.mf, 2_1m.fi, 2_1m.bb,\
    2_1m.ib, 2_1m.fb, 2_1m.mb, 2_1m.lx")
(final_presence_set "2_0mi_bs"  "2_0mi.i, 2_0mi.i")
(final_presence_set "2_1mi_bs"  "2_1mi.i, 2_1mi.i")
(final_presence_set "2_0mm_bs"  "2_0mm.i, 2_0mm.f, 2_0mm.b")
(final_presence_set "2_1mm_bs"  "2_1mm.i, 2_1mm.f, 2_1mm.b")
(final_presence_set "2_0mf_bs"  "2_0mf.i, 2_0mf.b")
(final_presence_set "2_1mf_bs"  "2_1mf.i, 2_1mf.b")
(final_presence_set "2_0b_bs"  "2_0b.bb")
(final_presence_set "2_1b_bs"  "2_1b.bb")
(final_presence_set "2_0bb_bs"  "2_0bb.b")
(final_presence_set "2_1bb_bs"  "2_1bb.b")
(final_presence_set "2_0mb_bs"  "2_0mb.b")
(final_presence_set "2_1mb_bs"  "2_1mb.b")

(exclusion_set "2_0m_bs"
   "2_0mi.i, 2_0mm.i, 2_0mm.f, 2_0mf.i, 2_0mb.b,\
    2_0mi.b, 2_0mf.b, 2_0mm.b, 2_0mlx., 2_m0_stop")
(exclusion_set "2_1m_bs"
   "2_1mi.i, 2_1mm.i, 2_1mm.f, 2_1mf.i, 2_1mb.b,\
    2_1mi.b, 2_1mf.b, 2_1mm.b, 2_1mlx., 2_m1_stop")
(exclusion_set "2_0mi_bs"  "2_0mii., 2_0mib., 2_mi0_stop")
(exclusion_set "2_1mi_bs"  "2_1mii., 2_1mib., 2_mi1_stop")
(exclusion_set "2_0mm_bs"  "2_0mmi., 2_0mmf., 2_0mmb.")
(exclusion_set "2_1mm_bs"  "2_1mmi., 2_1mmf., 2_1mmb.")
(exclusion_set "2_0mf_bs"  "2_0mfi., 2_0mfb.")
(exclusion_set "2_1mf_bs"  "2_1mfi., 2_1mfb.")
(exclusion_set "2_0b_bs"  "2_0bb.b")
(exclusion_set "2_1b_bs"  "2_1bb.b")
(exclusion_set "2_0bb_bs"  "2_0bbb.")
(exclusion_set "2_1bb_bs"  "2_1bbb.")
(exclusion_set "2_0mb_bs"  "2_0mbb.")
(exclusion_set "2_1mb_bs"  "2_1mbb.")

(exclusion_set
   "2_0m_bs, 2_0mi_bs, 2_0mm_bs, 2_0mf_bs, 2_0b_bs, 2_0bb_bs, 2_0mb_bs,
    2_1m_bs, 2_1mi_bs, 2_1mm_bs, 2_1mf_bs, 2_1b_bs, 2_1bb_bs, 2_1mb_bs"
   "2_stop")

(final_presence_set
   "2_0mi.i, 2_0mm.i, 2_0mf.i, 2_0mm.f, 2_0mb.b,\
    2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx."
   "2_m_cont")
(final_presence_set "2_0mii., 2_0mib." "2_mi_cont")
(final_presence_set "2_0mmi., 2_0mmf., 2_0mmb." "2_mm_cont")
(final_presence_set "2_0mfi., 2_0mfb." "2_mf_cont")
(final_presence_set "2_0bb.b" "2_b_cont")
(final_presence_set "2_0bbb." "2_bb_cont")
(final_presence_set "2_0mbb." "2_mb_cont")

(exclusion_set
   "2_0m.ii, 2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\
    2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx"
   "2_m_cont, 2_mi_cont, 2_mm_cont, 2_mf_cont,\
    2_mb_cont, 2_b_cont, 2_bb_cont")

(exclusion_set "2_empty"
               "2_m_cont,2_mi_cont,2_mm_cont,2_mf_cont,\
                2_mb_cont,2_b_cont,2_bb_cont")

;; For m;mi bundle
(final_presence_set "2_m0_stop" "2_0m.mi")
(final_presence_set "2_0mm.i" "2_0mmi_cont")
(exclusion_set "2_0mmi_cont"
   "2_0m.ii, 2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\
    2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx")
(exclusion_set "2_m0_stop" "2_0mm.i")
(final_presence_set "2_m1_stop" "2_1m.mi")
(exclusion_set "2_m1_stop" "2_1mm.i")
(final_presence_set "2_m_stop" "2_m0_stop, 2_m1_stop")

;; For mi;i bundle
(final_presence_set "2_mi0_stop" "2_0mi.i")
(final_presence_set "2_0mii." "2_0mii_cont")
(exclusion_set "2_0mii_cont"
   "2_0m.ii, 2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\
    2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx")
(exclusion_set "2_mi0_stop" "2_0mii.")
(final_presence_set "2_mi1_stop" "2_1mi.i")
(exclusion_set "2_mi1_stop" "2_1mii.")
(final_presence_set "2_mi_stop" "2_mi0_stop, 2_mi1_stop")

(final_absence_set
   "2_0m.ii,2_0mi.i,2_0mii.,2_0m.mi,2_0mm.i,2_0mmi.,2_0m.fi,2_0mf.i,2_0mfi.,\
    2_0m.mf,2_0mm.f,2_0mmf.,2_0b.bb,2_0bb.b,2_0bbb.,2_0m.bb,2_0mb.b,2_0mbb.,\
    2_0m.ib,2_0mi.b,2_0mib.,2_0m.mb,2_0mm.b,2_0mmb.,2_0m.fb,2_0mf.b,2_0mfb.,\
    2_0m.lx,2_0mlx., \
    2_1m.ii,2_1mi.i,2_1mii.,2_1m.mi,2_1mm.i,2_1mmi.,2_1m.fi,2_1mf.i,2_1mfi.,\
    2_1m.mf,2_1mm.f,2_1mmf.,2_1b.bb,2_1bb.b,2_1bbb.,2_1m.bb,2_1mb.b,2_1mbb.,\
    2_1m.ib,2_1mi.b,2_1mib.,2_1m.mb,2_1mm.b,2_1mmb.,2_1m.fb,2_1mf.b,2_1mfb.,\
    2_1m.lx,2_1mlx."
   "2_m0_stop,2_m1_stop,2_mi0_stop,2_mi1_stop")

(define_insn_reservation "2_stop_bit" 0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "stop_bit"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_stop|2_m0_stop|2_m1_stop|2_mi0_stop|2_mi1_stop")

(define_insn_reservation "2_br"      0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "br"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_B")
(define_insn_reservation "2_scall"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "scall"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_B")
(define_insn_reservation "2_fcmp"    2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fcmp"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_F")
(define_insn_reservation "2_fcvtfx"  4
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fcvtfx"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_F")
(define_insn_reservation "2_fld"     6
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fld"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_M")
(define_insn_reservation "2_fmac"    4
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fmac"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_F")
(define_insn_reservation "2_fmisc"   4
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fmisc"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_F")

;; There is only one insn `mov = ar.bsp' for frar_i:
;; Latency time ???
(define_insn_reservation "2_frar_i" 13
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frar_i"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")
;; There is only two insns `mov = ar.unat' or `mov = ar.ccv' for frar_m:
;; Latency time ???
(define_insn_reservation "2_frar_m"  6
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frar_m"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um2")
(define_insn_reservation "2_frbr"    2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frbr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")
(define_insn_reservation "2_frfr"    5
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frfr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um2")
(define_insn_reservation "2_frpr"    2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frpr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")

(define_insn_reservation "2_ialu"      1
    (and (and (eq_attr "cpu" "itanium2")
              (eq_attr "itanium_class" "ialu"))
         (eq (symbol_ref "bundling_p") (const_int 0)))
    "2_A")
(define_insn_reservation "2_icmp"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "icmp"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_A")
(define_insn_reservation "2_ilog"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "ilog"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_A")
;; Latency time ???
(define_insn_reservation "2_ishf"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "ishf"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")
(define_insn_reservation "2_ld"      1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "ld"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um01")
(define_insn_reservation "2_long_i"  1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "long_i"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_L")

(define_insn_reservation "2_mmmul"   2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "mmmul"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")
;; Latency time ???
(define_insn_reservation "2_mmshf"   2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "mmshf"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_I")
;; Latency time ???
(define_insn_reservation "2_mmshfi"  1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "mmshfi"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_I")

;; Now we have only one insn (flushrs) of such class.  We assume that flushrs
;; is the 1st syllable of the bundle after stop bit.
(define_insn_reservation "2_rse_m"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "rse_m"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb\
    |2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx)+2_um0")
(define_insn_reservation "2_sem"     0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "sem"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um23")

(define_insn_reservation "2_stf"     1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "stf"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um23")
(define_insn_reservation "2_st"      1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "st"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um23")
(define_insn_reservation "2_syst_m0" 0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "syst_m0"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um2")
(define_insn_reservation "2_syst_m"  0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "syst_m"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um0")
;; Reservation???
(define_insn_reservation "2_tbit"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "tbit"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")

;; There is only ony insn `mov ar.pfs =' for toar_i:
(define_insn_reservation "2_toar_i"  0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "toar_i"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")
;; There are only ony 2 insns `mov ar.ccv =' and `mov ar.unat =' for toar_m:
;; Latency time ???
(define_insn_reservation "2_toar_m"  5
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "toar_m"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um2")
;; Latency time ???
(define_insn_reservation "2_tobr"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "tobr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")
(define_insn_reservation "2_tofr"    5
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "tofr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um23")
;; Latency time ???
(define_insn_reservation "2_topr"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "topr"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I+2_only_ui0")

(define_insn_reservation "2_xmpy"    4
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "xmpy"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_F")
;; Latency time ???
(define_insn_reservation "2_xtd"     1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "xtd"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_I")

(define_insn_reservation "2_chk_s"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "chk_s"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_I|2_M_only_um23")
(define_insn_reservation "2_lfetch"  0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "lfetch"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M_only_um01")

(define_insn_reservation "2_nop_m"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_m"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_M0")
(define_insn_reservation "2_nop_b"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_b"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_NB")
(define_insn_reservation "2_nop_i"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_i"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_I0")
(define_insn_reservation "2_nop_f"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_f"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_F0")
(define_insn_reservation "2_nop_x"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_x"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_L0")

(define_insn_reservation "2_unknown" 1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "unknown"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "2_empty")

(define_insn_reservation "2_nop" 0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop"))
       (eq (symbol_ref "bundling_p") (const_int 0)))
  "2_M0|2_NB|2_I0|2_F0")

(define_insn_reservation "2_ignore" 0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "ignore"))
       (eq (symbol_ref "bundling_p") (const_int 0))) "nothing")

(define_cpu_unit "2_m_cont_only, 2_b_cont_only" "two")
(define_cpu_unit "2_mi_cont_only, 2_mm_cont_only, 2_mf_cont_only" "two")
(define_cpu_unit "2_mb_cont_only, 2_bb_cont_only" "two")

(final_presence_set "2_m_cont_only" "2_m_cont")
(exclusion_set "2_m_cont_only"
  "2_0mi.i, 2_0mm.i, 2_0mf.i, 2_0mm.f, 2_0mb.b,\
   2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.")

(final_presence_set "2_b_cont_only" "2_b_cont")
(exclusion_set "2_b_cont_only"  "2_0bb.b")

(final_presence_set "2_mi_cont_only" "2_mi_cont")
(exclusion_set "2_mi_cont_only" "2_0mii., 2_0mib.")

(final_presence_set "2_mm_cont_only" "2_mm_cont")
(exclusion_set "2_mm_cont_only" "2_0mmi., 2_0mmf., 2_0mmb.")

(final_presence_set "2_mf_cont_only" "2_mf_cont")
(exclusion_set "2_mf_cont_only" "2_0mfi., 2_0mfb.")

(final_presence_set "2_mb_cont_only" "2_mb_cont")
(exclusion_set "2_mb_cont_only" "2_0mbb.")

(final_presence_set "2_bb_cont_only" "2_bb_cont")
(exclusion_set "2_bb_cont_only" "2_0bbb.")

(define_insn_reservation "2_pre_cycle" 0
   (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "pre_cycle"))
        (eq (symbol_ref "bundling_p") (const_int 0)))
                         "nothing")

;;(define_insn_reservation "2_pre_cycle" 0
;;   (and (and (eq_attr "cpu" "itanium2")
;;             (eq_attr "itanium_class" "pre_cycle"))
;;        (eq (symbol_ref "bundling_p") (const_int 0)))
;;                         "(2_0m_bs, 2_m_cont)                     \
;;                          | (2_0mi_bs, (2_mi_cont|nothing))       \
;;                          | (2_0mm_bs, 2_mm_cont)                 \
;;                          | (2_0mf_bs, (2_mf_cont|nothing))       \
;;                          | (2_0b_bs, (2_b_cont|nothing))         \
;;                          | (2_0bb_bs, (2_bb_cont|nothing))       \
;;                          | (2_0mb_bs, (2_mb_cont|nothing))       \
;;                          | (2_1m_bs, 2_m_cont)                   \
;;                          | (2_1mi_bs, (2_mi_cont|nothing))       \
;;                          | (2_1mm_bs, 2_mm_cont)                 \
;;                          | (2_1mf_bs, (2_mf_cont|nothing))       \
;;                          | (2_1b_bs, (2_b_cont|nothing))         \
;;                          | (2_1bb_bs, (2_bb_cont|nothing))       \
;;                          | (2_1mb_bs, (2_mb_cont|nothing))       \
;;                          | (2_m_cont_only, (2_m_cont|nothing))   \
;;                          | (2_b_cont_only,  (2_b_cont|nothing))  \
;;                          | (2_mi_cont_only, (2_mi_cont|nothing)) \
;;                          | (2_mm_cont_only, (2_mm_cont|nothing)) \
;;                          | (2_mf_cont_only, (2_mf_cont|nothing)) \
;;                          | (2_mb_cont_only, (2_mb_cont|nothing)) \
;;                          | (2_bb_cont_only, (2_bb_cont|nothing)) \
;;                          | (2_m_stop, (2_0mmi_cont|nothing))     \
;;                          | (2_mi_stop, (2_0mii_cont|nothing))")

;; Bypasses:

(define_bypass  1 "2_fcmp" "2_br,2_scall")
(define_bypass  0 "2_icmp" "2_br,2_scall")
(define_bypass  0 "2_tbit" "2_br,2_scall")
(define_bypass  2 "2_ld" "2_ld"  "ia64_ld_address_bypass_p")
(define_bypass  2 "2_ld" "2_st"  "ia64_st_address_bypass_p")
(define_bypass  2 "2_ld" "2_mmmul,2_mmshf")
(define_bypass  3 "2_ilog" "2_mmmul,2_mmshf")
(define_bypass  3 "2_ialu" "2_mmmul,2_mmshf")
(define_bypass  3 "2_mmmul,2_mmshf" "2_ialu,2_ilog,2_ishf,2_st,2_ld")
(define_bypass  6 "2_tofr"  "2_frfr,2_stf")
(define_bypass  7 "2_fmac"  "2_frfr,2_stf")

;; We don't use here fcmp because scall may be predicated.
(define_bypass  0 "2_fcvtfx,2_fld,2_fmac,2_fmisc,2_frar_i,2_frar_m,\
                   2_frbr,2_frfr,2_frpr,2_ialu,2_ilog,2_ishf,2_ld,2_long_i,\
                   2_mmmul,2_mmshf,2_mmshfi,2_toar_m,2_tofr,2_xmpy,2_xtd"
                  "2_scall")

(define_bypass  0 "2_unknown,2_ignore,2_stop_bit,2_br,2_fcmp,2_fcvtfx,2_fld,\
                   2_fmac,2_fmisc,2_frar_i,2_frar_m,2_frbr,2_frfr,2_frpr,\
                   2_ialu,2_icmp,2_ilog,2_ishf,2_ld,2_chk_s,\
                   2_long_i,2_mmmul,2_mmshf,2_mmshfi,2_nop,2_nop_b,2_nop_f,\
                   2_nop_i,2_nop_m,2_nop_x,2_rse_m,2_scall,2_sem,2_stf,2_st,\
                   2_syst_m0,2_syst_m,2_tbit,2_toar_i,2_toar_m,2_tobr,2_tofr,\
                   2_topr,2_xmpy,2_xtd,2_lfetch" "2_ignore")



;; Bundling

(define_automaton "twob")

;; Pseudo units for quicker searching for position in two packet window.  */
(define_query_cpu_unit "2_1,2_2,2_3,2_4,2_5,2_6" "twob")

;;   All possible combinations of bundles/syllables
(define_cpu_unit
   "2b_0m.ii, 2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\
    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx" "twob")
(define_cpu_unit
   "2b_0mi.i, 2b_0mm.i, 2b_0mf.i, 2b_0mm.f, 2b_0bb.b, 2b_0mb.b,\
    2b_0mi.b, 2b_0mm.b, 2b_0mf.b" "twob")
(define_query_cpu_unit
   "2b_0mii., 2b_0mmi., 2b_0mfi., 2b_0mmf., 2b_0bbb., 2b_0mbb.,\
    2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx." "twob")

(define_cpu_unit
   "2b_1m.ii, 2b_1m.mi, 2b_1m.fi, 2b_1m.mf, 2b_1b.bb, 2b_1m.bb,\
    2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx" "twob")
(define_cpu_unit
   "2b_1mi.i, 2b_1mm.i, 2b_1mf.i, 2b_1mm.f, 2b_1bb.b, 2b_1mb.b,\
    2b_1mi.b, 2b_1mm.b, 2b_1mf.b" "twob")
(define_query_cpu_unit
   "2b_1mii., 2b_1mmi., 2b_1mfi., 2b_1mmf., 2b_1bbb., 2b_1mbb.,\
    2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx." "twob")

;; Slot 1
(exclusion_set "2b_0m.ii"
   "2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\
    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_0m.mi"
   "2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb, 2b_0m.ib,\
    2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_0m.fi"
   "2b_0m.mf, 2b_0b.bb, 2b_0m.bb, 2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_0m.mf"
   "2b_0b.bb, 2b_0m.bb, 2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_0b.bb" "2b_0m.bb, 2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_0m.bb" "2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_0m.ib" "2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_0m.mb" "2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_0m.fb" "2b_0m.lx")

;; Slot 2
(exclusion_set "2b_0mi.i"
   "2b_0mm.i, 2b_0mf.i, 2b_0mm.f, 2b_0bb.b, 2b_0mb.b,\
    2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.")
(exclusion_set "2b_0mm.i"
   "2b_0mf.i, 2b_0mm.f, 2b_0bb.b, 2b_0mb.b,\
    2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.")
(exclusion_set "2b_0mf.i"
   "2b_0mm.f, 2b_0bb.b, 2b_0mb.b, 2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.")
(exclusion_set "2b_0mm.f"
   "2b_0bb.b, 2b_0mb.b, 2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.")
(exclusion_set "2b_0bb.b" "2b_0mb.b, 2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.")
(exclusion_set "2b_0mb.b" "2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.")
(exclusion_set "2b_0mi.b" "2b_0mm.b, 2b_0mf.b, 2b_0mlx.")
(exclusion_set "2b_0mm.b" "2b_0mf.b, 2b_0mlx.")
(exclusion_set "2b_0mf.b" "2b_0mlx.")

;; Slot 3
(exclusion_set "2b_0mii."
   "2b_0mmi., 2b_0mfi., 2b_0mmf., 2b_0bbb., 2b_0mbb.,\
    2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.")
(exclusion_set "2b_0mmi."
   "2b_0mfi., 2b_0mmf., 2b_0bbb., 2b_0mbb.,\
    2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.")
(exclusion_set "2b_0mfi."
   "2b_0mmf., 2b_0bbb., 2b_0mbb., 2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.")
(exclusion_set "2b_0mmf."
   "2b_0bbb., 2b_0mbb., 2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.")
(exclusion_set "2b_0bbb." "2b_0mbb., 2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.")
(exclusion_set "2b_0mbb." "2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.")
(exclusion_set "2b_0mib." "2b_0mmb., 2b_0mfb., 2b_0mlx.")
(exclusion_set "2b_0mmb." "2b_0mfb., 2b_0mlx.")
(exclusion_set "2b_0mfb." "2b_0mlx.")

;; Slot 4
(exclusion_set "2b_1m.ii"
   "2b_1m.mi, 2b_1m.fi, 2b_1m.mf, 2b_1b.bb, 2b_1m.bb,\
    2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx")
(exclusion_set "2b_1m.mi"
   "2b_1m.fi, 2b_1m.mf, 2b_1b.bb, 2b_1m.bb, 2b_1m.ib,\
    2b_1m.mb, 2b_1m.fb, 2b_1m.lx")
(exclusion_set "2b_1m.fi"
   "2b_1m.mf, 2b_1b.bb, 2b_1m.bb, 2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx")
(exclusion_set "2b_1m.mf"
   "2b_1b.bb, 2b_1m.bb, 2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx")
(exclusion_set "2b_1b.bb" "2b_1m.bb, 2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx")
(exclusion_set "2b_1m.bb" "2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx")
(exclusion_set "2b_1m.ib" "2b_1m.mb, 2b_1m.fb, 2b_1m.lx")
(exclusion_set "2b_1m.mb" "2b_1m.fb, 2b_1m.lx")
(exclusion_set "2b_1m.fb" "2b_1m.lx")

;; Slot 5
(exclusion_set "2b_1mi.i"
   "2b_1mm.i, 2b_1mf.i, 2b_1mm.f, 2b_1bb.b, 2b_1mb.b,\
    2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.")
(exclusion_set "2b_1mm.i"
   "2b_1mf.i, 2b_1mm.f, 2b_1bb.b, 2b_1mb.b,\
    2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.")
(exclusion_set "2b_1mf.i"
   "2b_1mm.f, 2b_1bb.b, 2b_1mb.b, 2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.")
(exclusion_set "2b_1mm.f"
   "2b_1bb.b, 2b_1mb.b, 2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.")
(exclusion_set "2b_1bb.b" "2b_1mb.b, 2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.")
(exclusion_set "2b_1mb.b" "2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.")
(exclusion_set "2b_1mi.b" "2b_1mm.b, 2b_1mf.b, 2b_1mlx.")
(exclusion_set "2b_1mm.b" "2b_1mf.b, 2b_1mlx.")
(exclusion_set "2b_1mf.b" "2b_1mlx.")

;; Slot 6
(exclusion_set "2b_1mii."
   "2b_1mmi., 2b_1mfi., 2b_1mmf., 2b_1bbb., 2b_1mbb.,\
    2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.")
(exclusion_set "2b_1mmi."
   "2b_1mfi., 2b_1mmf., 2b_1bbb., 2b_1mbb.,\
    2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.")
(exclusion_set "2b_1mfi."
   "2b_1mmf., 2b_1bbb., 2b_1mbb., 2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.")
(exclusion_set "2b_1mmf."
   "2b_1bbb., 2b_1mbb., 2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.")
(exclusion_set "2b_1bbb." "2b_1mbb., 2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.")
(exclusion_set "2b_1mbb." "2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.")
(exclusion_set "2b_1mib." "2b_1mmb., 2b_1mfb., 2b_1mlx.")
(exclusion_set "2b_1mmb." "2b_1mfb., 2b_1mlx.")
(exclusion_set "2b_1mfb." "2b_1mlx.")

(final_presence_set "2b_0mi.i" "2b_0m.ii")
(final_presence_set "2b_0mii." "2b_0mi.i")
(final_presence_set "2b_1mi.i" "2b_1m.ii")
(final_presence_set "2b_1mii." "2b_1mi.i")

(final_presence_set "2b_0mm.i" "2b_0m.mi")
(final_presence_set "2b_0mmi." "2b_0mm.i")
(final_presence_set "2b_1mm.i" "2b_1m.mi")
(final_presence_set "2b_1mmi." "2b_1mm.i")

(final_presence_set "2b_0mf.i" "2b_0m.fi")
(final_presence_set "2b_0mfi." "2b_0mf.i")
(final_presence_set "2b_1mf.i" "2b_1m.fi")
(final_presence_set "2b_1mfi." "2b_1mf.i")

(final_presence_set "2b_0mm.f" "2b_0m.mf")
(final_presence_set "2b_0mmf." "2b_0mm.f")
(final_presence_set "2b_1mm.f" "2b_1m.mf")
(final_presence_set "2b_1mmf." "2b_1mm.f")

(final_presence_set "2b_0bb.b" "2b_0b.bb")
(final_presence_set "2b_0bbb." "2b_0bb.b")
(final_presence_set "2b_1bb.b" "2b_1b.bb")
(final_presence_set "2b_1bbb." "2b_1bb.b")

(final_presence_set "2b_0mb.b" "2b_0m.bb")
(final_presence_set "2b_0mbb." "2b_0mb.b")
(final_presence_set "2b_1mb.b" "2b_1m.bb")
(final_presence_set "2b_1mbb." "2b_1mb.b")

(final_presence_set "2b_0mi.b" "2b_0m.ib")
(final_presence_set "2b_0mib." "2b_0mi.b")
(final_presence_set "2b_1mi.b" "2b_1m.ib")
(final_presence_set "2b_1mib." "2b_1mi.b")

(final_presence_set "2b_0mm.b" "2b_0m.mb")
(final_presence_set "2b_0mmb." "2b_0mm.b")
(final_presence_set "2b_1mm.b" "2b_1m.mb")
(final_presence_set "2b_1mmb." "2b_1mm.b")

(final_presence_set "2b_0mf.b" "2b_0m.fb")
(final_presence_set "2b_0mfb." "2b_0mf.b")
(final_presence_set "2b_1mf.b" "2b_1m.fb")
(final_presence_set "2b_1mfb." "2b_1mf.b")

(final_presence_set "2b_0mlx." "2b_0m.lx")
(final_presence_set "2b_1mlx." "2b_1m.lx")

;;  See the corresponding comment in non-bundling section above.
(final_presence_set
   "2b_1m.lx"
   "2b_0mmi.,2b_0mfi.,2b_0mmf.,2b_0mib.,2b_0mmb.,2b_0mfb.,2b_0mlx.")
(final_presence_set "2b_1b.bb" "2b_0mii.,2b_0mmi.,2b_0mfi.,2b_0mmf.,2b_0mlx.")
(final_presence_set
   "2b_1m.ii,2b_1m.mi,2b_1m.fi,2b_1m.mf,2b_1m.bb,2b_1m.ib,2b_1m.mb,2b_1m.fb"
   "2b_0mii.,2b_0mmi.,2b_0mfi.,2b_0mmf.,2b_0mib.,2b_0mmb.,2b_0mfb.,2b_0mlx.")

;;  Ports/units (nb means nop.b insn issued into given port):
(define_cpu_unit
   "2b_um0, 2b_um1, 2b_um2, 2b_um3, 2b_ui0, 2b_ui1, 2b_uf0, 2b_uf1,\
    2b_ub0, 2b_ub1, 2b_ub2, 2b_unb0, 2b_unb1, 2b_unb2" "twob")

(exclusion_set "2b_ub0" "2b_unb0")
(exclusion_set "2b_ub1" "2b_unb1")
(exclusion_set "2b_ub2" "2b_unb2")

;; The following rules are used to decrease number of alternatives.
;; They are consequences of Itanium2 microarchitecture.  They also
;; describe the following rules mentioned in Itanium2
;; microarchitecture: rules mentioned in Itanium2 microarchitecture:
;; o "BBB/MBB: Always splits issue after either of these bundles".
;; o "MIB BBB: Split issue after the first bundle in this pair".
(exclusion_set
   "2b_0b.bb,2b_0bb.b,2b_0bbb.,2b_0m.bb,2b_0mb.b,2b_0mbb."
   "2b_1m.ii,2b_1m.mi,2b_1m.fi,2b_1m.mf,2b_1b.bb,2b_1m.bb,\
    2b_1m.ib,2b_1m.mb,2b_1m.fb,2b_1m.lx")
(exclusion_set "2b_0m.ib,2b_0mi.b,2b_0mib." "2b_1b.bb")

;;; "MIB/MFB/MMB: Splits issue after any of these bundles unless the
;;; B-slot contains a nop.b or a brp instruction".
;;;   "The B in an MIB/MFB/MMB bundle disperses to B0 if it is a brp or
;;; nop.b, otherwise it disperses to B2".
(final_absence_set
   "2b_1m.ii, 2b_1m.mi, 2b_1m.fi, 2b_1m.mf, 2b_1b.bb, 2b_1m.bb,\
    2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx"
   "2b_0mib. 2b_ub2, 2b_0mfb. 2b_ub2, 2b_0mmb. 2b_ub2")

;; This is necessary to start new processor cycle when we meet stop bit.
(define_cpu_unit "2b_stop" "twob")
(final_absence_set
   "2b_0m.ii,2b_0mi.i,2b_0mii.,2b_0m.mi,2b_0mm.i,2b_0mmi.,\
    2b_0m.fi,2b_0mf.i,2b_0mfi.,\
    2b_0m.mf,2b_0mm.f,2b_0mmf.,2b_0b.bb,2b_0bb.b,2b_0bbb.,\
    2b_0m.bb,2b_0mb.b,2b_0mbb.,\
    2b_0m.ib,2b_0mi.b,2b_0mib.,2b_0m.mb,2b_0mm.b,2b_0mmb.,\
    2b_0m.fb,2b_0mf.b,2b_0mfb.,2b_0m.lx,2b_0mlx., \
    2b_1m.ii,2b_1mi.i,2b_1mii.,2b_1m.mi,2b_1mm.i,2b_1mmi.,\
    2b_1m.fi,2b_1mf.i,2b_1mfi.,\
    2b_1m.mf,2b_1mm.f,2b_1mmf.,2b_1b.bb,2b_1bb.b,2b_1bbb.,\
    2b_1m.bb,2b_1mb.b,2b_1mbb.,\
    2b_1m.ib,2b_1mi.b,2b_1mib.,2b_1m.mb,2b_1mm.b,2b_1mmb.,\
    2b_1m.fb,2b_1mf.b,2b_1mfb.,2b_1m.lx,2b_1mlx."
   "2b_stop")

;;   The issue logic can reorder M slot insns between different subtypes
;; but can not reorder insn within the same subtypes.  The following
;; constraint is enough to describe this.
(final_presence_set "2b_um1" "2b_um0")
(final_presence_set "2b_um3" "2b_um2")

;;   The insn in the 1st I slot of the two bundle issue group will issue
;; to I0.  The second I slot insn will issue to I1.
(final_presence_set "2b_ui1" "2b_ui0")

;;  For exceptions of I insns:
(define_cpu_unit "2b_only_ui0" "twob")
(final_absence_set "2b_only_ui0"  "2b_ui1")

;; Insns

(define_reservation "2b_M"
  "((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\
     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\
    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\
      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\
    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\
    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\
   +(2b_um0|2b_um1|2b_um2|2b_um3)")

(define_reservation "2b_M_only_um0"
  "((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\
     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\
    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\
      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\
    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\
    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\
   +2b_um0")

(define_reservation "2b_M_only_um2"
  "((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\
     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\
    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\
      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\
    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\
    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\
   +2b_um2")

(define_reservation "2b_M_only_um01"
  "((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\
     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\
    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\
      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\
    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\
    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\
   +(2b_um0|2b_um1)")

(define_reservation "2b_M_only_um23"
  "((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\
     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\
    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\
      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\
    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\
    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\
   +(2b_um2|2b_um3)")

;; I instruction is dispersed to the lowest numbered I unit
;; not already in use.  Remeber about possible spliting.
(define_reservation "2b_I"
  "2b_0mi.i+2_2+2b_ui0|2b_0mii.+2_3+(2b_ui0|2b_ui1)|2b_0mmi.+2_3+2b_ui0\
   |2b_0mfi.+2_3+2b_ui0|2b_0mi.b+2_2+2b_ui0\
   |(2b_1mi.i+2_5|2b_1mi.b+2_5)+(2b_ui0|2b_ui1)\
   |(2b_1mii.|2b_1mmi.|2b_1mfi.)+2_6+(2b_ui0|2b_ui1)")

;; "An F slot in the 1st bundle disperses to F0".
;; "An F slot in the 2st bundle disperses to F1".
(define_reservation "2b_F"
   "2b_0mf.i+2_2+2b_uf0|2b_0mmf.+2_3+2b_uf0|2b_0mf.b+2_2+2b_uf0\
    |2b_1mf.i+2_5+2b_uf1|2b_1mmf.+2_6+2b_uf1|2b_1mf.b+2_5+2b_uf1")

;;; "Each B slot in MBB or BBB bundle disperses to the corresponding B
;;; unit. That is, a B slot in 1st position is despersed to B0.  In the
;;; 2nd position it is dispersed to B2".
(define_reservation "2b_NB"
    "2b_0b.bb+2_1+2b_unb0|2b_0bb.b+2_2+2b_unb1|2b_0bbb.+2_3+2b_unb2\
     |2b_0mb.b+2_2+2b_unb1|2b_0mbb.+2_3+2b_unb2\
     |2b_0mib.+2_3+2b_unb0|2b_0mmb.+2_3+2b_unb0|2b_0mfb.+2_3+2b_unb0\
     |2b_1b.bb+2_4+2b_unb0|2b_1bb.b+2_5+2b_unb1\
     |2b_1bbb.+2_6+2b_unb2|2b_1mb.b+2_5+2b_unb1|2b_1mbb.+2_6+2b_unb2\
     |2b_1mib.+2_6+2b_unb0|2b_1mmb.+2_6+2b_unb0|2b_1mfb.+2_6+2b_unb0")

(define_reservation "2b_B"
   "2b_0b.bb+2_1+2b_ub0|2b_0bb.b+2_2+2b_ub1|2b_0bbb.+2_3+2b_ub2\
    |2b_0mb.b+2_2+2b_ub1|2b_0mbb.+2_3+2b_ub2|2b_0mib.+2_3+2b_ub2\
    |2b_0mfb.+2_3+2b_ub2|2b_1b.bb+2_4+2b_ub0|2b_1bb.b+2_5+2b_ub1\
    |2b_1bbb.+2_6+2b_ub2|2b_1mb.b+2_5+2b_ub1\
    |2b_1mib.+2_6+2b_ub2|2b_1mmb.+2_6+2b_ub2|2b_1mfb.+2_6+2b_ub2")

;;   For the MLI template, the I slot insn is always assigned to port I0
;; if it is in the first bundle or it is assigned to port I1 if it is in
;; the second bundle.
(define_reservation "2b_L"
                    "2b_0mlx.+2_3+2b_ui0+2b_uf0|2b_1mlx.+2_6+2b_ui1+2b_uf1")

;;   Should we describe that A insn in I slot can be issued into M
;; ports?  I think it is not necessary because of multipass
;; scheduling.  For example, the multipass scheduling could use
;; MMI-MMI instead of MII-MII where the two last I slots contain A
;; insns (even if the case is complicated by use-def conflicts).
;;
;; In any case we could describe it as
;;    (define_cpu_unit "2b_ui1_0pres,2b_ui1_1pres,2b_ui1_2pres,2b_ui1_3pres"
;;                     "twob")
;;    (final_presence_set "2b_ui1_0pres,2b_ui1_1pres,2b_ui1_2pres,2b_ui1_3pres"
;;                        "2b_ui1")
;;    (define_reservation "b_A"
;;       "b_M|b_I\
;;        |(2b_1mi.i+2_5|2b_1mii.+2_6|2b_1mmi.+2_6|2b_1mfi.+2_6|2b_1mi.b+2_5)\
;;         +(2b_um0|2b_um1|2b_um2|2b_um3)\
;;         +(2b_ui1_0pres|2b_ui1_1pres|2b_ui1_2pres|2b_ui1_3pres)")

(define_reservation "2b_A" "2b_M|2b_I")

;; We assume that there is no insn issued on the same cycle as the
;; unknown insn.
(define_cpu_unit "2b_empty" "twob")
(exclusion_set "2b_empty"
    "2b_0m.ii,2b_0m.mi,2b_0m.fi,2b_0m.mf,2b_0b.bb,2b_0m.bb,\
     2b_0m.ib,2b_0m.mb,2b_0m.fb,2b_0m.lx,2b_0mm.i")

(define_cpu_unit
   "2b_0m_bs, 2b_0mi_bs, 2b_0mm_bs, 2b_0mf_bs, 2b_0b_bs, 2b_0bb_bs, 2b_0mb_bs"
   "twob")
(define_cpu_unit
   "2b_1m_bs, 2b_1mi_bs, 2b_1mm_bs, 2b_1mf_bs, 2b_1b_bs, 2b_1bb_bs, 2b_1mb_bs"
   "twob")

(define_cpu_unit "2b_m_cont, 2b_mi_cont, 2b_mm_cont, 2b_mf_cont, 2b_mb_cont,\
	          2b_b_cont, 2b_bb_cont" "twob")

;; For stop in the middle of the bundles.
(define_cpu_unit "2b_m_stop, 2b_m0_stop, 2b_m1_stop, 2b_0mmi_cont" "twob")
(define_cpu_unit "2b_mi_stop, 2b_mi0_stop, 2b_mi1_stop, 2b_0mii_cont" "twob")

(final_presence_set "2b_0m_bs"
   "2b_0m.ii, 2b_0m.mi, 2b_0m.mf, 2b_0m.fi, 2b_0m.bb,\
    2b_0m.ib, 2b_0m.fb, 2b_0m.mb, 2b_0m.lx")
(final_presence_set "2b_1m_bs"
   "2b_1m.ii, 2b_1m.mi, 2b_1m.mf, 2b_1m.fi, 2b_1m.bb,\
    2b_1m.ib, 2b_1m.fb, 2b_1m.mb, 2b_1m.lx")
(final_presence_set "2b_0mi_bs"  "2b_0mi.i, 2b_0mi.i")
(final_presence_set "2b_1mi_bs"  "2b_1mi.i, 2b_1mi.i")
(final_presence_set "2b_0mm_bs"  "2b_0mm.i, 2b_0mm.f, 2b_0mm.b")
(final_presence_set "2b_1mm_bs"  "2b_1mm.i, 2b_1mm.f, 2b_1mm.b")
(final_presence_set "2b_0mf_bs"  "2b_0mf.i, 2b_0mf.b")
(final_presence_set "2b_1mf_bs"  "2b_1mf.i, 2b_1mf.b")
(final_presence_set "2b_0b_bs"  "2b_0b.bb")
(final_presence_set "2b_1b_bs"  "2b_1b.bb")
(final_presence_set "2b_0bb_bs"  "2b_0bb.b")
(final_presence_set "2b_1bb_bs"  "2b_1bb.b")
(final_presence_set "2b_0mb_bs"  "2b_0mb.b")
(final_presence_set "2b_1mb_bs"  "2b_1mb.b")

(exclusion_set "2b_0m_bs"
   "2b_0mi.i, 2b_0mm.i, 2b_0mm.f, 2b_0mf.i, 2b_0mb.b,\
    2b_0mi.b, 2b_0mf.b, 2b_0mm.b, 2b_0mlx., 2b_m0_stop")
(exclusion_set "2b_1m_bs"
   "2b_1mi.i, 2b_1mm.i, 2b_1mm.f, 2b_1mf.i, 2b_1mb.b,\
    2b_1mi.b, 2b_1mf.b, 2b_1mm.b, 2b_1mlx., 2b_m1_stop")
(exclusion_set "2b_0mi_bs"  "2b_0mii., 2b_0mib., 2b_mi0_stop")
(exclusion_set "2b_1mi_bs"  "2b_1mii., 2b_1mib., 2b_mi1_stop")
(exclusion_set "2b_0mm_bs"  "2b_0mmi., 2b_0mmf., 2b_0mmb.")
(exclusion_set "2b_1mm_bs"  "2b_1mmi., 2b_1mmf., 2b_1mmb.")
(exclusion_set "2b_0mf_bs"  "2b_0mfi., 2b_0mfb.")
(exclusion_set "2b_1mf_bs"  "2b_1mfi., 2b_1mfb.")
(exclusion_set "2b_0b_bs"  "2b_0bb.b")
(exclusion_set "2b_1b_bs"  "2b_1bb.b")
(exclusion_set "2b_0bb_bs"  "2b_0bbb.")
(exclusion_set "2b_1bb_bs"  "2b_1bbb.")
(exclusion_set "2b_0mb_bs"  "2b_0mbb.")
(exclusion_set "2b_1mb_bs"  "2b_1mbb.")

(exclusion_set
   "2b_0m_bs, 2b_0mi_bs, 2b_0mm_bs, 2b_0mf_bs, 2b_0b_bs, 2b_0bb_bs, 2b_0mb_bs,
    2b_1m_bs, 2b_1mi_bs, 2b_1mm_bs, 2b_1mf_bs, 2b_1b_bs, 2b_1bb_bs, 2b_1mb_bs"
   "2b_stop")

(final_presence_set
   "2b_0mi.i, 2b_0mm.i, 2b_0mf.i, 2b_0mm.f, 2b_0mb.b,\
    2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx."
   "2b_m_cont")
(final_presence_set "2b_0mii., 2b_0mib." "2b_mi_cont")
(final_presence_set "2b_0mmi., 2b_0mmf., 2b_0mmb." "2b_mm_cont")
(final_presence_set "2b_0mfi., 2b_0mfb." "2b_mf_cont")
(final_presence_set "2b_0bb.b" "2b_b_cont")
(final_presence_set "2b_0bbb." "2b_bb_cont")
(final_presence_set "2b_0mbb." "2b_mb_cont")

(exclusion_set
   "2b_0m.ii, 2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\
    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx"
   "2b_m_cont, 2b_mi_cont, 2b_mm_cont, 2b_mf_cont,\
    2b_mb_cont, 2b_b_cont, 2b_bb_cont")

(exclusion_set "2b_empty"
               "2b_m_cont,2b_mi_cont,2b_mm_cont,2b_mf_cont,\
                2b_mb_cont,2b_b_cont,2b_bb_cont")

;; For m;mi bundle
(final_presence_set "2b_m0_stop" "2b_0m.mi")
(final_presence_set "2b_0mm.i" "2b_0mmi_cont")
(exclusion_set "2b_0mmi_cont"
   "2b_0m.ii, 2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\
    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_m0_stop" "2b_0mm.i")
(final_presence_set "2b_m1_stop" "2b_1m.mi")
(exclusion_set "2b_m1_stop" "2b_1mm.i")
(final_presence_set "2b_m_stop" "2b_m0_stop, 2b_m1_stop")

;; For mi;i bundle
(final_presence_set "2b_mi0_stop" "2b_0mi.i")
(final_presence_set "2b_0mii." "2b_0mii_cont")
(exclusion_set "2b_0mii_cont"
   "2b_0m.ii, 2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\
    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx")
(exclusion_set "2b_mi0_stop" "2b_0mii.")
(final_presence_set "2b_mi1_stop" "2b_1mi.i")
(exclusion_set "2b_mi1_stop" "2b_1mii.")
(final_presence_set "2b_mi_stop" "2b_mi0_stop, 2b_mi1_stop")

(final_absence_set
   "2b_0m.ii,2b_0mi.i,2b_0mii.,2b_0m.mi,2b_0mm.i,2b_0mmi.,\
    2b_0m.fi,2b_0mf.i,2b_0mfi.,2b_0m.mf,2b_0mm.f,2b_0mmf.,\
    2b_0b.bb,2b_0bb.b,2b_0bbb.,2b_0m.bb,2b_0mb.b,2b_0mbb.,\
    2b_0m.ib,2b_0mi.b,2b_0mib.,2b_0m.mb,2b_0mm.b,2b_0mmb.,\
    2b_0m.fb,2b_0mf.b,2b_0mfb.,2b_0m.lx,2b_0mlx., \
    2b_1m.ii,2b_1mi.i,2b_1mii.,2b_1m.mi,2b_1mm.i,2b_1mmi.,\
    2b_1m.fi,2b_1mf.i,2b_1mfi.,2b_1m.mf,2b_1mm.f,2b_1mmf.,\
    2b_1b.bb,2b_1bb.b,2b_1bbb.,2b_1m.bb,2b_1mb.b,2b_1mbb.,\
    2b_1m.ib,2b_1mi.b,2b_1mib.,2b_1m.mb,2b_1mm.b,2b_1mmb.,\
    2b_1m.fb,2b_1mf.b,2b_1mfb.,2b_1m.lx,2b_1mlx."
   "2b_m0_stop,2b_m1_stop,2b_mi0_stop,2b_mi1_stop")

(define_insn_reservation "2b_stop_bit" 0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "stop_bit"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_stop|2b_m0_stop|2b_m1_stop|2b_mi0_stop|2b_mi1_stop")
(define_insn_reservation "2b_br"      0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "br"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_B")
(define_insn_reservation "2b_scall"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "scall"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_B")
(define_insn_reservation "2b_fcmp"    2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fcmp"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_F")
(define_insn_reservation "2b_fcvtfx"  4
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fcvtfx"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_F")
(define_insn_reservation "2b_fld"     6
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fld"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_M")
(define_insn_reservation "2b_fmac"    4
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fmac"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_F")
(define_insn_reservation "2b_fmisc"   4
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "fmisc"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_F")

;; Latency time ???
(define_insn_reservation "2b_frar_i" 13
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frar_i"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")
;; Latency time ???
(define_insn_reservation "2b_frar_m"  6
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frar_m"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um2")
(define_insn_reservation "2b_frbr"    2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frbr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")
(define_insn_reservation "2b_frfr"    5				  
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frfr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um2")
(define_insn_reservation "2b_frpr"    2				  
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "frpr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")

(define_insn_reservation "2b_ialu"      1
    (and (and (eq_attr "cpu" "itanium2")
              (eq_attr "itanium_class" "ialu"))
         (ne (symbol_ref "bundling_p") (const_int 0)))
    "2b_A")
(define_insn_reservation "2b_icmp"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "icmp"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_A")
(define_insn_reservation "2b_ilog"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "ilog"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_A")
;; Latency time ???
(define_insn_reservation "2b_ishf"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "ishf"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")
(define_insn_reservation "2b_ld"      1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "ld"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um01")
(define_insn_reservation "2b_long_i"  1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "long_i"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_L")

;; Latency time ???
(define_insn_reservation "2b_mmmul"   2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "mmmul"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")
;; Latency time ???
(define_insn_reservation "2b_mmshf"   2
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "mmshf"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_I")
;; Latency time ???
(define_insn_reservation "2b_mmshfi"  1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "mmshfi"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_I")

(define_insn_reservation "2b_rse_m"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "rse_m"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
   "(2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\
     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1+2b_um0")
(define_insn_reservation "2b_sem"     0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "sem"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um23")

(define_insn_reservation "2b_stf"     1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "stf"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um23")
(define_insn_reservation "2b_st"      1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "st"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um23")
(define_insn_reservation "2b_syst_m0" 0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "syst_m0"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um2")
(define_insn_reservation "2b_syst_m"  0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "syst_m"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um0")
;; Reservation???
(define_insn_reservation "2b_tbit"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "tbit"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")
(define_insn_reservation "2b_toar_i"  0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "toar_i"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")
;; Latency time ???
(define_insn_reservation "2b_toar_m"  5
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "toar_m"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um2")
;; Latency time ???
(define_insn_reservation "2b_tobr"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "tobr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")
(define_insn_reservation "2b_tofr"    5
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "tofr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um23")
;; Latency time ???
(define_insn_reservation "2b_topr"    1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "topr"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I+2b_only_ui0")

(define_insn_reservation "2b_xmpy"    4
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "xmpy"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_F")
;; Latency time ???
(define_insn_reservation "2b_xtd"     1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "xtd"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_I")
(define_insn_reservation "2b_chk_s"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "chk_s"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_I|2b_M_only_um23")
(define_insn_reservation "2b_lfetch"  0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "lfetch"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M_only_um01")
(define_insn_reservation "2b_nop_m"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_m"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_M")
(define_insn_reservation "2b_nop_b"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_b"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_NB")
(define_insn_reservation "2b_nop_i"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_i"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_I")
(define_insn_reservation "2b_nop_f"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_f"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_F")
(define_insn_reservation "2b_nop_x"   0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop_x"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_L")
(define_insn_reservation "2b_unknown" 1
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "unknown"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "2b_empty")
(define_insn_reservation "2b_nop" 0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "nop"))
       (ne (symbol_ref "bundling_p") (const_int 0)))
  "2b_M|2b_NB|2b_I|2b_F")
(define_insn_reservation "2b_ignore" 0
  (and (and (eq_attr "cpu" "itanium2")
            (eq_attr "itanium_class" "ignore"))
       (ne (symbol_ref "bundling_p") (const_int 0))) "nothing")

(define_insn_reservation "2b_pre_cycle" 0
   (and (and (eq_attr "cpu" "itanium2")
             (eq_attr "itanium_class" "pre_cycle"))
        (ne (symbol_ref "bundling_p") (const_int 0)))
                         "(2b_0m_bs, 2b_m_cont)     \
                          | (2b_0mi_bs, 2b_mi_cont) \
                          | (2b_0mm_bs, 2b_mm_cont) \
                          | (2b_0mf_bs, 2b_mf_cont) \
                          | (2b_0b_bs, 2b_b_cont)   \
                          | (2b_0bb_bs, 2b_bb_cont) \
                          | (2b_0mb_bs, 2b_mb_cont) \
                          | (2b_1m_bs, 2b_m_cont)   \
                          | (2b_1mi_bs, 2b_mi_cont) \
                          | (2b_1mm_bs, 2b_mm_cont) \
                          | (2b_1mf_bs, 2b_mf_cont) \
                          | (2b_1b_bs, 2b_b_cont)   \
                          | (2b_1bb_bs, 2b_bb_cont) \
                          | (2b_1mb_bs, 2b_mb_cont) \
                          | (2b_m_stop, 2b_0mmi_cont)   \
                          | (2b_mi_stop, 2b_0mii_cont)")



;; ::::::::::::::::::::
;; ::
;; :: Moves
;; ::
;; ::::::::::::::::::::

;; Set of a single predicate register.  This is only used to implement
;; pr-to-pr move and complement.

(define_insn "*movcci"
  [(set (match_operand:CCI 0 "register_operand" "=c,c,c")
	(match_operand:CCI 1 "nonmemory_operand" "O,n,c"))]
  ""
  "@
   cmp.ne %0, p0 = r0, r0
   cmp.eq %0, p0 = r0, r0
   (%1) cmp.eq.unc %0, p0 = r0, r0"
  [(set_attr "itanium_class" "icmp")
   (set_attr "predicable" "no")])

(define_insn "movbi"
  [(set (match_operand:BI 0 "nonimmediate_operand" "=c,c,?c,?*r, c,*r,*r,*m,*r")
	(match_operand:BI 1 "move_operand"         " O,n, c,  c,*r, n,*m,*r,*r"))]
  ""
  "@
   cmp.ne %0, %I0 = r0, r0
   cmp.eq %0, %I0 = r0, r0
   #
   #
   tbit.nz %0, %I0 = %1, 0
   adds %0 = %1, r0
   ld1%O1 %0 = %1%P1
   st1%Q0 %0 = %1%P0
   mov %0 = %1"
  [(set_attr "itanium_class" "icmp,icmp,unknown,unknown,tbit,ialu,ld,st,ialu")])

(define_split
  [(set (match_operand:BI 0 "register_operand" "")
	(match_operand:BI 1 "register_operand" ""))]
  "reload_completed
   && GET_CODE (operands[0]) == REG && GR_REGNO_P (REGNO (operands[0]))
   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))"
  [(cond_exec (ne (match_dup 1) (const_int 0))
     (set (match_dup 0) (const_int 1)))
   (cond_exec (eq (match_dup 1) (const_int 0))
     (set (match_dup 0) (const_int 0)))]
  "")

(define_split
  [(set (match_operand:BI 0 "register_operand" "")
	(match_operand:BI 1 "register_operand" ""))]
  "reload_completed
   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))
   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))"
  [(set (match_dup 2) (match_dup 4))
   (set (match_dup 3) (match_dup 5))
   (set (match_dup 0) (unspec:BI [(match_dup 0)] 7))]
  "operands[2] = gen_rtx_REG (CCImode, REGNO (operands[0]));
   operands[3] = gen_rtx_REG (CCImode, REGNO (operands[0]) + 1);
   operands[4] = gen_rtx_REG (CCImode, REGNO (operands[1]));
   operands[5] = gen_rtx_REG (CCImode, REGNO (operands[1]) + 1);")

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
{
  rtx op1 = ia64_expand_move (operands[0], operands[1]);
  if (!op1)
    DONE;
  operands[1] = op1;
})

;; This is used as a placeholder for the return address during early
;; compilation.  We won't know where we've placed this until during
;; reload, at which point it can wind up in b0, a general register,
;; or memory.  The only safe destination under these conditions is a
;; general register.

(define_insn_and_split "*movdi_ret_addr"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(unspec:DI [(const_int 0)] UNSPEC_RET_ADDR))]
  ""
  "#"
  "reload_completed"
  [(const_int 0)]
{
  ia64_split_return_addr_rtx (operands[0]);
  DONE;
}
  [(set_attr "itanium_class" "ialu")])

(define_insn "*movqi_internal"
  [(set (match_operand:QI 0 "destination_operand" "=r,r,r, m, r,*f,*f")
	(match_operand:QI 1 "move_operand"        "rO,J,m,rO,*f,rO,*f"))]
  "ia64_move_ok (operands[0], operands[1])"
  "@
   mov %0 = %r1
   addl %0 = %1, r0
   ld1%O1 %0 = %1%P1
   st1%Q0 %0 = %r1%P0
   getf.sig %0 = %1
   setf.sig %0 = %r1
   mov %0 = %1"
  [(set_attr "itanium_class" "ialu,ialu,ld,st,frfr,tofr,fmisc")])

(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand" "")
	(match_operand:HI 1 "general_operand" ""))]
  ""
{
  rtx op1 = ia64_expand_move (operands[0], operands[1]);
  if (!op1)
    DONE;
  operands[1] = op1;
})

(define_insn "*movhi_internal"
  [(set (match_operand:HI 0 "destination_operand" "=r,r,r, m, r,*f,*f")
	(match_operand:HI 1 "move_operand"        "rO,J,m,rO,*f,rO,*f"))]
  "ia64_move_ok (operands[0], operands[1])"
  "@
   mov %0 = %r1
   addl %0 = %1, r0
   ld2%O1 %0 = %1%P1
   st2%Q0 %0 = %r1%P0
   getf.sig %0 = %1
   setf.sig %0 = %r1
   mov %0 = %1"
  [(set_attr "itanium_class" "ialu,ialu,ld,st,frfr,tofr,fmisc")])

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  ""
{
  rtx op1 = ia64_expand_move (operands[0], operands[1]);
  if (!op1)
    DONE;
  operands[1] = op1;
})

(define_insn "*movsi_internal"
  [(set (match_operand:SI 0 "destination_operand" "=r,r,r,r, m, r,*f,*f, r,*d")
	(match_operand:SI 1 "move_operand"        "rO,J,i,m,rO,*f,rO,*f,*d,rK"))]
  "ia64_move_ok (operands[0], operands[1])"
  "@
  mov %0 = %r1
  addl %0 = %1, r0
  movl %0 = %1
  ld4%O1 %0 = %1%P1
  st4%Q0 %0 = %r1%P0
  getf.sig %0 = %1
  setf.sig %0 = %r1
  mov %0 = %1
  mov %0 = %1
  mov %0 = %r1"
;; frar_m, toar_m ??? why not frar_i and toar_i
  [(set_attr "itanium_class" "ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,frar_m,toar_m")])

(define_expand "movdi"
  [(set (match_operand:DI 0 "general_operand" "")
	(match_operand:DI 1 "general_operand" ""))]
  ""
{
  rtx op1 = ia64_expand_move (operands[0], operands[1]);
  if (!op1)
    DONE;
  operands[1] = op1;
})

;; This is used during early compilation to delay the decision on
;; how to refer to a variable as long as possible.  This is especially
;; important between initial rtl generation and optimization for
;; deferred functions, since we may acquire additional information
;; on the variables used in the meantime.

(define_insn_and_split "movdi_symbolic"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(match_operand:DI 1 "symbolic_operand" "s"))
   (clobber (match_scratch:DI 2 "=r"))
   (use (reg:DI 1))]
  ""
  "* abort ();"
  "!no_new_pseudos || reload_completed"
  [(const_int 0)]
{
  rtx scratch = operands[2];
  if (!reload_completed)
    gen_reg_rtx (Pmode);
  ia64_expand_load_address (operands[0], operands[1], scratch); 
  DONE;
})

(define_insn "*movdi_internal"
  [(set (match_operand:DI 0 "destination_operand"
		    "=r,r,r,r, m, r,*f,*f,*f, Q, r,*b, r,*e, r,*d, r,*c")
	(match_operand:DI 1 "move_operand"
		    "rO,J,i,m,rO,*f,rO,*f, Q,*f,*b,rO,*e,rK,*d,rK,*c,rO"))]
  "ia64_move_ok (operands[0], operands[1])"
  "*
{
  static const char * const alt[] = {
    \"%,mov %0 = %r1\",
    \"%,addl %0 = %1, r0\",
    \"%,movl %0 = %1\",
    \"%,ld8%O1 %0 = %1%P1\",
    \"%,st8%Q0 %0 = %r1%P0\",
    \"%,getf.sig %0 = %1\",
    \"%,setf.sig %0 = %r1\",
    \"%,mov %0 = %1\",
    \"%,ldf8 %0 = %1%P1\",
    \"%,stf8 %0 = %1%P0\",
    \"%,mov %0 = %1\",
    \"%,mov %0 = %r1\",
    \"%,mov %0 = %1\",
    \"%,mov %0 = %1\",
    \"%,mov %0 = %1\",
    \"%,mov %0 = %1\",
    \"mov %0 = pr\",
    \"mov pr = %1, -1\"
  };

  if (which_alternative == 2 && ! TARGET_NO_PIC
      && symbolic_operand (operands[1], VOIDmode))
    abort ();

  return alt[which_alternative];
}"
  [(set_attr "itanium_class" "ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,fld,stf,frbr,tobr,frar_i,toar_i,frar_m,toar_m,frpr,topr")])

(define_split
  [(set (match_operand:DI 0 "register_operand" "")
	(match_operand:DI 1 "symbolic_operand" ""))]
  "reload_completed && ! TARGET_NO_PIC"
  [(const_int 0)]
  "
{
  ia64_expand_load_address (operands[0], operands[1], NULL_RTX);
  DONE;
}")

(define_expand "load_fptr"
  [(set (match_dup 2)
	(plus:DI (reg:DI 1) (match_operand:DI 1 "function_operand" "")))
   (set (match_operand:DI 0 "register_operand" "") (match_dup 3))]
  ""
  "
{
  operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (DImode);
  operands[3] = gen_rtx_MEM (DImode, operands[2]);
  RTX_UNCHANGING_P (operands[3]) = 1;
}")

(define_insn "*load_fptr_internal1"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (reg:DI 1) (match_operand:DI 1 "function_operand" "s")))]
  ""
  "addl %0 = @ltoff(@fptr(%1)), gp"
  [(set_attr "itanium_class" "ialu")])

(define_insn "load_gprel"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (reg:DI 1) (match_operand:DI 1 "sdata_symbolic_operand" "s")))]
  ""
  "addl %0 = @gprel(%1), gp"
  [(set_attr "itanium_class" "ialu")])

(define_insn "gprel64_offset"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(minus:DI (match_operand:DI 1 "symbolic_operand" "") (reg:DI 1)))]
  ""
  "movl %0 = @gprel(%1)"
  [(set_attr "itanium_class" "long_i")])

(define_expand "load_gprel64"
  [(set (match_dup 2)
	(minus:DI (match_operand:DI 1 "symbolic_operand" "") (match_dup 3)))
   (set (match_operand:DI 0 "register_operand" "")
	(plus:DI (match_dup 3) (match_dup 2)))]
  ""
  "
{
  operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (DImode);
  operands[3] = pic_offset_table_rtx;
}")

(define_expand "load_symptr"
  [(set (match_operand:DI 2 "register_operand" "")
	(plus:DI (high:DI (match_operand:DI 1 "got_symbolic_operand" ""))
		 (match_dup 3)))
   (set (match_operand:DI 0 "register_operand" "")
	(lo_sum:DI (match_dup 2) (match_dup 1)))]
  ""
{
  operands[3] = pic_offset_table_rtx;
})
  
(define_insn "*load_symptr_high"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (high:DI (match_operand 1 "got_symbolic_operand" "s"))
		 (match_operand:DI 2 "register_operand" "a")))]
  ""
{
  if (HAVE_AS_LTOFFX_LDXMOV_RELOCS)
    return "%,addl %0 = @ltoffx(%1), %2";
  else
    return "%,addl %0 = @ltoff(%1), %2";
}
  [(set_attr "itanium_class" "ialu")])

(define_insn "*load_symptr_low"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(lo_sum:DI (match_operand:DI 1 "register_operand" "r")
		   (match_operand 2 "got_symbolic_operand" "s")))]
  ""
{
  if (HAVE_AS_LTOFFX_LDXMOV_RELOCS)
    return "%,ld8.mov %0 = [%1], %2";
  else
    return "%,ld8 %0 = [%1]";
}
  [(set_attr "itanium_class" "ld")])

(define_insn "load_ltoff_dtpmod"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (reg:DI 1)
		 (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
			    UNSPEC_LTOFF_DTPMOD)))]
  ""
  "addl %0 = @ltoff(@dtpmod(%1)), gp"
  [(set_attr "itanium_class" "ialu")])

(define_insn "load_ltoff_dtprel"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (reg:DI 1)
		 (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
			    UNSPEC_LTOFF_DTPREL)))]
  ""
  "addl %0 = @ltoff(@dtprel(%1)), gp"
  [(set_attr "itanium_class" "ialu")])

(define_expand "load_dtprel"
  [(set (match_operand:DI 0 "register_operand" "")
	(unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
		   UNSPEC_DTPREL))]
  ""
  "")

(define_insn "*load_dtprel64"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
		   UNSPEC_DTPREL))]
  "TARGET_TLS64"
  "movl %0 = @dtprel(%1)"
  [(set_attr "itanium_class" "long_i")])

(define_insn "*load_dtprel22"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
		   UNSPEC_DTPREL))]
  ""
  "addl %0 = @dtprel(%1), r0"
  [(set_attr "itanium_class" "ialu")])

(define_expand "add_dtprel"
  [(set (match_operand:DI 0 "register_operand" "")
	(plus:DI (match_operand:DI 1 "register_operand" "")
		 (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")]
			    UNSPEC_DTPREL)))]
  "!TARGET_TLS64"
  "")

(define_insn "*add_dtprel14"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (match_operand:DI 1 "register_operand" "r")
		 (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")]
			    UNSPEC_DTPREL)))]
  "TARGET_TLS14"
  "adds %0 = @dtprel(%2), %1"
  [(set_attr "itanium_class" "ialu")])

(define_insn "*add_dtprel22"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (match_operand:DI 1 "register_operand" "a")
		 (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")]
			    UNSPEC_DTPREL)))]
  "TARGET_TLS22"
  "addl %0 = @dtprel(%2), %1"
  [(set_attr "itanium_class" "ialu")])

(define_insn "load_ltoff_tprel"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (reg:DI 1)
		 (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
			    UNSPEC_LTOFF_TPREL)))]
  ""
  "addl %0 = @ltoff(@tprel(%1)), gp"
  [(set_attr "itanium_class" "ialu")])

(define_expand "load_tprel"
  [(set (match_operand:DI 0 "register_operand" "")
	(unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
		   UNSPEC_TPREL))]
  ""
  "")

(define_insn "*load_tprel64"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
		   UNSPEC_TPREL))]
  "TARGET_TLS64"
  "movl %0 = @tprel(%1)"
  [(set_attr "itanium_class" "long_i")])

(define_insn "*load_tprel22"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(unspec:DI [(match_operand:DI 1 "symbolic_operand" "")]
		   UNSPEC_TPREL))]
  ""
  "addl %0 = @tprel(%1), r0"
  [(set_attr "itanium_class" "ialu")])

(define_expand "add_tprel"
  [(set (match_operand:DI 0 "register_operand" "")
	(plus:DI (match_operand:DI 1 "register_operand" "")
		 (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")]
			    UNSPEC_TPREL)))]
  "!TARGET_TLS64"
  "")

(define_insn "*add_tprel14"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (match_operand:DI 1 "register_operand" "r")
		 (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")]
			    UNSPEC_TPREL)))]
  "TARGET_TLS14"
  "adds %0 = @tprel(%2), %1"
  [(set_attr "itanium_class" "ialu")])

(define_insn "*add_tprel22"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(plus:DI (match_operand:DI 1 "register_operand" "a")
		 (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")]
			    UNSPEC_TPREL)))]
  "TARGET_TLS22"
  "addl %0 = @tprel(%2), %1"
  [(set_attr "itanium_class" "ialu")])

;; With no offsettable memory references, we've got to have a scratch
;; around to play with the second word.
(define_expand "movti"
  [(parallel [(set (match_operand:TI 0 "general_operand" "")
		   (match_operand:TI 1 "general_operand" ""))
	      (clobber (match_scratch:DI 2 ""))])]
  ""
{
  rtx op1 = ia64_expand_move (operands[0], operands[1]);
  if (!op1)
    DONE;
  operands[1] = op1;
})

(define_insn_and_split "*movti_internal"
  [(set (match_operand:TI 0 "nonimmediate_operand" "=r,r,m")
	(match_operand:TI 1 "general_operand"      "ri,m,r"))
   (clobber (match_scratch:DI 2 "=X,&r,&r"))]
  "ia64_move_ok (operands[0], operands[1])"
  "#"
  "reload_completed"
  [(const_int 0)]
  "
{
  rtx adj1, adj2, in[2], out[2], insn;
  int first;

  adj1 = ia64_split_timode (in, operands[1], operands[2]);
  adj2 = ia64_split_timode (out, operands[0], operands[2]);

  first = 0;
  if (reg_overlap_mentioned_p (out[0], in[1]))
    {
      if (reg_overlap_mentioned_p (out[1], in[0]))
	abort ();
      first = 1;
    }

  if (adj1 && adj2)
    abort ();
  if (adj1)
    emit_insn (adj1);
  if (adj2)
    emit_insn (adj2);
  insn = emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));
  if (GET_CODE (out[first]) == MEM
      && GET_CODE (XEXP (out[first], 0)) == POST_MODIFY)
    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,
					  XEXP (XEXP (out[first], 0), 0),
					  REG_NOTES (insn));
  insn = emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));
  if (GET_CODE (out[!first]) == MEM
      && GET_CODE (XEXP (out[!first], 0)) == POST_MODIFY)
    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,
					  XEXP (XEXP (out[!first], 0), 0),
					  REG_NOTES (insn));
  DONE;
}"
  [(set_attr "itanium_class" "unknown")
   (set_attr "predicable" "no")])

;; ??? SSA creates these.  Can't allow memories since we don't have
;; the scratch register.  Fortunately combine will know how to add
;; the clobber and scratch.
(define_insn_and_split "*movti_internal_reg"
  [(set (match_operand:TI 0 "register_operand"  "=r")
	(match_operand:TI 1 "nonmemory_operand" "ri"))]
  ""
  "#"
  "reload_completed"
  [(const_int 0)]
  "
{
  rtx in[2], out[2];
  int first;

  ia64_split_timode (in, operands[1], NULL_RTX);
  ia64_split_timode (out, operands[0], NULL_RTX);

  first = 0;
  if (reg_overlap_mentioned_p (out[0], in[1]))
    {
      if (reg_overlap_mentioned_p (out[1], in[0]))
	abort ();
      first = 1;
    }

  emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));
  emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));
  DONE;
}"
  [(set_attr "itanium_class" "unknown")
   (set_attr "predicable" "no")])

(define_expand "reload_inti"
  [(parallel [(set (match_operand:TI 0 "register_operand" "=r")
		   (match_operand:TI 1 "" "m"))
	      (clobber (match_operand:TI 2 "register_operand" "=&r"))])]
  ""
  "
{
  unsigned int s_regno = REGNO (operands[2]);
  if (s_regno == REGNO (operands[0]))
    s_regno += 1;
  operands[2] = gen_rtx_REG (DImode, s_regno);
}")

(define_expand "reload_outti"
  [(parallel [(set (match_operand:TI 0 "" "=m")
		   (match_operand:TI 1 "register_operand" "r"))
	      (clobber (match_operand:TI 2 "register_operand" "=&r"))])]
  ""
  "
{
  unsigned int s_regno = REGNO (operands[2]);
  if (s_regno == REGNO (operands[1]))
    s_regno += 1;
  operands[2] = gen_rtx_REG (DImode, s_regno);
}")

;; Floating Point Moves
;;
;; Note - Patterns for SF mode moves are compulsory, but
;; patterns for DF are optional, as GCC can synthesise them.

(define_expand "movsf"
  [(set (match_operand:SF 0 "general_operand" "")
	(match_operand:SF 1 "general_operand" ""))]
  ""
{
  rtx op1 = ia64_expand_move (operands[0], operands[1]);
  if (!op1)
    DONE;
  operands[1] = op1;
})

(define_insn "*movsf_internal"
  [(set (match_operand:SF 0 "destination_operand" "=f,f, Q,*r, f,*r,*r, m")
	(match_operand:SF 1 "general_operand"     "fG,Q,fG,fG,*r,*r, m,*r"))]
  "ia64_move_ok (operands[0], operands[1])"
  "@
  mov %0 = %F1
  ldfs %0 = %1%P1
  stfs %0 = %F1%P0
  getf.s %0 = %F1
  setf.s %0 = %1
  mov %0 = %1
  ld4%O1 %0 = %1%P1
  st4%Q0 %0 = %1%P0"
  [(set_attr "itanium_class" "fmisc,fld,stf,frfr,tofr,ialu,ld,st")])

(define_expand "movdf"
  [(set (match_operand:DF 0 "general_operand" "")
	(match_operand:DF 1 "general_operand" ""))]
  ""
{
  rtx op1 = ia64_expand_move (operands[0], operands[1]);
  if (!op1)
    DONE;
  operands[1] = op1;
})

(define_insn "*movdf_internal"
  [(set (match_operand:DF 0 "destination_operand" "=f,f, Q,*r, f,*r,*r, m")
	(match_operand:DF 1 "general_operand"     "fG,Q,fG,fG,*r,*r, m,*r"))]
  "ia64_move_ok (operands[0], operands[1])"
  "@
  mov %0 = %F1
  ldfd %0 = %1%P1
  stfd %0 = %F1%P0
  getf.d %0 = %F1
  setf.d %0 = %1
  mov %0 = %1
  ld8%O1 %0 = %1%P1
  st8%Q0 %0 = %1%P0"
  [(set_attr "itanium_class" "fmisc,fld,stf,frfr,tofr,ialu,ld,st")])

;; With no offsettable memory references, we've got to have a scratch
;; around to play with the second word if the variable winds up in GRs.
(define_expand "movtf"
  [(set (match_operand:TF 0 "general_operand" "")
	(match_operand:TF 1 "general_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "
{
  /* We must support TFmode loads into general registers for stdarg/vararg
     and unprototyped calls.  We split them into DImode loads for convenience.
     We don't need TFmode stores from general regs, because a stdarg/vararg
     routine does a block store to memory of unnamed arguments.  */
  if (GET_CODE (operands[0]) == REG
      && GR_REGNO_P (REGNO (operands[0])))
    {
      /* We're hoping to transform everything that deals with TFmode
	 quantities and GR registers early in the compiler.  */
      if (no_new_pseudos)
	abort ();

      /* Struct to register can just use TImode instead.  */
      if ((GET_CODE (operands[1]) == SUBREG
	   && GET_MODE (SUBREG_REG (operands[1])) == TImode)
	  || (GET_CODE (operands[1]) == REG
	      && GR_REGNO_P (REGNO (operands[1]))))
	{
	  emit_move_insn (gen_rtx_REG (TImode, REGNO (operands[0])),
			  SUBREG_REG (operands[1]));
	  DONE;
	}

      if (GET_CODE (operands[1]) == CONST_DOUBLE)
	{
	  emit_move_insn (gen_rtx_REG (DImode, REGNO (operands[0])),
			  operand_subword (operands[1], 0, 0, TFmode));
	  emit_move_insn (gen_rtx_REG (DImode, REGNO (operands[0]) + 1),
			  operand_subword (operands[1], 1, 0, TFmode));
	  DONE;
	}

      /* If the quantity is in a register not known to be GR, spill it.  */
      if (register_operand (operands[1], TFmode))
	operands[1] = spill_tfmode_operand (operands[1], 1);

      if (GET_CODE (operands[1]) == MEM)
	{
	  rtx out[2];

	  out[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[0]));
	  out[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[0])+1);

	  emit_move_insn (out[0], adjust_address (operands[1], DImode, 0));
	  emit_move_insn (out[1], adjust_address (operands[1], DImode, 8));
	  DONE;
	}

      abort ();
    }

  if (! reload_in_progress && ! reload_completed)
    {
      operands[0] = spill_tfmode_operand (operands[0], 0);
      operands[1] = spill_tfmode_operand (operands[1], 0);

      if (! ia64_move_ok (operands[0], operands[1]))
	operands[1] = force_reg (TFmode, operands[1]);
    }
}")

;; ??? There's no easy way to mind volatile acquire/release semantics.

(define_insn "*movtf_internal"
  [(set (match_operand:TF 0 "destination_tfmode_operand" "=f,f, m")
	(match_operand:TF 1 "general_tfmode_operand"     "fG,m,fG"))]
  "INTEL_EXTENDED_IEEE_FORMAT && ia64_move_ok (operands[0], operands[1])"
  "@
  mov %0 = %F1
  ldfe %0 = %1%P1
  stfe %0 = %F1%P0"
  [(set_attr "itanium_class" "fmisc,fld,stf")])

;; ::::::::::::::::::::
;; ::
;; :: Conversions
;; ::
;; ::::::::::::::::::::

;; Signed conversions from a smaller integer to a larger integer

(define_insn "extendqidi2"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(sign_extend:DI (match_operand:QI 1 "gr_register_operand" "r")))]
  ""
  "sxt1 %0 = %1"
  [(set_attr "itanium_class" "xtd")])

(define_insn "extendhidi2"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(sign_extend:DI (match_operand:HI 1 "gr_register_operand" "r")))]
  ""
  "sxt2 %0 = %1"
  [(set_attr "itanium_class" "xtd")])

(define_insn "extendsidi2"
  [(set (match_operand:DI 0 "grfr_register_operand" "=r,?f")
	(sign_extend:DI (match_operand:SI 1 "grfr_register_operand" "r,f")))]
  ""
  "@
   sxt4 %0 = %1
   fsxt.r %0 = %1, %1"
  [(set_attr "itanium_class" "xtd,fmisc")])

;; Unsigned conversions from a smaller integer to a larger integer

(define_insn "zero_extendqidi2"
  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
	(zero_extend:DI (match_operand:QI 1 "gr_nonimmediate_operand" "r,m")))]
  ""
  "@
   zxt1 %0 = %1
   ld1%O1 %0 = %1%P1"
  [(set_attr "itanium_class" "xtd,ld")])

(define_insn "zero_extendhidi2"
  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
	(zero_extend:DI (match_operand:HI 1 "gr_nonimmediate_operand" "r,m")))]
  ""
  "@
   zxt2 %0 = %1
   ld2%O1 %0 = %1%P1"
  [(set_attr "itanium_class" "xtd,ld")])

(define_insn "zero_extendsidi2"
  [(set (match_operand:DI 0 "grfr_register_operand" "=r,r,?f")
	(zero_extend:DI
	  (match_operand:SI 1 "grfr_nonimmediate_operand" "r,m,f")))]
  ""
  "@
   zxt4 %0 = %1
   ld4%O1 %0 = %1%P1
   fmix.r %0 = f0, %1"
  [(set_attr "itanium_class" "xtd,ld,fmisc")])

;; Convert between floating point types of different sizes.

;; At first glance, it would appear that emitting fnorm for an extending
;; conversion is unnecessary.  However, the stf and getf instructions work
;; correctly only if the input is properly rounded for its type.  In
;; particular, we get the wrong result for getf.d/stfd if the input is a
;; denorm single.  Since we don't know what the next instruction will be, we
;; have to emit an fnorm.

;; ??? Optimization opportunity here.  Get rid of the insn altogether
;; when we can.  Should probably use a scheme like has been proposed
;; for ia32 in dealing with operands that match unary operators.  This
;; would let combine merge the thing into adjacent insns.  See also how the
;; mips port handles SIGN_EXTEND as operands to integer arithmetic insns via
;; se_register_operand.

(define_insn "extendsfdf2"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_extend:DF (match_operand:SF 1 "fr_register_operand" "f")))]
  ""
  "fnorm.d %0 = %1"
  [(set_attr "itanium_class" "fmac")])

(define_insn "extendsftf2"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(float_extend:TF (match_operand:SF 1 "fr_register_operand" "f")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnorm %0 = %1"
  [(set_attr "itanium_class" "fmac")])

(define_insn "extenddftf2"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(float_extend:TF (match_operand:DF 1 "fr_register_operand" "f")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnorm %0 = %1"
  [(set_attr "itanium_class" "fmac")])

(define_insn "truncdfsf2"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF (match_operand:DF 1 "fr_register_operand" "f")))]
  ""
  "fnorm.s %0 = %1"
  [(set_attr "itanium_class" "fmac")])

(define_insn "trunctfsf2"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF (match_operand:TF 1 "fr_register_operand" "f")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnorm.s %0 = %1"
  [(set_attr "itanium_class" "fmac")])

(define_insn "trunctfdf2"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF (match_operand:TF 1 "fr_register_operand" "f")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnorm.d %0 = %1"
  [(set_attr "itanium_class" "fmac")])

;; Convert between signed integer types and floating point.

(define_insn "floatditf2"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(float:TF (match_operand:DI 1 "fr_register_operand" "f")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fcvt.xf %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

;; ??? Suboptimal.  This should be split somehow.
(define_insn "floatdidf2"
  [(set (match_operand:DF 0 "register_operand" "=f")
        (float:DF (match_operand:DI 1 "register_operand" "f")))]
  "!INTEL_EXTENDED_IEEE_FORMAT"
  "fcvt.xf %0 = %1\;;;\;fnorm.d %0 = %0"
  [(set_attr "itanium_class" "fcvtfx")])

;; ??? Suboptimal.  This should be split somehow.
(define_insn "floatdisf2"
  [(set (match_operand:SF 0 "register_operand" "=f")
        (float:SF (match_operand:DI 1 "register_operand" "f")))]
  "!INTEL_EXTENDED_IEEE_FORMAT"
  "fcvt.xf %0 = %1\;;;\;fnorm.s %0 = %0"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "fix_truncsfdi2"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(fix:DI (match_operand:SF 1 "fr_register_operand" "f")))]
  ""
  "fcvt.fx.trunc %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "fix_truncdfdi2"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(fix:DI (match_operand:DF 1 "fr_register_operand" "f")))]
  ""
  "fcvt.fx.trunc %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "fix_trunctfdi2"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(fix:DI (match_operand:TF 1 "fr_register_operand" "f")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fcvt.fx.trunc %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "fix_trunctfdi2_alts"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(fix:DI (match_operand:TF 1 "fr_register_operand" "f")))
   (use (match_operand:SI 2 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fcvt.fx.trunc.s%2 %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

;; Convert between unsigned integer types and floating point.

(define_insn "floatunsdisf2"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(unsigned_float:SF (match_operand:DI 1 "fr_register_operand" "f")))]
  ""
  "fcvt.xuf.s %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "floatunsdidf2"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(unsigned_float:DF (match_operand:DI 1 "fr_register_operand" "f")))]
  ""
  "fcvt.xuf.d %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "floatunsditf2"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(unsigned_float:TF (match_operand:DI 1 "fr_register_operand" "f")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fcvt.xuf %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "fixuns_truncsfdi2"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(unsigned_fix:DI (match_operand:SF 1 "fr_register_operand" "f")))]
  ""
  "fcvt.fxu.trunc %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "fixuns_truncdfdi2"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(unsigned_fix:DI (match_operand:DF 1 "fr_register_operand" "f")))]
  ""
  "fcvt.fxu.trunc %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "fixuns_trunctfdi2"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(unsigned_fix:DI (match_operand:TF 1 "fr_register_operand" "f")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fcvt.fxu.trunc %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

(define_insn "fixuns_trunctfdi2_alts"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(unsigned_fix:DI (match_operand:TF 1 "fr_register_operand" "f")))
   (use (match_operand:SI 2 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fcvt.fxu.trunc.s%2 %0 = %1"
  [(set_attr "itanium_class" "fcvtfx")])

;; ::::::::::::::::::::
;; ::
;; :: Bit field extraction
;; ::
;; ::::::::::::::::::::

(define_insn "extv"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(sign_extract:DI (match_operand:DI 1 "gr_register_operand" "r")
			 (match_operand:DI 2 "const_int_operand" "n")
			 (match_operand:DI 3 "const_int_operand" "n")))]
  ""
  "extr %0 = %1, %3, %2"
  [(set_attr "itanium_class" "ishf")])

(define_insn "extzv"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(zero_extract:DI (match_operand:DI 1 "gr_register_operand" "r")
			 (match_operand:DI 2 "const_int_operand" "n")
			 (match_operand:DI 3 "const_int_operand" "n")))]
  ""
  "extr.u %0 = %1, %3, %2"
  [(set_attr "itanium_class" "ishf")])

;; Insert a bit field.
;; Can have 3 operands, source1 (inserter), source2 (insertee), dest.
;; Source1 can be 0 or -1.
;; Source2 can be 0.

;; ??? Actual dep instruction is more powerful than what these insv
;; patterns support.  Unfortunately, combine is unable to create patterns
;; where source2 != dest.

(define_expand "insv"
  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "")
			 (match_operand:DI 1 "const_int_operand" "")
			 (match_operand:DI 2 "const_int_operand" ""))
	(match_operand:DI 3 "nonmemory_operand" ""))]
  ""
  "
{
  int width = INTVAL (operands[1]);
  int shift = INTVAL (operands[2]);

  /* If operand[3] is a constant, and isn't 0 or -1, then load it into a
     pseudo.  */
  if (! register_operand (operands[3], DImode)
      && operands[3] != const0_rtx && operands[3] != constm1_rtx)
    operands[3] = force_reg (DImode, operands[3]);

  /* If this is a single dep instruction, we have nothing to do.  */
  if (! ((register_operand (operands[3], DImode) && width <= 16)
	 || operands[3] == const0_rtx || operands[3] == constm1_rtx))
    {
      /* Check for cases that can be implemented with a mix instruction.  */
      if (width == 32 && shift == 0)
	{
	  /* Directly generating the mix4left instruction confuses
	     optimize_bit_field in function.c.  Since this is performing
	     a useful optimization, we defer generation of the complicated
	     mix4left RTL to the first splitting phase.  */
	  rtx tmp = gen_reg_rtx (DImode);
	  emit_insn (gen_shift_mix4left (operands[0], operands[3], tmp));
	  DONE;
	}
      else if (width == 32 && shift == 32)
	{
	  emit_insn (gen_mix4right (operands[0], operands[3]));
	  DONE;
	}

      /* We could handle remaining cases by emitting multiple dep
	 instructions.

	 If we need more than two dep instructions then we lose.  A 6
	 insn sequence mov mask1,mov mask2,shl;;and,and;;or is better than
	 mov;;dep,shr;;dep,shr;;dep.  The former can be executed in 3 cycles,
	 the latter is 6 cycles on an Itanium (TM) processor, because there is
	 only one function unit that can execute dep and shr immed.

	 If we only need two dep instruction, then we still lose.
	 mov;;dep,shr;;dep is still 4 cycles.  Even if we optimize away
	 the unnecessary mov, this is still undesirable because it will be
	 hard to optimize, and it creates unnecessary pressure on the I0
	 function unit.  */

      FAIL;

#if 0
      /* This code may be useful for other IA-64 processors, so we leave it in
	 for now.  */
      while (width > 16)
	{
	  rtx tmp;

	  emit_insn (gen_insv (operands[0], GEN_INT (16), GEN_INT (shift),
			       operands[3]));
	  shift += 16;
	  width -= 16;
	  tmp = gen_reg_rtx (DImode);
	  emit_insn (gen_lshrdi3 (tmp, operands[3], GEN_INT (16)));
	  operands[3] = tmp;
	}
      operands[1] = GEN_INT (width);
      operands[2] = GEN_INT (shift);
#endif
    }
}")

(define_insn "*insv_internal"
  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "+r")
			 (match_operand:DI 1 "const_int_operand" "n")
			 (match_operand:DI 2 "const_int_operand" "n"))
	(match_operand:DI 3 "nonmemory_operand" "rP"))]
  "(gr_register_operand (operands[3], DImode) && INTVAL (operands[1]) <= 16)
   || operands[3] == const0_rtx || operands[3] == constm1_rtx"
  "dep %0 = %3, %0, %2, %1"
  [(set_attr "itanium_class" "ishf")])

;; Combine doesn't like to create bitfield insertions into zero.
(define_insn "*depz_internal"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(and:DI (ashift:DI (match_operand:DI 1 "gr_register_operand" "r")
			   (match_operand:DI 2 "const_int_operand" "n"))
		(match_operand:DI 3 "const_int_operand" "n")))]
  "CONST_OK_FOR_M (INTVAL (operands[2]))
   && ia64_depz_field_mask (operands[3], operands[2]) > 0"
  "*
{
  operands[3] = GEN_INT (ia64_depz_field_mask (operands[3], operands[2]));
  return \"%,dep.z %0 = %1, %2, %3\";
}"
  [(set_attr "itanium_class" "ishf")])

(define_insn "shift_mix4left"
  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "+r")
			 (const_int 32) (const_int 0))
	(match_operand:DI 1 "gr_register_operand" "r"))
   (clobber (match_operand:DI 2 "gr_register_operand" "=r"))]
  ""
  "#"
  [(set_attr "itanium_class" "unknown")])

(define_split
  [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "")
			 (const_int 32) (const_int 0))
	(match_operand:DI 1 "register_operand" ""))
   (clobber (match_operand:DI 2 "register_operand" ""))]
  "reload_completed"
  [(set (match_dup 3) (ashift:DI (match_dup 1) (const_int 32)))
   (set (zero_extract:DI (match_dup 0) (const_int 32) (const_int 0))
	(lshiftrt:DI (match_dup 3) (const_int 32)))]
  "operands[3] = operands[2];")

(define_split
  [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "")
			 (const_int 32) (const_int 0))
	(match_operand:DI 1 "register_operand" ""))
   (clobber (match_operand:DI 2 "register_operand" ""))]
  "! reload_completed"
  [(set (match_dup 3) (ashift:DI (match_dup 1) (const_int 32)))
   (set (zero_extract:DI (match_dup 0) (const_int 32) (const_int 0))
	(lshiftrt:DI (match_dup 3) (const_int 32)))]
  "operands[3] = operands[2];")

(define_insn "*mix4left"
  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "+r")
			 (const_int 32) (const_int 0))
	(lshiftrt:DI (match_operand:DI 1 "gr_register_operand" "r")
		     (const_int 32)))]
  ""
  "mix4.l %0 = %0, %r1"
  [(set_attr "itanium_class" "mmshf")])

(define_insn "mix4right"
  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "+r")
			 (const_int 32) (const_int 32))
	(match_operand:DI 1 "gr_reg_or_0_operand" "rO"))]
  ""
  "mix4.r %0 = %r1, %0"
  [(set_attr "itanium_class" "mmshf")])

;; This is used by the rotrsi3 pattern.

(define_insn "*mix4right_3op"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(ior:DI (zero_extend:DI (match_operand:SI 1 "gr_register_operand" "r"))
		(ashift:DI (zero_extend:DI
			     (match_operand:SI 2 "gr_register_operand" "r"))
			   (const_int 32))))]
  ""
  "mix4.r %0 = %2, %1"
  [(set_attr "itanium_class" "mmshf")])


;; ::::::::::::::::::::
;; ::
;; :: 1 bit Integer arithmetic
;; ::
;; ::::::::::::::::::::

(define_insn_and_split "andbi3"
  [(set (match_operand:BI 0 "register_operand" "=c,c,r")
	(and:BI (match_operand:BI 1 "register_operand" "%0,0,r")
		(match_operand:BI 2 "register_operand" "c,r,r")))]
  ""
  "@
   #
   tbit.nz.and.orcm %0, %I0 = %2, 0
   and %0 = %2, %1"
  "reload_completed
   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))
   && GET_CODE (operands[2]) == REG && PR_REGNO_P (REGNO (operands[2]))"
  [(cond_exec (eq (match_dup 2) (const_int 0))
     (set (match_dup 0) (and:BI (ne:BI (const_int 0) (const_int 0))
				(match_dup 0))))]
  ""
  [(set_attr "itanium_class" "unknown,tbit,ilog")])

(define_insn_and_split "*andcmbi3"
  [(set (match_operand:BI 0 "register_operand" "=c,c,r")
	(and:BI (not:BI (match_operand:BI 1 "register_operand" "c,r,r"))
		(match_operand:BI 2 "register_operand" "0,0,r")))]
  ""
  "@
   #
   tbit.z.and.orcm %0, %I0 = %1, 0
   andcm %0 = %2, %1"
  "reload_completed
   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))
   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))"
  [(cond_exec (ne (match_dup 1) (const_int 0))
     (set (match_dup 0) (and:BI (ne:BI (const_int 0) (const_int 0))
				(match_dup 0))))]
  ""
  [(set_attr "itanium_class" "unknown,tbit,ilog")])

(define_insn_and_split "iorbi3"
  [(set (match_operand:BI 0 "register_operand" "=c,c,r")
	(ior:BI (match_operand:BI 1 "register_operand" "%0,0,r")
		(match_operand:BI 2 "register_operand" "c,r,r")))]
  ""
  "@
   #
   tbit.nz.or.andcm %0, %I0 = %2, 0
   or %0 = %2, %1"
  "reload_completed
   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))
   && GET_CODE (operands[2]) == REG && PR_REGNO_P (REGNO (operands[2]))"
  [(cond_exec (ne (match_dup 2) (const_int 0))
     (set (match_dup 0) (ior:BI (eq:BI (const_int 0) (const_int 0))
				(match_dup 0))))]
  ""
  [(set_attr "itanium_class" "unknown,tbit,ilog")])

(define_insn_and_split "*iorcmbi3"
  [(set (match_operand:BI 0 "register_operand" "=c,c")
	(ior:BI (not:BI (match_operand:BI 1 "register_operand" "c,r"))
		(match_operand:BI 2 "register_operand" "0,0")))]
  ""
  "@
   #
   tbit.z.or.andcm %0, %I0 = %1, 0"
  "reload_completed
   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))
   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))"
  [(cond_exec (eq (match_dup 1) (const_int 0))
     (set (match_dup 0) (ior:BI (eq:BI (const_int 0) (const_int 0))
				(match_dup 0))))]
  ""
  [(set_attr "itanium_class" "unknown,tbit")])

(define_insn "one_cmplbi2"
  [(set (match_operand:BI 0 "register_operand" "=c,r,c,&c")
	(not:BI (match_operand:BI 1 "register_operand" "r,r,0,c")))
   (clobber (match_scratch:BI 2 "=X,X,c,X"))]
  ""
  "@
   tbit.z %0, %I0 = %1, 0
   xor %0 = 1, %1
   #
   #"
  [(set_attr "itanium_class" "tbit,ilog,unknown,unknown")])

(define_split
  [(set (match_operand:BI 0 "register_operand" "")
	(not:BI (match_operand:BI 1 "register_operand" "")))
   (clobber (match_scratch:BI 2 ""))]
  "reload_completed
   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))
   && rtx_equal_p (operands[0], operands[1])"
  [(set (match_dup 4) (match_dup 3))
   (set (match_dup 0) (const_int 1))
   (cond_exec (ne (match_dup 2) (const_int 0))
     (set (match_dup 0) (const_int 0)))
   (set (match_dup 0) (unspec:BI [(match_dup 0)] 7))]
  "operands[3] = gen_rtx_REG (CCImode, REGNO (operands[1]));
   operands[4] = gen_rtx_REG (CCImode, REGNO (operands[2]));")

(define_split
  [(set (match_operand:BI 0 "register_operand" "")
	(not:BI (match_operand:BI 1 "register_operand" "")))
   (clobber (match_scratch:BI 2 ""))]
  "reload_completed
   && GET_CODE (operands[0]) == REG && PR_REGNO_P (REGNO (operands[0]))
   && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))
   && ! rtx_equal_p (operands[0], operands[1])"
  [(cond_exec (ne (match_dup 1) (const_int 0))
     (set (match_dup 0) (const_int 0)))
   (cond_exec (eq (match_dup 1) (const_int 0))
     (set (match_dup 0) (const_int 1)))
   (set (match_dup 0) (unspec:BI [(match_dup 0)] 7))]
  "")

(define_insn "*cmpsi_and_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (match_operator:BI 4 "predicate_operator"
		  [(match_operand:SI 2 "gr_reg_or_0_operand" "rO")
		   (match_operand:SI 3 "gr_reg_or_8bit_operand" "rK")])
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp4.%C4.and.orcm %0, %I0 = %3, %r2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpsi_and_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (match_operator:BI 3 "signed_inequality_operator"
		  [(match_operand:SI 2 "gr_register_operand" "r")
		   (const_int 0)])
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp4.%C3.and.orcm %0, %I0 = r0, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpsi_andnot_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (not:BI (match_operator:BI 4 "predicate_operator"
			 [(match_operand:SI 2 "gr_reg_or_0_operand" "rO")
			  (match_operand:SI 3 "gr_reg_or_8bit_operand" "rK")]))
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp4.%C4.or.andcm %I0, %0 = %3, %r2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpsi_andnot_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (not:BI (match_operator:BI 3 "signed_inequality_operator"
			  [(match_operand:SI 2 "gr_register_operand" "r")
			   (const_int 0)]))
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp4.%C3.or.andcm %I0, %0 = r0, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_and_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (match_operator:BI 4 "predicate_operator"
		  [(match_operand:DI 2 "gr_register_operand" "r")
		   (match_operand:DI 3 "gr_reg_or_8bit_operand" "rK")])
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp.%C4.and.orcm %0, %I0 = %3, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_and_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (match_operator:BI 3 "signed_inequality_operator"
		  [(match_operand:DI 2 "gr_register_operand" "r")
		   (const_int 0)])
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp.%C3.and.orcm %0, %I0 = r0, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_andnot_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (not:BI (match_operator:BI 4 "predicate_operator"
			 [(match_operand:DI 2 "gr_register_operand" "r")
			  (match_operand:DI 3 "gr_reg_or_8bit_operand" "rK")]))
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp.%C4.or.andcm %I0, %0 = %3, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_andnot_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (not:BI (match_operator:BI 3 "signed_inequality_operator"
			  [(match_operand:DI 2 "gr_register_operand" "r")
			   (const_int 0)]))
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp.%C3.or.andcm %I0, %0 = r0, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*tbit_and_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (ne:BI (and:DI (match_operand:DI 1 "gr_register_operand" "r")
			       (const_int 1))
		       (const_int 0))
		(match_operand:BI 2 "register_operand" "0")))]
  ""
  "tbit.nz.and.orcm %0, %I0 = %1, 0"
  [(set_attr "itanium_class" "tbit")])

(define_insn "*tbit_and_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (eq:BI (and:DI (match_operand:DI 1 "gr_register_operand" "r")
			       (const_int 1))
		       (const_int 0))
		(match_operand:BI 2 "register_operand" "0")))]
  ""
  "tbit.z.and.orcm %0, %I0 = %1, 0"
  [(set_attr "itanium_class" "tbit")])

(define_insn "*tbit_and_2"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (ne:BI (zero_extract:DI
			 (match_operand:DI 1 "gr_register_operand" "r")
			 (const_int 1)
			 (match_operand:DI 2 "const_int_operand" "n"))
		       (const_int 0))
		(match_operand:BI 3 "register_operand" "0")))]
  ""
  "tbit.nz.and.orcm %0, %I0 = %1, %2"
  [(set_attr "itanium_class" "tbit")])

(define_insn "*tbit_and_3"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(and:BI (eq:BI (zero_extract:DI
			 (match_operand:DI 1 "gr_register_operand" "r")
			 (const_int 1)
			 (match_operand:DI 2 "const_int_operand" "n"))
		       (const_int 0))
		(match_operand:BI 3 "register_operand" "0")))]
  ""
  "tbit.z.and.orcm %0, %I0 = %1, %2"
  [(set_attr "itanium_class" "tbit")])

(define_insn "*cmpsi_or_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (match_operator:BI 4 "predicate_operator"
		  [(match_operand:SI 2 "gr_reg_or_0_operand" "rO")
		   (match_operand:SI 3 "gr_reg_or_8bit_operand" "rK")])
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp4.%C4.or.andcm %0, %I0 = %3, %r2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpsi_or_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (match_operator:BI 3 "signed_inequality_operator"
		  [(match_operand:SI 2 "gr_register_operand" "r")
		   (const_int 0)])
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp4.%C3.or.andcm %0, %I0 = r0, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpsi_orcm_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (not:BI (match_operator:BI 4 "predicate_operator"
			 [(match_operand:SI 2 "gr_reg_or_0_operand" "rO")
			  (match_operand:SI 3 "gr_reg_or_8bit_operand" "rK")]))
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp4.%C4.and.orcm %I0, %0 = %3, %r2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpsi_orcm_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (not:BI (match_operator:BI 3 "signed_inequality_operator"
			  [(match_operand:SI 2 "gr_register_operand" "r")
			   (const_int 0)]))
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp4.%C3.and.orcm %I0, %0 = r0, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_or_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (match_operator:BI 4 "predicate_operator"
		  [(match_operand:DI 2 "gr_register_operand" "r")
		   (match_operand:DI 3 "gr_reg_or_8bit_operand" "rK")])
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp.%C4.or.andcm %0, %I0 = %3, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_or_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (match_operator:BI 3 "signed_inequality_operator"
		  [(match_operand:DI 2 "gr_register_operand" "r")
		   (const_int 0)])
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp.%C3.or.andcm %0, %I0 = r0, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_orcm_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (not:BI (match_operator:BI 4 "predicate_operator"
			 [(match_operand:DI 2 "gr_register_operand" "r")
			  (match_operand:DI 3 "gr_reg_or_8bit_operand" "rK")]))
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp.%C4.and.orcm %I0, %0 = %3, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_orcm_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (not:BI (match_operator:BI 3 "signed_inequality_operator"
			  [(match_operand:DI 2 "gr_register_operand" "r")
			   (const_int 0)]))
		(match_operand:BI 1 "register_operand" "0")))]
  ""
  "cmp.%C3.and.orcm %I0, %0 = r0, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*tbit_or_0"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (ne:BI (and:DI (match_operand:DI 1 "gr_register_operand" "r")
			       (const_int 1))
		       (const_int 0))
		(match_operand:BI 2 "register_operand" "0")))]
  ""
  "tbit.nz.or.andcm %0, %I0 = %1, 0"
  [(set_attr "itanium_class" "tbit")])

(define_insn "*tbit_or_1"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (eq:BI (and:DI (match_operand:DI 1 "gr_register_operand" "r")
			       (const_int 1))
		       (const_int 0))
		(match_operand:BI 2 "register_operand" "0")))]
  ""
  "tbit.z.or.andcm %0, %I0 = %1, 0"
  [(set_attr "itanium_class" "tbit")])

(define_insn "*tbit_or_2"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (ne:BI (zero_extract:DI
			 (match_operand:DI 1 "gr_register_operand" "r")
			 (const_int 1)
			 (match_operand:DI 2 "const_int_operand" "n"))
		       (const_int 0))
		(match_operand:BI 3 "register_operand" "0")))]
  ""
  "tbit.nz.or.andcm %0, %I0 = %1, %2"
  [(set_attr "itanium_class" "tbit")])

(define_insn "*tbit_or_3"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ior:BI (eq:BI (zero_extract:DI
			 (match_operand:DI 1 "gr_register_operand" "r")
			 (const_int 1)
			 (match_operand:DI 2 "const_int_operand" "n"))
		       (const_int 0))
		(match_operand:BI 3 "register_operand" "0")))]
  ""
  "tbit.z.or.andcm %0, %I0 = %1, %2"
  [(set_attr "itanium_class" "tbit")])

;; Transform test of and/or of setcc into parallel comparisons.

(define_split
  [(set (match_operand:BI 0 "register_operand" "")
	(ne:BI (and:DI (ne:DI (match_operand:BI 2 "register_operand" "")
			      (const_int 0))
		       (match_operand:DI 3 "register_operand" ""))
	       (const_int 0)))]
  ""
  [(set (match_dup 0)
	(and:BI (ne:BI (and:DI (match_dup 3) (const_int 1)) (const_int 0))
		(match_dup 2)))]
  "")

(define_split
  [(set (match_operand:BI 0 "register_operand" "")
	(eq:BI (and:DI (ne:DI (match_operand:BI 2 "register_operand" "")
			      (const_int 0))
		       (match_operand:DI 3 "register_operand" ""))
	       (const_int 0)))]
  ""
  [(set (match_dup 0)
	(and:BI (ne:BI (and:DI (match_dup 3) (const_int 1)) (const_int 0))
		(match_dup 2)))
   (parallel [(set (match_dup 0) (not:BI (match_dup 0)))
	      (clobber (scratch))])]
  "")

(define_split
  [(set (match_operand:BI 0 "register_operand" "")
	(ne:BI (ior:DI (ne:DI (match_operand:BI 2 "register_operand" "")
			      (const_int 0))
		       (match_operand:DI 3 "register_operand" ""))
	       (const_int 0)))]
  ""
  [(set (match_dup 0) 
	(ior:BI (ne:BI (match_dup 3) (const_int 0))
		(match_dup 2)))]
  "")

(define_split
  [(set (match_operand:BI 0 "register_operand" "")
	(eq:BI (ior:DI (ne:DI (match_operand:BI 2 "register_operand" "")
			      (const_int 0))
		       (match_operand:DI 3 "register_operand" ""))
	       (const_int 0)))]
  ""
  [(set (match_dup 0) 
	(ior:BI (ne:BI (match_dup 3) (const_int 0))
		(match_dup 2)))
   (parallel [(set (match_dup 0) (not:BI (match_dup 0)))
	      (clobber (scratch))])]
  "")

;; ??? Incredibly hackish.  Either need four proper patterns with all
;; the alternatives, or rely on sched1 to split the insn and hope that
;; nothing bad happens to the comparisons in the meantime.
;;
;; Alternately, adjust combine to allow 2->2 and 3->3 splits, assuming
;; that we're doing height reduction.
;
;(define_insn_and_split ""
;  [(set (match_operand:BI 0 "register_operand" "=c")
;	(and:BI (and:BI (match_operator:BI 1 "comparison_operator"
;			  [(match_operand 2 "" "")
;			   (match_operand 3 "" "")])
;			(match_operator:BI 4 "comparison_operator"
;			  [(match_operand 5 "" "")
;			   (match_operand 6 "" "")]))
;		(match_dup 0)))]
;  "flag_schedule_insns"
;  "#"
;  ""
;  [(set (match_dup 0) (and:BI (match_dup 1) (match_dup 0)))
;   (set (match_dup 0) (and:BI (match_dup 4) (match_dup 0)))]
;  "")
;
;(define_insn_and_split ""
;  [(set (match_operand:BI 0 "register_operand" "=c")
;	(ior:BI (ior:BI (match_operator:BI 1 "comparison_operator"
;			  [(match_operand 2 "" "")
;			   (match_operand 3 "" "")])
;			(match_operator:BI 4 "comparison_operator"
;			  [(match_operand 5 "" "")
;			   (match_operand 6 "" "")]))
;		(match_dup 0)))]
;  "flag_schedule_insns"
;  "#"
;  ""
;  [(set (match_dup 0) (ior:BI (match_dup 1) (match_dup 0)))
;   (set (match_dup 0) (ior:BI (match_dup 4) (match_dup 0)))]
;  "")
;
;(define_split
;  [(set (match_operand:BI 0 "register_operand" "")
;	(and:BI (and:BI (match_operator:BI 1 "comparison_operator"
;			  [(match_operand 2 "" "")
;			   (match_operand 3 "" "")])
;			(match_operand:BI 7 "register_operand" ""))
;		(and:BI (match_operator:BI 4 "comparison_operator"
;			  [(match_operand 5 "" "")
;			   (match_operand 6 "" "")])
;			(match_operand:BI 8 "register_operand" ""))))]
;  ""
;  [(set (match_dup 0) (and:BI (match_dup 7) (match_dup 8)))
;   (set (match_dup 0) (and:BI (and:BI (match_dup 1) (match_dup 4))
;			      (match_dup 0)))]
;  "")
;
;(define_split
;  [(set (match_operand:BI 0 "register_operand" "")
;	(ior:BI (ior:BI (match_operator:BI 1 "comparison_operator"
;			  [(match_operand 2 "" "")
;			   (match_operand 3 "" "")])
;			(match_operand:BI 7 "register_operand" ""))
;		(ior:BI (match_operator:BI 4 "comparison_operator"
;			  [(match_operand 5 "" "")
;			   (match_operand 6 "" "")])
;			(match_operand:BI 8 "register_operand" ""))))]
;  ""
;  [(set (match_dup 0) (ior:BI (match_dup 7) (match_dup 8)))
;   (set (match_dup 0) (ior:BI (ior:BI (match_dup 1) (match_dup 4))
;			      (match_dup 0)))]
;  "")

;; Try harder to avoid predicate copies by duplicating compares.
;; Note that we'll have already split the predicate copy, which
;; is kind of a pain, but oh well.

(define_peephole2
  [(set (match_operand:BI 0 "register_operand" "")
	(match_operand:BI 1 "comparison_operator" ""))
   (set (match_operand:CCI 2 "register_operand" "")
	(match_operand:CCI 3 "register_operand" ""))
   (set (match_operand:CCI 4 "register_operand" "")
	(match_operand:CCI 5 "register_operand" ""))
   (set (match_operand:BI 6 "register_operand" "")
	(unspec:BI [(match_dup 6)] 7))]
  "REGNO (operands[3]) == REGNO (operands[0])
   && REGNO (operands[4]) == REGNO (operands[0]) + 1
   && REGNO (operands[4]) == REGNO (operands[2]) + 1
   && REGNO (operands[6]) == REGNO (operands[2])"
  [(set (match_dup 0) (match_dup 1))
   (set (match_dup 6) (match_dup 7))]
  "operands[7] = copy_rtx (operands[1]);")

;; ::::::::::::::::::::
;; ::
;; :: 16 bit Integer arithmetic
;; ::
;; ::::::::::::::::::::

(define_insn "mulhi3"
  [(set (match_operand:HI 0 "gr_register_operand" "=r")
	(mult:HI (match_operand:HI 1 "gr_register_operand" "r")
		 (match_operand:HI 2 "gr_register_operand" "r")))]
  ""
  "pmpy2.r %0 = %1, %2"
  [(set_attr "itanium_class" "mmmul")])


;; ::::::::::::::::::::
;; ::
;; :: 32 bit Integer arithmetic
;; ::
;; ::::::::::::::::::::

(define_insn "addsi3"
  [(set (match_operand:SI 0 "gr_register_operand" "=r,r,r")
	(plus:SI (match_operand:SI 1 "gr_register_operand" "%r,r,a")
		 (match_operand:SI 2 "gr_reg_or_22bit_operand" "r,I,J")))]
  ""
  "@
  add %0 = %1, %2
  adds %0 = %2, %1
  addl %0 = %2, %1"
  [(set_attr "itanium_class" "ialu")])

(define_insn "*addsi3_plus1"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(plus:SI (plus:SI (match_operand:SI 1 "gr_register_operand" "r")
			  (match_operand:SI 2 "gr_register_operand" "r"))
		 (const_int 1)))]
  ""
  "add %0 = %1, %2, 1"
  [(set_attr "itanium_class" "ialu")])

(define_insn "*addsi3_plus1_alt"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(plus:SI (mult:SI (match_operand:SI 1 "gr_register_operand" "r")
			  (const_int 2))
		 (const_int 1)))]
  ""
  "add %0 = %1, %1, 1"
  [(set_attr "itanium_class" "ialu")])

(define_insn "*addsi3_shladd"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(plus:SI (mult:SI (match_operand:SI 1 "gr_register_operand" "r")
			  (match_operand:SI 2 "shladd_operand" "n"))
		 (match_operand:SI 3 "gr_register_operand" "r")))]
  ""
  "shladd %0 = %1, %S2, %3"
  [(set_attr "itanium_class" "ialu")])

(define_insn "subsi3"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(minus:SI (match_operand:SI 1 "gr_reg_or_8bit_operand" "rK")
		  (match_operand:SI 2 "gr_register_operand" "r")))]
  ""
  "sub %0 = %1, %2"
  [(set_attr "itanium_class" "ialu")])

(define_insn "*subsi3_minus1"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(plus:SI (not:SI (match_operand:SI 1 "gr_register_operand" "r"))
		 (match_operand:SI 2 "gr_register_operand" "r")))]
  ""
  "sub %0 = %2, %1, 1"
  [(set_attr "itanium_class" "ialu")])

;; ??? Could add maddsi3 patterns patterned after the madddi3 patterns.

(define_insn "mulsi3"
  [(set (match_operand:SI 0 "fr_register_operand" "=f")
	(mult:SI (match_operand:SI 1 "grfr_register_operand" "f")
		 (match_operand:SI 2 "grfr_register_operand" "f")))]
  ""
  "xmpy.l %0 = %1, %2"
  [(set_attr "itanium_class" "xmpy")])

(define_insn "maddsi4"
  [(set (match_operand:SI 0 "fr_register_operand" "=f")
	(plus:SI (mult:SI (match_operand:SI 1 "grfr_register_operand" "f")
			  (match_operand:SI 2 "grfr_register_operand" "f"))
		 (match_operand:SI 3 "grfr_register_operand" "f")))]
  ""
  "xma.l %0 = %1, %2, %3"
  [(set_attr "itanium_class" "xmpy")])

(define_insn "negsi2"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(neg:SI (match_operand:SI 1 "gr_register_operand" "r")))]
  ""
  "sub %0 = r0, %1"
  [(set_attr "itanium_class" "ialu")])

(define_expand "abssi2"
  [(set (match_dup 2)
	(ge:BI (match_operand:SI 1 "gr_register_operand" "") (const_int 0)))
   (set (match_operand:SI 0 "gr_register_operand" "")
	(if_then_else:SI (eq (match_dup 2) (const_int 0))
			 (neg:SI (match_dup 1))
			 (match_dup 1)))]
  ""
  "
{
  operands[2] = gen_reg_rtx (BImode);
}")

(define_expand "sminsi3"
  [(set (match_dup 3)
	(ge:BI (match_operand:SI 1 "gr_register_operand" "")
	       (match_operand:SI 2 "gr_register_operand" "")))
   (set (match_operand:SI 0 "gr_register_operand" "")
	(if_then_else:SI (ne (match_dup 3) (const_int 0))
			 (match_dup 2) (match_dup 1)))]
  ""
  "
{
  operands[3] = gen_reg_rtx (BImode);
}")

(define_expand "smaxsi3"
  [(set (match_dup 3)
	(ge:BI (match_operand:SI 1 "gr_register_operand" "")
	       (match_operand:SI 2 "gr_register_operand" "")))
   (set (match_operand:SI 0 "gr_register_operand" "")
	(if_then_else:SI (ne (match_dup 3) (const_int 0))
			 (match_dup 1) (match_dup 2)))]
  ""
  "
{
  operands[3] = gen_reg_rtx (BImode);
}")

(define_expand "uminsi3"
  [(set (match_dup 3)
	(geu:BI (match_operand:SI 1 "gr_register_operand" "")
		(match_operand:SI 2 "gr_register_operand" "")))
   (set (match_operand:SI 0 "gr_register_operand" "")
	(if_then_else:SI (ne (match_dup 3) (const_int 0))
			 (match_dup 2) (match_dup 1)))]
  ""
  "
{
  operands[3] = gen_reg_rtx (BImode);
}")

(define_expand "umaxsi3"
  [(set (match_dup 3)
	(geu:BI (match_operand:SI 1 "gr_register_operand" "")
		(match_operand:SI 2 "gr_register_operand" "")))
   (set (match_operand:SI 0 "gr_register_operand" "")
	(if_then_else:SI (ne (match_dup 3) (const_int 0))
			 (match_dup 1) (match_dup 2)))]
  ""
  "
{
  operands[3] = gen_reg_rtx (BImode);
}")

(define_expand "divsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(div:SI (match_operand:SI 1 "general_operand" "")
		(match_operand:SI 2 "general_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;

  op0_tf = gen_reg_rtx (TFmode);
  op0_di = gen_reg_rtx (DImode);

  if (CONSTANT_P (operands[1]))
    operands[1] = force_reg (SImode, operands[1]);
  op1_tf = gen_reg_rtx (TFmode);
  expand_float (op1_tf, operands[1], 0);

  if (CONSTANT_P (operands[2]))
    operands[2] = force_reg (SImode, operands[2]);
  op2_tf = gen_reg_rtx (TFmode);
  expand_float (op2_tf, operands[2], 0);

  /* 2^-34 */
#if 0
  twon34 = (CONST_DOUBLE_FROM_REAL_VALUE
	    (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), TFmode));
  twon34 = force_reg (TFmode, twon34);
#else
  twon34 = gen_reg_rtx (TFmode);
  convert_move (twon34, force_const_mem (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), SFmode)), 0);
#endif

  emit_insn (gen_divsi3_internal (op0_tf, op1_tf, op2_tf, twon34));

  emit_insn (gen_fix_trunctfdi2_alts (op0_di, op0_tf, const1_rtx));
  emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));
  DONE;
}")

(define_expand "modsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(mod:SI (match_operand:SI 1 "general_operand" "")
		(match_operand:SI 2 "general_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx op2_neg, op1_di, div;

  div = gen_reg_rtx (SImode);
  emit_insn (gen_divsi3 (div, operands[1], operands[2]));

  op2_neg = expand_unop (SImode, neg_optab, operands[2], NULL_RTX, 0);

  /* This is a trick to get us to reuse the value that we're sure to
     have already copied to the FP regs.  */
  op1_di = gen_reg_rtx (DImode);
  convert_move (op1_di, operands[1], 0);

  emit_insn (gen_maddsi4 (operands[0], div, op2_neg,
			  gen_lowpart (SImode, op1_di)));
  DONE;
}")

(define_expand "udivsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(udiv:SI (match_operand:SI 1 "general_operand" "")
		 (match_operand:SI 2 "general_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;

  op0_tf = gen_reg_rtx (TFmode);
  op0_di = gen_reg_rtx (DImode);

  if (CONSTANT_P (operands[1]))
    operands[1] = force_reg (SImode, operands[1]);
  op1_tf = gen_reg_rtx (TFmode);
  expand_float (op1_tf, operands[1], 1);

  if (CONSTANT_P (operands[2]))
    operands[2] = force_reg (SImode, operands[2]);
  op2_tf = gen_reg_rtx (TFmode);
  expand_float (op2_tf, operands[2], 1);

  /* 2^-34 */
#if 0
  twon34 = (CONST_DOUBLE_FROM_REAL_VALUE
	    (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), TFmode));
  twon34 = force_reg (TFmode, twon34);
#else
  twon34 = gen_reg_rtx (TFmode);
  convert_move (twon34, force_const_mem (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), SFmode)), 0);
#endif

  emit_insn (gen_divsi3_internal (op0_tf, op1_tf, op2_tf, twon34));

  emit_insn (gen_fixuns_trunctfdi2_alts (op0_di, op0_tf, const1_rtx));
  emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));
  DONE;
}")

(define_expand "umodsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(umod:SI (match_operand:SI 1 "general_operand" "")
		 (match_operand:SI 2 "general_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx op2_neg, op1_di, div;

  div = gen_reg_rtx (SImode);
  emit_insn (gen_udivsi3 (div, operands[1], operands[2]));

  op2_neg = expand_unop (SImode, neg_optab, operands[2], NULL_RTX, 0);

  /* This is a trick to get us to reuse the value that we're sure to
     have already copied to the FP regs.  */
  op1_di = gen_reg_rtx (DImode);
  convert_move (op1_di, operands[1], 1);

  emit_insn (gen_maddsi4 (operands[0], div, op2_neg,
			  gen_lowpart (SImode, op1_di)));
  DONE;
}")

(define_insn_and_split "divsi3_internal"
  [(set (match_operand:TF 0 "fr_register_operand" "=&f")
	(float:TF (div:SI (match_operand:TF 1 "fr_register_operand" "f")
			  (match_operand:TF 2 "fr_register_operand" "f"))))
   (clobber (match_scratch:TF 4 "=&f"))
   (clobber (match_scratch:TF 5 "=&f"))
   (clobber (match_scratch:BI 6 "=c"))
   (use (match_operand:TF 3 "fr_register_operand" "f"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))
	      (set (match_dup 6) (unspec:BI [(match_dup 1) (match_dup 2)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 5)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))
			      (match_dup 7)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 4))
			      (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 5)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 5))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 4))
			      (match_dup 4)))
		(use (const_int 1))]))
  ] 
  "operands[7] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

;; ::::::::::::::::::::
;; ::
;; :: 64 bit Integer arithmetic
;; ::
;; ::::::::::::::::::::

(define_insn "adddi3"
  [(set (match_operand:DI 0 "gr_register_operand" "=r,r,r")
	(plus:DI (match_operand:DI 1 "gr_register_operand" "%r,r,a")
		 (match_operand:DI 2 "gr_reg_or_22bit_operand" "r,I,J")))]
  ""
  "@
  add %0 = %1, %2
  adds %0 = %2, %1
  addl %0 = %2, %1"
  [(set_attr "itanium_class" "ialu")])

(define_insn "*adddi3_plus1"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(plus:DI (plus:DI (match_operand:DI 1 "gr_register_operand" "r")
			  (match_operand:DI 2 "gr_register_operand" "r"))
		 (const_int 1)))]
  ""
  "add %0 = %1, %2, 1"
  [(set_attr "itanium_class" "ialu")])

;; This has some of the same problems as shladd.  We let the shladd
;; eliminator hack handle it, which results in the 1 being forced into
;; a register, but not more ugliness here.
(define_insn "*adddi3_plus1_alt"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(plus:DI (mult:DI (match_operand:DI 1 "gr_register_operand" "r")
			  (const_int 2))
		 (const_int 1)))]
  ""
  "add %0 = %1, %1, 1"
  [(set_attr "itanium_class" "ialu")])

(define_insn "subdi3"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(minus:DI (match_operand:DI 1 "gr_reg_or_8bit_operand" "rK")
		  (match_operand:DI 2 "gr_register_operand" "r")))]
  ""
  "sub %0 = %1, %2"
  [(set_attr "itanium_class" "ialu")])

(define_insn "*subdi3_minus1"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(plus:DI (not:DI (match_operand:DI 1 "gr_register_operand" "r"))
		 (match_operand:DI 2 "gr_register_operand" "r")))]
  ""
  "sub %0 = %2, %1, 1"
  [(set_attr "itanium_class" "ialu")])

;; ??? Use grfr instead of fr because of virtual register elimination
;; and silly test cases multiplying by the frame pointer.
(define_insn "muldi3"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(mult:DI (match_operand:DI 1 "grfr_register_operand" "f")
		 (match_operand:DI 2 "grfr_register_operand" "f")))]
  ""
  "xmpy.l %0 = %1, %2"
  [(set_attr "itanium_class" "xmpy")])

;; ??? If operand 3 is an eliminable reg, then register elimination causes the
;; same problem that we have with shladd below.  Unfortunately, this case is
;; much harder to fix because the multiply puts the result in an FP register,
;; but the add needs inputs from a general register.  We add a spurious clobber
;; here so that it will be present just in case register elimination gives us
;; the funny result.

;; ??? Maybe validate_changes should try adding match_scratch clobbers?

;; ??? Maybe we should change how adds are canonicalized.

(define_insn "madddi4"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(plus:DI (mult:DI (match_operand:DI 1 "grfr_register_operand" "f")
			  (match_operand:DI 2 "grfr_register_operand" "f"))
		 (match_operand:DI 3 "grfr_register_operand" "f")))
   (clobber (match_scratch:DI 4 "=X"))]
  ""
  "xma.l %0 = %1, %2, %3"
  [(set_attr "itanium_class" "xmpy")])

;; This can be created by register elimination if operand3 of shladd is an
;; eliminable register or has reg_equiv_constant set.

;; We have to use nonmemory_operand for operand 4, to ensure that the
;; validate_changes call inside eliminate_regs will always succeed.  If it
;; doesn't succeed, then this remain a madddi4 pattern, and will be reloaded
;; incorrectly.

(define_insn "*madddi4_elim"
  [(set (match_operand:DI 0 "register_operand" "=&r")
	(plus:DI (plus:DI (mult:DI (match_operand:DI 1 "register_operand" "f")
				   (match_operand:DI 2 "register_operand" "f"))
			  (match_operand:DI 3 "register_operand" "f"))
		 (match_operand:DI 4 "nonmemory_operand" "rI")))
   (clobber (match_scratch:DI 5 "=f"))]
  "reload_in_progress"
  "#"
  [(set_attr "itanium_class" "unknown")])

(define_split
  [(set (match_operand:DI 0 "register_operand" "")
	(plus:DI (plus:DI (mult:DI (match_operand:DI 1 "register_operand" "")
				   (match_operand:DI 2 "register_operand" ""))
			  (match_operand:DI 3 "register_operand" ""))
		 (match_operand:DI 4 "gr_reg_or_14bit_operand" "")))
   (clobber (match_scratch:DI 5 ""))]
  "reload_completed"
  [(parallel [(set (match_dup 5) (plus:DI (mult:DI (match_dup 1) (match_dup 2))
					  (match_dup 3)))
	      (clobber (match_dup 0))])
   (set (match_dup 0) (match_dup 5))
   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]
  "")

;; ??? There are highpart multiply and add instructions, but we have no way
;; to generate them.

(define_insn "smuldi3_highpart"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(truncate:DI
	 (lshiftrt:TI
	  (mult:TI (sign_extend:TI
		     (match_operand:DI 1 "fr_register_operand" "f"))
		   (sign_extend:TI
		     (match_operand:DI 2 "fr_register_operand" "f")))
	  (const_int 64))))]
  ""
  "xmpy.h %0 = %1, %2"
  [(set_attr "itanium_class" "xmpy")])

(define_insn "umuldi3_highpart"
  [(set (match_operand:DI 0 "fr_register_operand" "=f")
	(truncate:DI
	 (lshiftrt:TI
	  (mult:TI (zero_extend:TI
		     (match_operand:DI 1 "fr_register_operand" "f"))
		   (zero_extend:TI
		     (match_operand:DI 2 "fr_register_operand" "f")))
	  (const_int 64))))]
  ""
  "xmpy.hu %0 = %1, %2"
  [(set_attr "itanium_class" "xmpy")])

(define_insn "negdi2"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(neg:DI (match_operand:DI 1 "gr_register_operand" "r")))]
  ""
  "sub %0 = r0, %1"
  [(set_attr "itanium_class" "ialu")])

(define_expand "absdi2"
  [(set (match_dup 2)
	(ge:BI (match_operand:DI 1 "gr_register_operand" "") (const_int 0)))
   (set (match_operand:DI 0 "gr_register_operand" "")
	(if_then_else:DI (eq (match_dup 2) (const_int 0))
			 (neg:DI (match_dup 1))
			 (match_dup 1)))]
  ""
  "
{
  operands[2] = gen_reg_rtx (BImode);
}")

(define_expand "smindi3"
  [(set (match_dup 3)
	(ge:BI (match_operand:DI 1 "gr_register_operand" "")
	       (match_operand:DI 2 "gr_register_operand" "")))
   (set (match_operand:DI 0 "gr_register_operand" "")
	(if_then_else:DI (ne (match_dup 3) (const_int 0))
			 (match_dup 2) (match_dup 1)))]
  ""
  "
{
  operands[3] = gen_reg_rtx (BImode);
}")

(define_expand "smaxdi3"
  [(set (match_dup 3)
	(ge:BI (match_operand:DI 1 "gr_register_operand" "")
	       (match_operand:DI 2 "gr_register_operand" "")))
   (set (match_operand:DI 0 "gr_register_operand" "")
	(if_then_else:DI (ne (match_dup 3) (const_int 0))
			 (match_dup 1) (match_dup 2)))]
  ""
  "
{
  operands[3] = gen_reg_rtx (BImode);
}")

(define_expand "umindi3"
  [(set (match_dup 3)
	(geu:BI (match_operand:DI 1 "gr_register_operand" "")
		(match_operand:DI 2 "gr_register_operand" "")))
   (set (match_operand:DI 0 "gr_register_operand" "")
	(if_then_else:DI (ne (match_dup 3) (const_int 0))
			 (match_dup 2) (match_dup 1)))]
  ""
  "
{
  operands[3] = gen_reg_rtx (BImode);
}")

(define_expand "umaxdi3"
  [(set (match_dup 3)
	(geu:BI (match_operand:DI 1 "gr_register_operand" "")
		(match_operand:DI 2 "gr_register_operand" "")))
   (set (match_operand:DI 0 "gr_register_operand" "")
	(if_then_else:DI (ne (match_dup 3) (const_int 0))
			 (match_dup 1) (match_dup 2)))]
  ""
  "
{
  operands[3] = gen_reg_rtx (BImode);
}")

(define_expand "ffsdi2"
  [(set (match_dup 6)
	(eq:BI (match_operand:DI 1 "gr_register_operand" "") (const_int 0)))
   (set (match_dup 2) (plus:DI (match_dup 1) (const_int -1)))
   (set (match_dup 5) (const_int 0))
   (set (match_dup 3) (xor:DI (match_dup 1) (match_dup 2)))
   (set (match_dup 4) (unspec:DI [(match_dup 3)] 8))
   (set (match_operand:DI 0 "gr_register_operand" "")
	(if_then_else:DI (ne (match_dup 6) (const_int 0))
			 (match_dup 5) (match_dup 4)))]
  ""
  "
{
  operands[2] = gen_reg_rtx (DImode);
  operands[3] = gen_reg_rtx (DImode);
  operands[4] = gen_reg_rtx (DImode);
  operands[5] = gen_reg_rtx (DImode);
  operands[6] = gen_reg_rtx (BImode);
}")

(define_insn "*popcnt"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(unspec:DI [(match_operand:DI 1 "gr_register_operand" "r")] 8))]
  ""
  "popcnt %0 = %1"
  [(set_attr "itanium_class" "mmmul")])

(define_expand "divdi3"
  [(set (match_operand:DI 0 "register_operand" "")
	(div:DI (match_operand:DI 1 "general_operand" "")
		(match_operand:DI 2 "general_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx op1_tf, op2_tf, op0_tf;

  op0_tf = gen_reg_rtx (TFmode);

  if (CONSTANT_P (operands[1]))
    operands[1] = force_reg (DImode, operands[1]);
  op1_tf = gen_reg_rtx (TFmode);
  expand_float (op1_tf, operands[1], 0);

  if (CONSTANT_P (operands[2]))
    operands[2] = force_reg (DImode, operands[2]);
  op2_tf = gen_reg_rtx (TFmode);
  expand_float (op2_tf, operands[2], 0);

  if (TARGET_INLINE_DIV_LAT)
    emit_insn (gen_divdi3_internal_lat (op0_tf, op1_tf, op2_tf));
  else
    emit_insn (gen_divdi3_internal_thr (op0_tf, op1_tf, op2_tf));

  emit_insn (gen_fix_trunctfdi2_alts (operands[0], op0_tf, const1_rtx));
  DONE;
}")

(define_expand "moddi3"
  [(set (match_operand:DI 0 "register_operand" "")
	(mod:SI (match_operand:DI 1 "general_operand" "")
		(match_operand:DI 2 "general_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx op2_neg, div;

  div = gen_reg_rtx (DImode);
  emit_insn (gen_divdi3 (div, operands[1], operands[2]));

  op2_neg = expand_unop (DImode, neg_optab, operands[2], NULL_RTX, 0);

  emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));
  DONE;
}")

(define_expand "udivdi3"
  [(set (match_operand:DI 0 "register_operand" "")
	(udiv:DI (match_operand:DI 1 "general_operand" "")
		 (match_operand:DI 2 "general_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx op1_tf, op2_tf, op0_tf;

  op0_tf = gen_reg_rtx (TFmode);

  if (CONSTANT_P (operands[1]))
    operands[1] = force_reg (DImode, operands[1]);
  op1_tf = gen_reg_rtx (TFmode);
  expand_float (op1_tf, operands[1], 1);

  if (CONSTANT_P (operands[2]))
    operands[2] = force_reg (DImode, operands[2]);
  op2_tf = gen_reg_rtx (TFmode);
  expand_float (op2_tf, operands[2], 1);

  if (TARGET_INLINE_DIV_LAT)
    emit_insn (gen_divdi3_internal_lat (op0_tf, op1_tf, op2_tf));
  else
    emit_insn (gen_divdi3_internal_thr (op0_tf, op1_tf, op2_tf));

  emit_insn (gen_fixuns_trunctfdi2_alts (operands[0], op0_tf, const1_rtx));
  DONE;
}")

(define_expand "umoddi3"
  [(set (match_operand:DI 0 "register_operand" "")
	(umod:DI (match_operand:DI 1 "general_operand" "")
		 (match_operand:DI 2 "general_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx op2_neg, div;

  div = gen_reg_rtx (DImode);
  emit_insn (gen_udivdi3 (div, operands[1], operands[2]));

  op2_neg = expand_unop (DImode, neg_optab, operands[2], NULL_RTX, 0);

  emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));
  DONE;
}")

(define_insn_and_split "divdi3_internal_lat"
  [(set (match_operand:TF 0 "fr_register_operand" "=&f")
	(float:TF (div:SI (match_operand:TF 1 "fr_register_operand" "f")
			  (match_operand:TF 2 "fr_register_operand" "f"))))
   (clobber (match_scratch:TF 3 "=&f"))
   (clobber (match_scratch:TF 4 "=&f"))
   (clobber (match_scratch:TF 5 "=&f"))
   (clobber (match_scratch:BI 6 "=c"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_LAT"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))
	      (set (match_dup 6) (unspec:BI [(match_dup 1) (match_dup 2)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))
			      (match_dup 7)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 5) (mult:TF (match_dup 3) (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 4))
			      (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 0))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 4))
			      (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 0))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))
			      (match_dup 1)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 0))
			      (match_dup 3)))
		(use (const_int 1))]))
  ] 
  "operands[7] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

(define_insn_and_split "divdi3_internal_thr"
  [(set (match_operand:TF 0 "fr_register_operand" "=&f")
	(float:TF (div:SI (match_operand:TF 1 "fr_register_operand" "f")
			  (match_operand:TF 2 "fr_register_operand" "f"))))
   (clobber (match_scratch:TF 3 "=&f"))
   (clobber (match_scratch:TF 4 "=f"))
   (clobber (match_scratch:BI 5 "=c"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_THR"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))
	      (set (match_dup 5) (unspec:BI [(match_dup 1) (match_dup 2)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))
			      (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 0))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3) (mult:TF (match_dup 3) (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 0))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3) (mult:TF (match_dup 0) (match_dup 1)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))
			      (match_dup 1)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 0))
			      (match_dup 3)))
		(use (const_int 1))]))
  ] 
  "operands[6] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

;; ::::::::::::::::::::
;; ::
;; :: 32 bit floating point arithmetic
;; ::
;; ::::::::::::::::::::

(define_insn "addsf3"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(plus:SF (match_operand:SF 1 "fr_register_operand" "%f")
		 (match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fadd.s %0 = %1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "subsf3"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(minus:SF (match_operand:SF 1 "fr_reg_or_fp01_operand" "fG")
		  (match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fsub.s %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "mulsf3"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(mult:SF (match_operand:SF 1 "fr_register_operand" "%f")
		 (match_operand:SF 2 "fr_register_operand" "f")))]
  ""
  "fmpy.s %0 = %1, %2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "abssf2"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(abs:SF (match_operand:SF 1 "fr_register_operand" "f")))]
  ""
  "fabs %0 = %1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "negsf2"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(neg:SF (match_operand:SF 1 "fr_register_operand" "f")))]
  ""
  "fneg %0 = %1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "*nabssf2"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(neg:SF (abs:SF (match_operand:SF 1 "fr_register_operand" "f"))))]
  ""
  "fnegabs %0 = %1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "minsf3"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(smin:SF (match_operand:SF 1 "fr_register_operand" "f")
		 (match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fmin %0 = %1, %F2"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "maxsf3"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(smax:SF (match_operand:SF 1 "fr_register_operand" "f")
		 (match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fmax %0 = %1, %F2"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "*maddsf4"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(plus:SF (mult:SF (match_operand:SF 1 "fr_register_operand" "f")
			  (match_operand:SF 2 "fr_register_operand" "f"))
		 (match_operand:SF 3 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fma.s %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*msubsf4"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(minus:SF (mult:SF (match_operand:SF 1 "fr_register_operand" "f")
			   (match_operand:SF 2 "fr_register_operand" "f"))
		  (match_operand:SF 3 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fms.s %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmulsf3"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(neg:SF (mult:SF (match_operand:SF 1 "fr_register_operand" "f")
			 (match_operand:SF 2 "fr_register_operand" "f"))))]
  ""
  "fnmpy.s %0 = %1, %2"
  [(set_attr "itanium_class" "fmac")])

;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?

(define_insn "*nmaddsf4"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(plus:SF (neg:SF (mult:SF
			   (match_operand:SF 1 "fr_register_operand" "f")
			   (match_operand:SF 2 "fr_register_operand" "f")))
		 (match_operand:SF 3 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fnma.s %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_expand "divsf3"
  [(set (match_operand:SF 0 "fr_register_operand" "")
	(div:SF (match_operand:SF 1 "fr_register_operand" "")
		(match_operand:SF 2 "fr_register_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx insn;
  if (TARGET_INLINE_DIV_LAT)
    insn = gen_divsf3_internal_lat (operands[0], operands[1], operands[2]);
  else
    insn = gen_divsf3_internal_thr (operands[0], operands[1], operands[2]);
  emit_insn (insn);
  DONE;
}")

(define_insn_and_split "divsf3_internal_lat"
  [(set (match_operand:SF 0 "fr_register_operand" "=&f")
	(div:SF (match_operand:SF 1 "fr_register_operand" "f")
		(match_operand:SF 2 "fr_register_operand" "f")))
   (clobber (match_scratch:TF 3 "=&f"))
   (clobber (match_scratch:TF 4 "=f"))
   (clobber (match_scratch:BI 5 "=c"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_LAT"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))
	      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3) (mult:TF (match_dup 7) (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 8) (match_dup 6)))
			      (match_dup 10)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 3))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4) (mult:TF (match_dup 4) (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 3))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4) (mult:TF (match_dup 4) (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 9)
		     (float_truncate:DF
		       (plus:TF (mult:TF (match_dup 4) (match_dup 3))
			      (match_dup 3))))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (set (match_dup 0)
	  (float_truncate:SF (match_dup 6))))
  ] 
  "operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));
   operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));
   operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));
   operands[9] = gen_rtx_REG (DFmode, REGNO (operands[0]));
   operands[10] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

(define_insn_and_split "divsf3_internal_thr"
  [(set (match_operand:SF 0 "fr_register_operand" "=&f")
	(div:SF (match_operand:SF 1 "fr_register_operand" "f")
		(match_operand:SF 2 "fr_register_operand" "f")))
   (clobber (match_scratch:TF 3 "=&f"))
   (clobber (match_scratch:TF 4 "=f"))
   (clobber (match_scratch:BI 5 "=c"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_THR"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))
	      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (neg:TF (mult:TF (match_dup 8) (match_dup 6)))
			      (match_dup 10)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 3))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 6)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 6))
			      (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 9)
		     (float_truncate:SF
		       (mult:TF (match_dup 7) (match_dup 6))))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 8) (match_dup 3)))
			      (match_dup 7)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (set (match_dup 0)
	  (float_truncate:SF
	    (plus:TF (mult:TF (match_dup 4) (match_dup 6))
			      (match_dup 3)))))
  ] 
  "operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));
   operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));
   operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));
   operands[9] = gen_rtx_REG (SFmode, REGNO (operands[3]));
   operands[10] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

;; ::::::::::::::::::::
;; ::
;; :: 64 bit floating point arithmetic
;; ::
;; ::::::::::::::::::::

(define_insn "adddf3"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(plus:DF (match_operand:DF 1 "fr_register_operand" "%f")
		 (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fadd.d %0 = %1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*adddf3_trunc"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (plus:DF (match_operand:DF 1 "fr_register_operand" "%f")
		   (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG"))))]
  ""
  "fadd.s %0 = %1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "subdf3"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(minus:DF (match_operand:DF 1 "fr_reg_or_fp01_operand" "fG")
		  (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fsub.d %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*subdf3_trunc"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (minus:DF (match_operand:DF 1 "fr_reg_or_fp01_operand" "fG")
		    (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG"))))]
  ""
  "fsub.s %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "muldf3"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(mult:DF (match_operand:DF 1 "fr_register_operand" "f")
		 (match_operand:DF 2 "fr_register_operand" "f")))]
  ""
  "fmpy.d %0 = %1, %2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*muldf3_trunc"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
		   (match_operand:DF 2 "fr_register_operand" "f"))))]
  ""
  "fmpy.s %0 = %1, %2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "absdf2"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(abs:DF (match_operand:DF 1 "fr_register_operand" "f")))]
  ""
  "fabs %0 = %1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "negdf2"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(neg:DF (match_operand:DF 1 "fr_register_operand" "f")))]
  ""
  "fneg %0 = %1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "*nabsdf2"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(neg:DF (abs:DF (match_operand:DF 1 "fr_register_operand" "f"))))]
  ""
  "fnegabs %0 = %1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "mindf3"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(smin:DF (match_operand:DF 1 "fr_register_operand" "f")
		 (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fmin %0 = %1, %F2"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "maxdf3"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(smax:DF (match_operand:DF 1 "fr_register_operand" "f")
		 (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fmax %0 = %1, %F2"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "*madddf4"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(plus:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
			  (match_operand:DF 2 "fr_register_operand" "f"))
		 (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fma.d %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*madddf4_trunc"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (plus:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
			    (match_operand:DF 2 "fr_register_operand" "f"))
		   (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG"))))]
  ""
  "fma.s %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*msubdf4"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(minus:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
			   (match_operand:DF 2 "fr_register_operand" "f"))
		  (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fms.d %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*msubdf4_trunc"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (minus:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
			     (match_operand:DF 2 "fr_register_operand" "f"))
		    (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG"))))]
  ""
  "fms.s %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmuldf3"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(neg:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
			 (match_operand:DF 2 "fr_register_operand" "f"))))]
  ""
  "fnmpy.d %0 = %1, %2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmuldf3_trunc"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (neg:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
			   (match_operand:DF 2 "fr_register_operand" "f")))))]
  ""
  "fnmpy.s %0 = %1, %2"
  [(set_attr "itanium_class" "fmac")])

;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?

(define_insn "*nmadddf4"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(plus:DF (neg:DF (mult:DF
			   (match_operand:DF 1 "fr_register_operand" "f")
			   (match_operand:DF 2 "fr_register_operand" "f")))
		 (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")))]
  ""
  "fnma.d %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmadddf4_alts"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(plus:DF (neg:DF (mult:DF
			   (match_operand:DF 1 "fr_register_operand" "f")
			   (match_operand:DF 2 "fr_register_operand" "f")))
		 (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")))
   (use (match_operand:SI 4 "const_int_operand" ""))]
  ""
  "fnma.d.s%4 %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmadddf4_trunc"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (plus:DF (neg:DF (mult:DF
			     (match_operand:DF 1 "fr_register_operand" "f")
			     (match_operand:DF 2 "fr_register_operand" "f")))
		   (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG"))))]
  ""
  "fnma.s %0 = %1, %2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_expand "divdf3"
  [(set (match_operand:DF 0 "fr_register_operand" "")
	(div:DF (match_operand:DF 1 "fr_register_operand" "")
		(match_operand:DF 2 "fr_register_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx insn;
  if (TARGET_INLINE_DIV_LAT)
    insn = gen_divdf3_internal_lat (operands[0], operands[1], operands[2]);
  else
    insn = gen_divdf3_internal_thr (operands[0], operands[1], operands[2]);
  emit_insn (insn);
  DONE;
}")

(define_insn_and_split "divdf3_internal_lat"
  [(set (match_operand:DF 0 "fr_register_operand" "=&f")
	(div:DF (match_operand:DF 1 "fr_register_operand" "f")
		(match_operand:DF 2 "fr_register_operand" "f")))
   (clobber (match_scratch:TF 3 "=&f"))
   (clobber (match_scratch:TF 4 "=&f"))
   (clobber (match_scratch:TF 5 "=&f"))
   (clobber (match_scratch:BI 6 "=c"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_LAT"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 7) (div:TF (const_int 1) (match_dup 9)))
	      (set (match_dup 6) (unspec:BI [(match_dup 8) (match_dup 9)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 3) (mult:TF (match_dup 8) (match_dup 7)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 9) (match_dup 7)))
			      (match_dup 12)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 3))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 5) (mult:TF (match_dup 4) (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 7)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 7))
			      (match_dup 7)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 3))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 4) (mult:TF (match_dup 5) (match_dup 5)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 7)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 7))
			      (match_dup 7)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 10)
		     (float_truncate:DF
		       (plus:TF (mult:TF (match_dup 4) (match_dup 3))
			      (match_dup 3))))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 7)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 7))
			      (match_dup 7)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (parallel [(set (match_dup 11)
		     (float_truncate:DF
		       (plus:TF (neg:TF (mult:TF (match_dup 9) (match_dup 3)))
			        (match_dup 8))))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 6) (const_int 0))
     (set (match_dup 0)
	  (float_truncate:DF (plus:TF (mult:TF (match_dup 5) (match_dup 7))
			      (match_dup 3)))))
  ] 
  "operands[7] = gen_rtx_REG (TFmode, REGNO (operands[0]));
   operands[8] = gen_rtx_REG (TFmode, REGNO (operands[1]));
   operands[9] = gen_rtx_REG (TFmode, REGNO (operands[2]));
   operands[10] = gen_rtx_REG (DFmode, REGNO (operands[3]));
   operands[11] = gen_rtx_REG (DFmode, REGNO (operands[5]));
   operands[12] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

(define_insn_and_split "divdf3_internal_thr"
  [(set (match_operand:DF 0 "fr_register_operand" "=&f")
	(div:DF (match_operand:DF 1 "fr_register_operand" "f")
		(match_operand:DF 2 "fr_register_operand" "f")))
   (clobber (match_scratch:TF 3 "=&f"))
   (clobber (match_scratch:DF 4 "=f"))
   (clobber (match_scratch:BI 5 "=c"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_THR"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))
	      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (neg:TF (mult:TF (match_dup 8) (match_dup 6)))
			      (match_dup 10)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 6)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 6))
			      (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (mult:TF (match_dup 3) (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 6)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 6))
			      (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (mult:TF (match_dup 3) (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 6)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 6))
			      (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 9)
		     (float_truncate:DF
		       (mult:TF (match_dup 7) (match_dup 3))))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:DF (neg:DF (mult:DF (match_dup 2) (match_dup 9)))
			      (match_dup 1)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (set (match_dup 0)
	  (plus:DF (mult:DF (match_dup 4) (match_dup 0))
			    (match_dup 9))))
  ] 
  "operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));
   operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));
   operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));
   operands[9] = gen_rtx_REG (DFmode, REGNO (operands[3]));
   operands[10] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

;; ::::::::::::::::::::
;; ::
;; :: 80 bit floating point arithmetic
;; ::
;; ::::::::::::::::::::

(define_insn "addtf3"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(plus:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fadd %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*addtf3_truncsf"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (plus:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		   (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fadd.s %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*addtf3_truncdf"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (plus:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		   (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fadd.d %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "subtf3"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(minus:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		  (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fsub %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*subtf3_truncsf"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (minus:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fsub.s %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*subtf3_truncdf"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (minus:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fsub.d %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "multf3"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fmpy %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*multf3_truncsf"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		   (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fmpy.s %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*multf3_truncdf"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		   (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fmpy.d %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*multf3_alts"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))
   (use (match_operand:SI 3 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fmpy.s%3 %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*multf3_truncsf_alts"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		   (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))
   (use (match_operand:SI 3 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fmpy.s.s%3 %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*multf3_truncdf_alts"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		   (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))
   (use (match_operand:SI 3 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fmpy.d.s%3 %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "abstf2"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(abs:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fabs %0 = %F1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "negtf2"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(neg:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fneg %0 = %F1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "*nabstf2"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(neg:TF (abs:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnegabs %0 = %F1"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "mintf3"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(smin:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fmin %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "maxtf3"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(smax:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fmax %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmisc")])

(define_insn "*maddtf4"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(plus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			  (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
		 (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fma %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*maddtf4_truncsf"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (plus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
		   (match_operand:TF 3 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fma.s %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*maddtf4_truncdf"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (plus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
		   (match_operand:TF 3 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fma.d %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*maddtf4_alts"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(plus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			  (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
		 (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")))
   (use (match_operand:SI 4 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fma.s%4 %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*maddtf4_alts_truncdf"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (plus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
		   (match_operand:TF 3 "tfreg_or_fp01_operand" "fG"))))
   (use (match_operand:SI 4 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fma.d.s%4 %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*msubtf4"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(minus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			   (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
		  (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fms %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*msubtf4_truncsf"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (minus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			     (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
		    (match_operand:TF 3 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fms.s %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*msubtf4_truncdf"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (minus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			     (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
		    (match_operand:TF 3 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fms.d %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmultf3"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(neg:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnmpy %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmultf3_truncsf"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (neg:TF (mult:TF
		    (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnmpy.s %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmultf3_truncdf"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (neg:TF (mult:TF
		    (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnmpy.d %0 = %F1, %F2"
  [(set_attr "itanium_class" "fmac")])

;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?

(define_insn "*nmaddtf4"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(plus:TF (neg:TF (mult:TF
			  (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			  (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))
		 (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnma %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmaddtf4_truncsf"
  [(set (match_operand:SF 0 "fr_register_operand" "=f")
	(float_truncate:SF
	  (plus:TF (neg:TF (mult:TF
			    (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))
		   (match_operand:TF 3 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnma.s %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmaddtf4_truncdf"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (plus:TF (neg:TF (mult:TF
			    (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			    (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))
		   (match_operand:TF 3 "tfreg_or_fp01_operand" "fG"))))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnma.d %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmaddtf4_alts"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(plus:TF (neg:TF (mult:TF
			  (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
			  (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))
		 (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")))
   (use (match_operand:SI 4 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnma.s%4 %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_insn "*nmaddtf4_truncdf_alts"
  [(set (match_operand:DF 0 "fr_register_operand" "=f")
	(float_truncate:DF
	  (plus:TF (neg:TF
		     (mult:TF
		       (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
		       (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))
		 (match_operand:TF 3 "tfreg_or_fp01_operand" "fG"))))
   (use (match_operand:SI 4 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fnma.d.s%4 %0 = %F1, %F2, %F3"
  [(set_attr "itanium_class" "fmac")])

(define_expand "divtf3"
  [(set (match_operand:TF 0 "fr_register_operand" "")
	(div:TF (match_operand:TF 1 "fr_register_operand" "")
		(match_operand:TF 2 "fr_register_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV"
  "
{
  rtx insn;
  if (TARGET_INLINE_DIV_LAT)
    insn = gen_divtf3_internal_lat (operands[0], operands[1], operands[2]);
  else
    insn = gen_divtf3_internal_thr (operands[0], operands[1], operands[2]);
  emit_insn (insn);
  DONE;
}")

(define_insn_and_split "divtf3_internal_lat"
  [(set (match_operand:TF 0 "fr_register_operand" "=&f")
	(div:TF (match_operand:TF 1 "fr_register_operand" "f")
		(match_operand:TF 2 "fr_register_operand" "f")))
   (clobber (match_scratch:TF 3 "=&f"))
   (clobber (match_scratch:TF 4 "=&f"))
   (clobber (match_scratch:TF 5 "=&f"))
   (clobber (match_scratch:TF 6 "=&f"))
   (clobber (match_scratch:BI 7 "=c"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_LAT"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))
	      (set (match_dup 7) (unspec:BI [(match_dup 1) (match_dup 2)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))
			      (match_dup 8)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 5) (mult:TF (match_dup 3) (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 6)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 3))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 5))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 5)
		     (plus:TF (mult:TF (match_dup 6) (match_dup 0))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 5) (match_dup 3))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 4)))
			      (match_dup 1)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 0))
			      (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 5)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))
			      (match_dup 8)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 0))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))
			      (match_dup 1)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 7) (const_int 0))
     (set (match_dup 0)
	  (plus:TF (mult:TF (match_dup 4) (match_dup 0))
		   (match_dup 3))))
  ] 
  "operands[8] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

(define_insn_and_split "divtf3_internal_thr"
  [(set (match_operand:TF 0 "fr_register_operand" "=&f")
	(div:TF (match_operand:TF 1 "fr_register_operand" "f")
		(match_operand:TF 2 "fr_register_operand" "f")))
   (clobber (match_scratch:TF 3 "=&f"))
   (clobber (match_scratch:TF 4 "=&f"))
   (clobber (match_scratch:BI 5 "=c"))]
  "INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV_THR"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))
	      (set (match_dup 5) (unspec:BI [(match_dup 1) (match_dup 2)] 5))
	      (use (const_int 1))])
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))
			      (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 0))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3) (mult:TF (match_dup 3) (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 4))
			      (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))
			      (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 0) (match_dup 3))
			      (match_dup 3)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 4)))
			      (match_dup 1)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 3)
		     (plus:TF (mult:TF (match_dup 3) (match_dup 0))
			      (match_dup 4)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))
			      (match_dup 6)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 0)
		     (plus:TF (mult:TF (match_dup 4) (match_dup 0))
			      (match_dup 0)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (parallel [(set (match_dup 4)
		     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))
			      (match_dup 1)))
		(use (const_int 1))]))
   (cond_exec (ne (match_dup 5) (const_int 0))
     (set (match_dup 0)
	  (plus:TF (mult:TF (match_dup 4) (match_dup 0))
		   (match_dup 3))))
  ] 
  "operands[6] = CONST1_RTX (TFmode);"
  [(set_attr "predicable" "no")])

;; ??? frcpa works like cmp.foo.unc.

(define_insn "*recip_approx"
  [(set (match_operand:TF 0 "fr_register_operand" "=f")
	(div:TF (const_int 1)
		(match_operand:TF 3 "fr_register_operand" "f")))
   (set (match_operand:BI 1 "register_operand" "=c")
	(unspec:BI [(match_operand:TF 2 "fr_register_operand" "f")
		    (match_dup 3)] 5))
   (use (match_operand:SI 4 "const_int_operand" ""))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "frcpa.s%4 %0, %1 = %2, %3"
  [(set_attr "itanium_class" "fmisc")
   (set_attr "predicable" "no")])

;; ::::::::::::::::::::
;; ::
;; :: 32 bit Integer Shifts and Rotates
;; ::
;; ::::::::::::::::::::

(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "gr_register_operand" "")
	(ashift:SI (match_operand:SI 1 "gr_register_operand" "")
		   (match_operand:SI 2 "gr_reg_or_5bit_operand" "")))]
  ""
  "
{
  if (GET_CODE (operands[2]) != CONST_INT)
    {
      /* Why oh why didn't Intel arrange for SHIFT_COUNT_TRUNCATED?  Now
	 we've got to get rid of stray bits outside the SImode register.  */
      rtx subshift = gen_reg_rtx (DImode);
      emit_insn (gen_zero_extendsidi2 (subshift, operands[2]));
      operands[2] = subshift;
    }
}")

(define_insn "*ashlsi3_internal"
  [(set (match_operand:SI 0 "gr_register_operand" "=r,r,r")
	(ashift:SI (match_operand:SI 1 "gr_register_operand" "r,r,r")
		   (match_operand:DI 2 "gr_reg_or_5bit_operand" "R,n,r")))]
  ""
  "@
   shladd %0 = %1, %2, r0
   dep.z %0 = %1, %2, %E2
   shl %0 = %1, %2"
  [(set_attr "itanium_class" "ialu,ishf,mmshf")])

(define_expand "ashrsi3"
  [(set (match_operand:SI 0 "gr_register_operand" "")
	(ashiftrt:SI (match_operand:SI 1 "gr_register_operand" "")
		     (match_operand:SI 2 "gr_reg_or_5bit_operand" "")))]
  ""
  "
{
  rtx subtarget = gen_reg_rtx (DImode);
  if (GET_CODE (operands[2]) == CONST_INT)
    emit_insn (gen_extv (subtarget, gen_lowpart (DImode, operands[1]),
			 GEN_INT (32 - INTVAL (operands[2])), operands[2]));
  else
    {
      rtx subshift = gen_reg_rtx (DImode);
      emit_insn (gen_extendsidi2 (subtarget, operands[1]));
      emit_insn (gen_zero_extendsidi2 (subshift, operands[2]));
      emit_insn (gen_ashrdi3 (subtarget, subtarget, subshift));
    }
  emit_move_insn (gen_lowpart (DImode, operands[0]), subtarget);
  DONE;
}")

(define_expand "lshrsi3"
  [(set (match_operand:SI 0 "gr_register_operand" "")
	(lshiftrt:SI (match_operand:SI 1 "gr_register_operand" "")
		     (match_operand:SI 2 "gr_reg_or_5bit_operand" "")))]
  ""
  "
{
  rtx subtarget = gen_reg_rtx (DImode);
  if (GET_CODE (operands[2]) == CONST_INT)
    emit_insn (gen_extzv (subtarget, gen_lowpart (DImode, operands[1]),
			  GEN_INT (32 - INTVAL (operands[2])), operands[2]));
  else
    {
      rtx subshift = gen_reg_rtx (DImode);
      emit_insn (gen_zero_extendsidi2 (subtarget, operands[1]));
      emit_insn (gen_zero_extendsidi2 (subshift, operands[2]));
      emit_insn (gen_lshrdi3 (subtarget, subtarget, subshift));
    }
  emit_move_insn (gen_lowpart (DImode, operands[0]), subtarget);
  DONE;
}")

;; Use mix4.r/shr to implement rotrsi3.  We only get 32 bits of valid result
;; here, instead of 64 like the patterns above.  Keep the pattern together
;; until after combine; otherwise it won't get matched often.

(define_expand "rotrsi3"
  [(set (match_operand:SI 0 "gr_register_operand" "")
	(rotatert:SI (match_operand:SI 1 "gr_register_operand" "")
		     (match_operand:SI 2 "gr_reg_or_5bit_operand" "")))]
  ""
  "
{
  if (GET_MODE (operands[2]) != VOIDmode)
    {
      rtx tmp = gen_reg_rtx (DImode);
      emit_insn (gen_zero_extendsidi2 (tmp, operands[2]));
      operands[2] = tmp;
    }
}")

(define_insn_and_split "*rotrsi3_internal"
  [(set (match_operand:SI 0 "gr_register_operand" "=&r")
	(rotatert:SI (match_operand:SI 1 "gr_register_operand" "r")
		     (match_operand:DI 2 "gr_reg_or_5bit_operand" "rM")))]
  ""
  "#"
  "reload_completed"
  [(set (match_dup 3)
	(ior:DI (zero_extend:DI (match_dup 1))
		(ashift:DI (zero_extend:DI (match_dup 1)) (const_int 32))))
   (set (match_dup 3)
	(lshiftrt:DI (match_dup 3) (match_dup 2)))]
  "operands[3] = gen_rtx_REG (DImode, REGNO (operands[0]));")

(define_expand "rotlsi3"
  [(set (match_operand:SI 0 "gr_register_operand" "")
	(rotate:SI (match_operand:SI 1 "gr_register_operand" "")
		   (match_operand:SI 2 "gr_reg_or_5bit_operand" "")))]
  ""
  "
{
  if (! shift_32bit_count_operand (operands[2], SImode))
    {
      rtx tmp = gen_reg_rtx (SImode);
      emit_insn (gen_subsi3 (tmp, GEN_INT (32), operands[2]));
      emit_insn (gen_rotrsi3 (operands[0], operands[1], tmp));
      DONE;
    }
}")

(define_insn_and_split "*rotlsi3_internal"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(rotate:SI (match_operand:SI 1 "gr_register_operand" "r")
		   (match_operand:SI 2 "shift_32bit_count_operand" "n")))]
  ""
  "#"
  "reload_completed"
  [(set (match_dup 3)
	(ior:DI (zero_extend:DI (match_dup 1))
		(ashift:DI (zero_extend:DI (match_dup 1)) (const_int 32))))
   (set (match_dup 3)
	(lshiftrt:DI (match_dup 3) (match_dup 2)))]
  "operands[3] = gen_rtx_REG (DImode, REGNO (operands[0]));
   operands[2] = GEN_INT (32 - INTVAL (operands[2]));")

;; ::::::::::::::::::::
;; ::
;; :: 64 bit Integer Shifts and Rotates
;; ::
;; ::::::::::::::::::::

(define_insn "ashldi3"
  [(set (match_operand:DI 0 "gr_register_operand" "=r,r,r")
	(ashift:DI (match_operand:DI 1 "gr_register_operand" "r,r,r")
		   (match_operand:DI 2 "gr_reg_or_6bit_operand" "R,r,rM")))]
  ""
  "@
   shladd %0 = %1, %2, r0
   shl %0 = %1, %2
   shl %0 = %1, %2"
  [(set_attr "itanium_class" "ialu,mmshf,mmshfi")])

;; ??? Maybe combine this with the multiply and add instruction?

(define_insn "*shladd"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(plus:DI (mult:DI (match_operand:DI 1 "gr_register_operand" "r")
			  (match_operand:DI 2 "shladd_operand" "n"))
		 (match_operand:DI 3 "gr_register_operand" "r")))]
  ""
  "shladd %0 = %1, %S2, %3"
  [(set_attr "itanium_class" "ialu")])

;; This can be created by register elimination if operand3 of shladd is an
;; eliminable register or has reg_equiv_constant set.

;; We have to use nonmemory_operand for operand 4, to ensure that the
;; validate_changes call inside eliminate_regs will always succeed.  If it
;; doesn't succeed, then this remain a shladd pattern, and will be reloaded
;; incorrectly.

(define_insn_and_split "*shladd_elim"
  [(set (match_operand:DI 0 "gr_register_operand" "=&r")
	(plus:DI (plus:DI (mult:DI (match_operand:DI 1 "gr_register_operand" "r")
				   (match_operand:DI 2 "shladd_operand" "n"))
			  (match_operand:DI 3 "nonmemory_operand" "r"))
		 (match_operand:DI 4 "nonmemory_operand" "rI")))]
  "reload_in_progress"
  "* abort ();"
  "reload_completed"
  [(set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (match_dup 2))
			       (match_dup 3)))
   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]
  ""
  [(set_attr "itanium_class" "unknown")])

(define_insn "ashrdi3"
  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
	(ashiftrt:DI (match_operand:DI 1 "gr_register_operand" "r,r")
		     (match_operand:DI 2 "gr_reg_or_6bit_operand" "r,rM")))]
  ""
  "@
   shr %0 = %1, %2
   shr %0 = %1, %2"
  [(set_attr "itanium_class" "mmshf,mmshfi")])

(define_insn "lshrdi3"
  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
	(lshiftrt:DI (match_operand:DI 1 "gr_register_operand" "r,r")
		     (match_operand:DI 2 "gr_reg_or_6bit_operand" "r,rM")))]
  ""
  "@
   shr.u %0 = %1, %2
   shr.u %0 = %1, %2"
  [(set_attr "itanium_class" "mmshf,mmshfi")])

;; Using a predicate that accepts only constants doesn't work, because optabs
;; will load the operand into a register and call the pattern if the predicate
;; did not accept it on the first try.  So we use nonmemory_operand and then
;; verify that we have an appropriate constant in the expander.

(define_expand "rotrdi3"
  [(set (match_operand:DI 0 "gr_register_operand" "")
	(rotatert:DI (match_operand:DI 1 "gr_register_operand" "")
		     (match_operand:DI 2 "nonmemory_operand" "")))]
  ""
  "
{
  if (! shift_count_operand (operands[2], DImode))
    FAIL;
}")

(define_insn "*rotrdi3_internal"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(rotatert:DI (match_operand:DI 1 "gr_register_operand" "r")
		     (match_operand:DI 2 "shift_count_operand" "M")))]
  ""
  "shrp %0 = %1, %1, %2"
  [(set_attr "itanium_class" "ishf")])

(define_expand "rotldi3"
  [(set (match_operand:DI 0 "gr_register_operand" "")
	(rotate:DI (match_operand:DI 1 "gr_register_operand" "")
		   (match_operand:DI 2 "nonmemory_operand" "")))]
  ""
  "
{
  if (! shift_count_operand (operands[2], DImode))
    FAIL;
}")

(define_insn "*rotldi3_internal"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(rotate:DI (match_operand:DI 1 "gr_register_operand" "r")
		   (match_operand:DI 2 "shift_count_operand" "M")))]
  ""
  "shrp %0 = %1, %1, %e2"
  [(set_attr "itanium_class" "ishf")])

;; ::::::::::::::::::::
;; ::
;; :: 32 bit Integer Logical operations
;; ::
;; ::::::::::::::::::::

;; We don't seem to need any other 32-bit logical operations, because gcc
;; generates zero-extend;zero-extend;DImode-op, which combine optimizes to
;; DImode-op;zero-extend, and then we can optimize away the zero-extend.
;; This doesn't work for unary logical operations, because we don't call
;; apply_distributive_law for them.

;; ??? Likewise, this doesn't work for andnot, which isn't handled by
;; apply_distributive_law.  We get inefficient code for
;; int sub4 (int i, int j) { return i & ~j; }
;; We could convert (and (not (sign_extend A)) (sign_extend B)) to
;; (zero_extend (and (not A) B)) in combine.
;; Or maybe fix this by adding andsi3/iorsi3/xorsi3 patterns like the
;; one_cmplsi2 pattern.

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(not:SI (match_operand:SI 1 "gr_register_operand" "r")))]
  ""
  "andcm %0 = -1, %1"
  [(set_attr "itanium_class" "ilog")])

;; ::::::::::::::::::::
;; ::
;; :: 64 bit Integer Logical operations
;; ::
;; ::::::::::::::::::::

(define_insn "anddi3"
  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
	(and:DI (match_operand:DI 1 "grfr_register_operand" "%r,*f")
		(match_operand:DI 2 "grfr_reg_or_8bit_operand" "rK,*f")))]
  ""
  "@
   and %0 = %2, %1
   fand %0 = %2, %1"
  [(set_attr "itanium_class" "ilog,fmisc")])

(define_insn "*andnot"
  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
	(and:DI (not:DI (match_operand:DI 1 "grfr_register_operand" "r,*f"))
		(match_operand:DI 2 "grfr_reg_or_8bit_operand" "rK,*f")))]
  ""
  "@
   andcm %0 = %2, %1
   fandcm %0 = %2, %1"
  [(set_attr "itanium_class" "ilog,fmisc")])

(define_insn "iordi3"
  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
	(ior:DI (match_operand:DI 1 "grfr_register_operand" "%r,*f")
		(match_operand:DI 2 "grfr_reg_or_8bit_operand" "rK,*f")))]
  ""
  "@
   or %0 = %2, %1
   for %0 = %2, %1"
  [(set_attr "itanium_class" "ilog,fmisc")])

(define_insn "xordi3"
  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
	(xor:DI (match_operand:DI 1 "grfr_register_operand" "%r,*f")
		(match_operand:DI 2 "grfr_reg_or_8bit_operand" "rK,*f")))]
  ""
  "@
   xor %0 = %2, %1
   fxor %0 = %2, %1"
  [(set_attr "itanium_class" "ilog,fmisc")])

(define_insn "one_cmpldi2"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(not:DI (match_operand:DI 1 "gr_register_operand" "r")))]
  ""
  "andcm %0 = -1, %1"
  [(set_attr "itanium_class" "ilog")])

;; ::::::::::::::::::::
;; ::
;; :: Comparisons
;; ::
;; ::::::::::::::::::::

(define_expand "cmpbi"
  [(set (cc0)
        (compare (match_operand:BI 0 "register_operand" "")
  		 (match_operand:BI 1 "const_int_operand" "")))]
  ""
  "
{
  ia64_compare_op0 = operands[0];
  ia64_compare_op1 = operands[1];
  DONE;
}")

(define_expand "cmpsi"
  [(set (cc0)
        (compare (match_operand:SI 0 "gr_register_operand" "")
  		 (match_operand:SI 1 "gr_reg_or_8bit_and_adjusted_operand" "")))]
  ""
  "
{
  ia64_compare_op0 = operands[0];
  ia64_compare_op1 = operands[1];
  DONE;
}")

(define_expand "cmpdi"
  [(set (cc0)
        (compare (match_operand:DI 0 "gr_register_operand" "")
  		 (match_operand:DI 1 "gr_reg_or_8bit_and_adjusted_operand" "")))]
  ""
  "
{
  ia64_compare_op0 = operands[0];
  ia64_compare_op1 = operands[1];
  DONE;
}")

(define_expand "cmpsf"
  [(set (cc0)
        (compare (match_operand:SF 0 "fr_reg_or_fp01_operand" "")
  		 (match_operand:SF 1 "fr_reg_or_fp01_operand" "")))]
  ""
  "
{
  ia64_compare_op0 = operands[0];
  ia64_compare_op1 = operands[1];
  DONE;
}")

(define_expand "cmpdf"
  [(set (cc0)
        (compare (match_operand:DF 0 "fr_reg_or_fp01_operand" "")
  		 (match_operand:DF 1 "fr_reg_or_fp01_operand" "")))]
  ""
  "
{
  ia64_compare_op0 = operands[0];
  ia64_compare_op1 = operands[1];
  DONE;
}")

(define_expand "cmptf"
  [(set (cc0)
        (compare (match_operand:TF 0 "tfreg_or_fp01_operand" "")
  		 (match_operand:TF 1 "tfreg_or_fp01_operand" "")))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "
{
  ia64_compare_op0 = operands[0];
  ia64_compare_op1 = operands[1];
  DONE;
}")

(define_insn "*cmpsi_normal"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(match_operator:BI 1 "normal_comparison_operator"
	   [(match_operand:SI 2 "gr_register_operand" "r")
	    (match_operand:SI 3 "gr_reg_or_8bit_operand" "rK")]))]
  ""
  "cmp4.%C1 %0, %I0 = %3, %2"
  [(set_attr "itanium_class" "icmp")])

;; We use %r3 because it is possible for us to match a 0, and two of the
;; unsigned comparisons don't accept immediate operands of zero.

(define_insn "*cmpsi_adjusted"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(match_operator:BI 1 "adjusted_comparison_operator"
	   [(match_operand:SI 2 "gr_register_operand" "r")
	    (match_operand:SI 3 "gr_reg_or_8bit_adjusted_operand" "rL")]))]
  ""
  "cmp4.%C1 %0, %I0 = %r3, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpdi_normal"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(match_operator:BI 1 "normal_comparison_operator"
	   [(match_operand:DI 2 "gr_reg_or_0_operand" "rO")
	    (match_operand:DI 3 "gr_reg_or_8bit_operand" "rK")]))]
  ""
  "cmp.%C1 %0, %I0 = %3, %r2"
  [(set_attr "itanium_class" "icmp")])

;; We use %r3 because it is possible for us to match a 0, and two of the
;; unsigned comparisons don't accept immediate operands of zero.

(define_insn "*cmpdi_adjusted"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(match_operator:BI 1 "adjusted_comparison_operator"
	   [(match_operand:DI 2 "gr_register_operand" "r")
	    (match_operand:DI 3 "gr_reg_or_8bit_adjusted_operand" "rL")]))]
  ""
  "cmp.%C1 %0, %I0 = %r3, %2"
  [(set_attr "itanium_class" "icmp")])

(define_insn "*cmpsf_internal"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(match_operator:BI 1 "comparison_operator"
	   [(match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")
	    (match_operand:SF 3 "fr_reg_or_fp01_operand" "fG")]))]
  ""
  "fcmp.%D1 %0, %I0 = %F2, %F3"
  [(set_attr "itanium_class" "fcmp")])

(define_insn "*cmpdf_internal"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(match_operator:BI 1 "comparison_operator"
	   [(match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")
	    (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")]))]
  ""
  "fcmp.%D1 %0, %I0 = %F2, %F3"
  [(set_attr "itanium_class" "fcmp")])

(define_insn "*cmptf_internal"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(match_operator:BI 1 "comparison_operator"
		   [(match_operand:TF 2 "tfreg_or_fp01_operand" "fG")
		    (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")]))]
  "INTEL_EXTENDED_IEEE_FORMAT"
  "fcmp.%D1 %0, %I0 = %F2, %F3"
  [(set_attr "itanium_class" "fcmp")])

;; ??? Can this pattern be generated?

(define_insn "*bit_zero"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(eq:BI (zero_extract:DI (match_operand:DI 1 "gr_register_operand" "r")
				(const_int 1)
				(match_operand:DI 2 "immediate_operand" "n"))
	       (const_int 0)))]
  ""
  "tbit.z %0, %I0 = %1, %2"
  [(set_attr "itanium_class" "tbit")])

(define_insn "*bit_one"
  [(set (match_operand:BI 0 "register_operand" "=c")
	(ne:BI (zero_extract:DI (match_operand:DI 1 "gr_register_operand" "r")
				(const_int 1)
				(match_operand:DI 2 "immediate_operand" "n"))
	       (const_int 0)))]
  ""
  "tbit.nz %0, %I0 = %1, %2"
  [(set_attr "itanium_class" "tbit")])

;; ::::::::::::::::::::
;; ::
;; :: Branches
;; ::
;; ::::::::::::::::::::

(define_expand "beq"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (EQ, VOIDmode);")

(define_expand "bne"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (NE, VOIDmode);")

(define_expand "blt"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (LT, VOIDmode);")

(define_expand "ble"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (LE, VOIDmode);")

(define_expand "bgt"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (GT, VOIDmode);")

(define_expand "bge"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (GE, VOIDmode);")

(define_expand "bltu"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (LTU, VOIDmode);")

(define_expand "bleu"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (LEU, VOIDmode);")

(define_expand "bgtu"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (GTU, VOIDmode);")

(define_expand "bgeu"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (GEU, VOIDmode);")

(define_expand "bunordered"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (UNORDERED, VOIDmode);")

(define_expand "bordered"
  [(set (pc)
	(if_then_else (match_dup 1)
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "operands[1] = ia64_expand_compare (ORDERED, VOIDmode);")

(define_insn "*br_true"
  [(set (pc)
	(if_then_else (match_operator 0 "predicate_operator"
			[(match_operand:BI 1 "register_operand" "c")
			 (const_int 0)])
		      (label_ref (match_operand 2 "" ""))
		      (pc)))]
  ""
  "(%J0) br.cond%+ %l2"
  [(set_attr "itanium_class" "br")
   (set_attr "predicable" "no")])

(define_insn "*br_false"
  [(set (pc)
	(if_then_else (match_operator 0 "predicate_operator"
			[(match_operand:BI 1 "register_operand" "c")
			 (const_int 0)])
		      (pc)
		      (label_ref (match_operand 2 "" ""))))]
  ""
  "(%j0) br.cond%+ %l2"
  [(set_attr "itanium_class" "br")
   (set_attr "predicable" "no")])

;; ::::::::::::::::::::
;; ::
;; :: Counted loop operations
;; ::
;; ::::::::::::::::::::

(define_expand "doloop_end"
  [(use (match_operand 0 "" ""))	; loop pseudo
   (use (match_operand 1 "" ""))	; iterations; zero if unknown
   (use (match_operand 2 "" ""))	; max iterations
   (use (match_operand 3 "" ""))	; loop level
   (use (match_operand 4 "" ""))]	; label
  ""
  "
{
  /* Only use cloop on innermost loops.  */
  if (INTVAL (operands[3]) > 1)
    FAIL;
  emit_jump_insn (gen_doloop_end_internal (gen_rtx_REG (DImode, AR_LC_REGNUM),
					   operands[4]));
  DONE;
}")

(define_insn "doloop_end_internal"
  [(set (pc) (if_then_else (ne (match_operand:DI 0 "ar_lc_reg_operand" "")
			       (const_int 0))
		(label_ref (match_operand 1 "" ""))
		(pc)))
   (set (match_dup 0) (if_then_else:DI (ne (match_dup 0) (const_int 0))
			 (match_dup 0)
			 (plus:DI (match_dup 0) (const_int -1))))]
  ""
  "br.cloop.sptk.few %l1"
  [(set_attr "itanium_class" "br")
   (set_attr "predicable" "no")])

;; ::::::::::::::::::::
;; ::
;; :: Set flag operations
;; ::
;; ::::::::::::::::::::

(define_expand "seq"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (EQ, DImode);")

(define_expand "sne"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (NE, DImode);")

(define_expand "slt"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (LT, DImode);")

(define_expand "sle"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (LE, DImode);")

(define_expand "sgt"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (GT, DImode);")

(define_expand "sge"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (GE, DImode);")

(define_expand "sltu"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (LTU, DImode);")

(define_expand "sleu"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (LEU, DImode);")

(define_expand "sgtu"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (GTU, DImode);")

(define_expand "sgeu"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (GEU, DImode);")

(define_expand "sunordered"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (UNORDERED, DImode);")

(define_expand "sordered"
  [(set (match_operand:DI 0 "gr_register_operand" "") (match_dup 1))]
  ""
  "operands[1] = ia64_expand_compare (ORDERED, DImode);")

;; Don't allow memory as destination here, because cmov/cmov/st is more
;; efficient than mov/mov/cst/cst.

(define_insn_and_split "*sne_internal"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(ne:DI (match_operand:BI 1 "register_operand" "c")
	       (const_int 0)))]
  ""
  "#"
  "reload_completed"
  [(cond_exec (ne (match_dup 1) (const_int 0))
     (set (match_dup 0) (const_int 1)))
   (cond_exec (eq (match_dup 1) (const_int 0))
     (set (match_dup 0) (const_int 0)))]
  ""
  [(set_attr "itanium_class" "unknown")])

(define_insn_and_split "*seq_internal"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(eq:DI (match_operand:BI 1 "register_operand" "c")
	       (const_int 0)))]
  ""
  "#"
  "reload_completed"
  [(cond_exec (ne (match_dup 1) (const_int 0))
     (set (match_dup 0) (const_int 0)))
   (cond_exec (eq (match_dup 1) (const_int 0))
     (set (match_dup 0) (const_int 1)))]
  ""
  [(set_attr "itanium_class" "unknown")])

;; ::::::::::::::::::::
;; ::
;; :: Conditional move instructions.
;; ::
;; ::::::::::::::::::::

;; ??? Add movXXcc patterns?

;;
;; DImode if_then_else patterns.
;;

(define_insn "*cmovdi_internal"
  [(set (match_operand:DI 0 "destination_operand"
	   "= r,  r,  r,   r,  r,  r,   r, r, r,   r, m, Q, *f,*b,*d*e")
	(if_then_else:DI
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand"
		"c,c,c,c,c,c,c,c,c,c,c,c,c,c,c")
	     (const_int 0)])
	  (match_operand:DI 2 "move_operand"
	   "rim, *f, *b,*d*e,rim,rim, rim,*f,*b,*d*e,rO,*f,rOQ,rO,  rK")
	  (match_operand:DI 3 "move_operand"
	   "rim,rim,rim, rim, *f, *b,*d*e,*f,*b,*d*e,rO,*f,rOQ,rO,  rK")))]
  "ia64_move_ok (operands[0], operands[2])
   && ia64_move_ok (operands[0], operands[3])"
  "* abort ();"
  [(set_attr "predicable" "no")])

(define_split
  [(set (match_operand 0 "destination_operand" "")
	(if_then_else
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand" "")
	     (const_int 0)])
	  (match_operand 2 "move_operand" "")
	  (match_operand 3 "move_operand" "")))]
  "reload_completed"
  [(const_int 0)]
  "
{
  rtx tmp;
  if (! rtx_equal_p (operands[0], operands[2]))
    {
      tmp = gen_rtx_SET (VOIDmode, operands[0], operands[2]);
      tmp = gen_rtx_COND_EXEC (VOIDmode, operands[4], tmp);
      emit_insn (tmp);
    }
  if (! rtx_equal_p (operands[0], operands[3]))
    {
      tmp = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,
			    VOIDmode, operands[1], const0_rtx);
      tmp = gen_rtx_COND_EXEC (VOIDmode, tmp,
			       gen_rtx_SET (VOIDmode, operands[0],
					    operands[3]));
      emit_insn (tmp);
    }
  DONE;
}")

;; Absolute value pattern.

(define_insn "*absdi2_internal"
  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
	(if_then_else:DI
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand" "c,c")
	     (const_int 0)])
	  (neg:DI (match_operand:DI 2 "gr_reg_or_22bit_operand" "rI,rI"))
	  (match_operand:DI 3 "gr_reg_or_22bit_operand" "0,rI")))]
  ""
  "#"
  [(set_attr "itanium_class" "ialu,unknown")
   (set_attr "predicable" "no")])

(define_split
  [(set (match_operand:DI 0 "register_operand" "")
	(if_then_else:DI
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand" "c,c")
	     (const_int 0)])
	  (neg:DI (match_operand:DI 2 "gr_reg_or_22bit_operand" ""))
	  (match_operand:DI 3 "gr_reg_or_22bit_operand" "")))]
  "reload_completed && rtx_equal_p (operands[0], operands[3])"
  [(cond_exec
     (match_dup 4)
     (set (match_dup 0)
	  (neg:DI (match_dup 2))))]
  "")

(define_split
  [(set (match_operand:DI 0 "register_operand" "")
	(if_then_else:DI
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand" "c,c")
	     (const_int 0)])
	  (neg:DI (match_operand:DI 2 "gr_reg_or_22bit_operand" ""))
	  (match_operand:DI 3 "gr_reg_or_22bit_operand" "")))]
  "reload_completed"
  [(cond_exec
     (match_dup 4)
     (set (match_dup 0) (neg:DI (match_dup 2))))
   (cond_exec
     (match_dup 5)
     (set (match_dup 0) (match_dup 3)))]
  "
{
  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,
				VOIDmode, operands[1], const0_rtx);
}")

;;
;; SImode if_then_else patterns.
;;

(define_insn "*cmovsi_internal"
  [(set (match_operand:SI 0 "destination_operand" "=r,m,*f,r,m,*f,r,m,*f")
	(if_then_else:SI
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand" "c,c,c,c,c,c,c,c,c")
	     (const_int 0)])
	  (match_operand:SI 2 "move_operand"
		    "0,0,0,rim*f,rO,rO,rim*f,rO,rO")
	  (match_operand:SI 3 "move_operand"
		    "rim*f,rO,rO,0,0,0,rim*f,rO,rO")))]
  "ia64_move_ok (operands[0], operands[2])
   && ia64_move_ok (operands[0], operands[3])"
  "* abort ();"
  [(set_attr "predicable" "no")])

(define_insn "*abssi2_internal"
  [(set (match_operand:SI 0 "gr_register_operand" "=r,r")
	(if_then_else:SI
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand" "c,c")
	     (const_int 0)])
	  (neg:SI (match_operand:SI 3 "gr_reg_or_22bit_operand" "rI,rI"))
	  (match_operand:SI 2 "gr_reg_or_22bit_operand" "0,rI")))]
  ""
  "#"
  [(set_attr "itanium_class" "ialu,unknown")
   (set_attr "predicable" "no")])

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
	(if_then_else:SI
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand" "c,c")
	     (const_int 0)])
	  (neg:SI (match_operand:SI 2 "gr_reg_or_22bit_operand" ""))
	  (match_operand:SI 3 "gr_reg_or_22bit_operand" "")))]
  "reload_completed && rtx_equal_p (operands[0], operands[3])"
  [(cond_exec
     (match_dup 4)
     (set (match_dup 0)
	  (neg:SI (match_dup 2))))]
  "")

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
	(if_then_else:SI
	  (match_operator 4 "predicate_operator"
	    [(match_operand:BI 1 "register_operand" "c,c")
	     (const_int 0)])
	  (neg:SI (match_operand:SI 2 "gr_reg_or_22bit_operand" ""))
	  (match_operand:SI 3 "gr_reg_or_22bit_operand" "")))]
  "reload_completed"
  [(cond_exec
     (match_dup 4)
     (set (match_dup 0) (neg:SI (match_dup 2))))
   (cond_exec
     (match_dup 5)
     (set (match_dup 0) (match_dup 3)))]
  "
{
  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,
				VOIDmode, operands[1], const0_rtx);
}")

(define_insn_and_split "*cond_opsi2_internal"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(match_operator:SI 5 "condop_operator"
	  [(if_then_else:SI
	     (match_operator 6 "predicate_operator"
	       [(match_operand:BI 1 "register_operand" "c")
	        (const_int 0)])
	     (match_operand:SI 2 "gr_register_operand" "r")
	     (match_operand:SI 3 "gr_register_operand" "r"))
	   (match_operand:SI 4 "gr_register_operand" "r")]))]
  ""
  "#"
  "reload_completed"
  [(cond_exec
     (match_dup 6)
     (set (match_dup 0) (match_op_dup:SI 5 [(match_dup 2) (match_dup 4)])))
   (cond_exec
     (match_dup 7)
     (set (match_dup 0) (match_op_dup:SI 5 [(match_dup 3) (match_dup 4)])))]
  "
{
  operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[6]) == NE ? EQ : NE,
				VOIDmode, operands[1], const0_rtx);
}"
  [(set_attr "itanium_class" "ialu")
   (set_attr "predicable" "no")])


(define_insn_and_split "*cond_opsi2_internal_b"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(match_operator:SI 5 "condop_operator"
	  [(match_operand:SI 4 "gr_register_operand" "r")
	   (if_then_else:SI
	     (match_operator 6 "predicate_operator"
	       [(match_operand:BI 1 "register_operand" "c")
	        (const_int 0)])
	     (match_operand:SI 2 "gr_register_operand" "r")
	     (match_operand:SI 3 "gr_register_operand" "r"))]))]
  ""
  "#"
  "reload_completed"
  [(cond_exec
     (match_dup 6)
     (set (match_dup 0) (match_op_dup:SI 5 [(match_dup 4) (match_dup 2)])))
   (cond_exec
     (match_dup 7)
     (set (match_dup 0) (match_op_dup:SI 5 [(match_dup 4) (match_dup 3)])))]
  "
{
  operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[6]) == NE ? EQ : NE,
				VOIDmode, operands[1], const0_rtx);
}"
  [(set_attr "itanium_class" "ialu")
   (set_attr "predicable" "no")])


;; ::::::::::::::::::::
;; ::
;; :: Call and branch instructions
;; ::
;; ::::::::::::::::::::

;; Subroutine call instruction returning no value.  Operand 0 is the function
;; to call; operand 1 is the number of bytes of arguments pushed (in mode
;; `SImode', except it is normally a `const_int'); operand 2 is the number of
;; registers used as operands.

;; On most machines, operand 2 is not actually stored into the RTL pattern.  It
;; is supplied for the sake of some RISC machines which need to put this
;; information into the assembler code; they can put it in the RTL instead of
;; operand 1.

(define_expand "call"
  [(use (match_operand:DI 0 "" ""))
   (use (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))]
  ""
  "
{
  ia64_expand_call (NULL_RTX, operands[0], operands[2], 0);
  DONE;
}")

(define_expand "sibcall"
  [(use (match_operand:DI 0 "" ""))
   (use (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))]
  ""
  "
{
  ia64_expand_call (NULL_RTX, operands[0], operands[2], 1);
  DONE;
}")

;; Subroutine call instruction returning a value.  Operand 0 is the hard
;; register in which the value is returned.  There are three more operands,
;; the same as the three operands of the `call' instruction (but with numbers
;; increased by one).
;;
;; Subroutines that return `BLKmode' objects use the `call' insn.

(define_expand "call_value"
  [(use (match_operand 0 "" ""))
   (use (match_operand:DI 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))
   (use (match_operand 4 "" ""))]
  ""
  "
{
  ia64_expand_call (operands[0], operands[1], operands[3], 0);
  DONE;
}")

(define_expand "sibcall_value"
  [(use (match_operand 0 "" ""))
   (use (match_operand:DI 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))
   (use (match_operand 4 "" ""))]
  ""
  "
{
  ia64_expand_call (operands[0], operands[1], operands[3], 1);
  DONE;
}")

;; Call subroutine returning any type.

(define_expand "untyped_call"
  [(parallel [(call (match_operand 0 "" "")
		    (const_int 0))
	      (match_operand 1 "" "")
	      (match_operand 2 "" "")])]
  ""
  "
{
  int i;

  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));

  for (i = 0; i < XVECLEN (operands[2], 0); i++)
    {
      rtx set = XVECEXP (operands[2], 0, i);
      emit_move_insn (SET_DEST (set), SET_SRC (set));
    }

  /* The optimizer does not know that the call sets the function value
     registers we stored in the result block.  We avoid problems by
     claiming that all hard registers are used and clobbered at this
     point.  */
  emit_insn (gen_blockage ());

  DONE;
}")

(define_insn "call_nopic"
  [(call (mem:DI (match_operand:DI 0 "call_operand" "b,i"))
	 (match_operand 1 "" ""))
   (clobber (match_operand:DI 2 "register_operand" "=b,b"))]
  ""
  "br.call%+.many %2 = %0"
  [(set_attr "itanium_class" "br,scall")])

(define_insn "call_value_nopic"
  [(set (match_operand 0 "" "")
	(call (mem:DI (match_operand:DI 1 "call_operand" "b,i"))
	      (match_operand 2 "" "")))
   (clobber (match_operand:DI 3 "register_operand" "=b,b"))]
  ""
  "br.call%+.many %3 = %1"
  [(set_attr "itanium_class" "br,scall")])

(define_insn "sibcall_nopic"
  [(call (mem:DI (match_operand:DI 0 "call_operand" "b,i"))
	 (match_operand 1 "" ""))
   (use (match_operand:DI 2 "register_operand" "=b,b"))
   (use (match_operand:DI 3 "ar_pfs_reg_operand" ""))]
  ""
  "br%+.many %0"
  [(set_attr "itanium_class" "br,scall")])

(define_insn "call_pic"
  [(call (mem:DI (match_operand:DI 0 "call_operand" "b,i"))
	 (match_operand 1 "" ""))
   (use (unspec [(reg:DI 1)] 9))
   (clobber (match_operand:DI 2 "register_operand" "=b,b"))]
  ""
  "br.call%+.many %2 = %0"
  [(set_attr "itanium_class" "br,scall")])

(define_insn "call_value_pic"
  [(set (match_operand 0 "" "")
	(call (mem:DI (match_operand:DI 1 "call_operand" "b,i"))
	      (match_operand 2 "" "")))
   (use (unspec [(reg:DI 1)] 9))
   (clobber (match_operand:DI 3 "register_operand" "=b,b"))]
  ""
  "br.call%+.many %3 = %1"
  [(set_attr "itanium_class" "br,scall")])

(define_insn "sibcall_pic"
  [(call (mem:DI (match_operand:DI 0 "call_operand" "bi"))
	 (match_operand 1 "" ""))
   (use (unspec [(reg:DI 1)] 9))
   (use (match_operand:DI 2 "register_operand" "=b"))
   (use (match_operand:DI 3 "ar_pfs_reg_operand" ""))]
  ""
  "br%+.many %0"
  [(set_attr "itanium_class" "br")])

(define_insn "return_internal"
  [(return)
   (use (match_operand:DI 0 "register_operand" "b"))]
  ""
  "br.ret.sptk.many %0"
  [(set_attr "itanium_class" "br")])

(define_insn "return"
  [(return)]
  "ia64_direct_return ()"
  "br.ret.sptk.many rp"
  [(set_attr "itanium_class" "br")])

(define_insn "*return_true"
  [(set (pc)
	(if_then_else (match_operator 0 "predicate_operator"
			[(match_operand:BI 1 "register_operand" "c")
			 (const_int 0)])
		      (return)
		      (pc)))]
  "ia64_direct_return ()"
  "(%J0) br.ret%+.many rp"
  [(set_attr "itanium_class" "br")
   (set_attr "predicable" "no")])

(define_insn "*return_false"
  [(set (pc)
	(if_then_else (match_operator 0 "predicate_operator"
			[(match_operand:BI 1 "register_operand" "c")
			 (const_int 0)])
		      (pc)
		      (return)))]
  "ia64_direct_return ()"
  "(%j0) br.ret%+.many rp"
  [(set_attr "itanium_class" "br")
   (set_attr "predicable" "no")])

(define_insn "jump"
  [(set (pc) (label_ref (match_operand 0 "" "")))]
  ""
  "br %l0"
  [(set_attr "itanium_class" "br")])

(define_insn "indirect_jump"
  [(set (pc) (match_operand:DI 0 "register_operand" "b"))]
  ""
  "br %0"
  [(set_attr "itanium_class" "br")])

(define_expand "tablejump"
  [(parallel [(set (pc) (match_operand:DI 0 "memory_operand" ""))
	      (use (label_ref (match_operand 1 "" "")))])]
  ""
{
  rtx op0 = operands[0];
  rtx addr;

  /* ??? Bother -- do_tablejump is "helpful" and pulls the table
     element into a register without bothering to see whether that
     is necessary given the operand predicate.  Check for MEM just
     in case someone fixes this.  */
  if (GET_CODE (op0) == MEM)
    addr = XEXP (op0, 0);
  else
    {
      /* Otherwise, cheat and guess that the previous insn in the
	 stream was the memory load.  Grab the address from that.
	 Note we have to momentarily pop out of the sequence started
	 by the insn-emit wrapper in order to grab the last insn.  */
      rtx last, set;

      end_sequence ();
      last = get_last_insn ();
      start_sequence ();
      set = single_set (last);

      if (! rtx_equal_p (SET_DEST (set), op0)
	  || GET_CODE (SET_SRC (set)) != MEM)
	abort ();
      addr = XEXP (SET_SRC (set), 0);
      if (rtx_equal_p (addr, op0))
	abort ();
    }

  /* Jump table elements are stored pc-relative.  That is, a displacement
     from the entry to the label.  Thus to convert to an absolute address
     we add the address of the memory from which the value is loaded.  */
  operands[0] = expand_simple_binop (DImode, PLUS, op0, addr,
				     NULL_RTX, 1, OPTAB_DIRECT);
})

(define_insn "*tablejump_internal"
  [(set (pc) (match_operand:DI 0 "register_operand" "b"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  "br %0"
  [(set_attr "itanium_class" "br")])


;; ::::::::::::::::::::
;; ::
;; :: Prologue and Epilogue instructions
;; ::
;; ::::::::::::::::::::

(define_expand "prologue"
  [(const_int 1)]
  ""
  "
{
  ia64_expand_prologue ();
  DONE;
}")

(define_expand "epilogue"
  [(return)]
  ""
  "
{
  ia64_expand_epilogue (0);
  DONE;
}")

(define_expand "sibcall_epilogue"
  [(return)]
  ""
  "
{
  ia64_expand_epilogue (1);
  DONE;
}")

;; This prevents the scheduler from moving the SP decrement past FP-relative
;; stack accesses.  This is the same as adddi3 plus the extra set.

(define_insn "prologue_allocate_stack"
  [(set (match_operand:DI 0 "register_operand" "=r,r,r")
	(plus:DI (match_operand:DI 1 "register_operand" "%r,r,a")
		 (match_operand:DI 2 "gr_reg_or_22bit_operand" "r,I,J")))
   (set (match_operand:DI 3 "register_operand" "+r,r,r")
	(match_dup 3))]
  ""
  "@
  add %0 = %1, %2
  adds %0 = %2, %1
  addl %0 = %2, %1"
  [(set_attr "itanium_class" "ialu")])

;; This prevents the scheduler from moving the SP restore past FP-relative
;; stack accesses.  This is similar to movdi plus the extra set.

(define_insn "epilogue_deallocate_stack"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(match_operand:DI 1 "register_operand" "+r"))
   (set (match_dup 1) (match_dup 1))]
  ""
  "mov %0 = %1"
  [(set_attr "itanium_class" "ialu")])

;; Allocate a new register frame.

(define_insn "alloc"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(unspec_volatile:DI [(const_int 0)] 0))
   (use (match_operand:DI 1 "const_int_operand" "i"))
   (use (match_operand:DI 2 "const_int_operand" "i"))
   (use (match_operand:DI 3 "const_int_operand" "i"))
   (use (match_operand:DI 4 "const_int_operand" "i"))]
  ""
  "alloc %0 = ar.pfs, %1, %2, %3, %4"
  [(set_attr "itanium_class" "syst_m0")
   (set_attr "predicable" "no")])

;; Modifies ar.unat
(define_expand "gr_spill"
  [(parallel [(set (match_operand:DI 0 "memory_operand" "=m")
		   (unspec:DI [(match_operand:DI 1 "register_operand" "r")
			       (match_operand:DI 2 "const_int_operand" "")] 1))
	      (clobber (match_dup 3))])]
  ""
  "operands[3] = gen_rtx_REG (DImode, AR_UNAT_REGNUM);")

(define_insn "gr_spill_internal"
  [(set (match_operand:DI 0 "memory_operand" "=m")
	(unspec:DI [(match_operand:DI 1 "register_operand" "r")
		    (match_operand:DI 2 "const_int_operand" "")] 1))
   (clobber (match_operand:DI 3 "register_operand" ""))]
  ""
  "*
{
  return \".mem.offset %2, 0\;%,st8.spill %0 = %1%P0\";
}"
  [(set_attr "itanium_class" "st")])

;; Reads ar.unat
(define_expand "gr_restore"
  [(parallel [(set (match_operand:DI 0 "register_operand" "=r")
		   (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
			       (match_operand:DI 2 "const_int_operand" "")] 2))
	      (use (match_dup 3))])]
  ""
  "operands[3] = gen_rtx_REG (DImode, AR_UNAT_REGNUM);")

(define_insn "gr_restore_internal"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(unspec:DI [(match_operand:DI 1 "memory_operand" "m")
		    (match_operand:DI 2 "const_int_operand" "")] 2))
   (use (match_operand:DI 3 "register_operand" ""))]
  ""
  "*
{
  return \".mem.offset %2, 0\;%,ld8.fill %0 = %1%P1\";
}"
  [(set_attr "itanium_class" "ld")])

(define_insn "fr_spill"
  [(set (match_operand:TF 0 "memory_operand" "=m")
	(unspec:TF [(match_operand:TF 1 "register_operand" "f")] 3))]
  ""
  "stf.spill %0 = %1%P0"
  [(set_attr "itanium_class" "stf")])

(define_insn "fr_restore"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(unspec:TF [(match_operand:TF 1 "memory_operand" "m")] 4))]
  ""
  "ldf.fill %0 = %1%P1"
  [(set_attr "itanium_class" "fld")])

;; ??? The explicit stop is not ideal.  It would be better if
;; rtx_needs_barrier took care of this, but this is something that can be
;; fixed later.  This avoids an RSE DV.

(define_insn "bsp_value"
  [(set (match_operand:DI 0 "register_operand" "=r")
	(unspec:DI [(const_int 0)] 20))]
  ""
  ";;\;mov %0 = ar.bsp"
  [(set_attr "itanium_class" "frar_i")])

(define_insn "set_bsp"
  [(unspec_volatile [(match_operand:DI 0 "register_operand" "r")] 5)]
  ""
  "flushrs\;mov r19=ar.rsc\;;;\;and r19=0x1c,r19\;;;\;mov ar.rsc=r19\;;;\;mov ar.bspstore=%0\;;;\;or r19=0x3,r19\;;;\;loadrs\;invala\;;;\;mov ar.rsc=r19"
  [(set_attr "itanium_class" "unknown")
   (set_attr "predicable" "no")])

;; ??? The explicit stops are not ideal.  It would be better if
;; rtx_needs_barrier took care of this, but this is something that can be
;; fixed later.  This avoids an RSE DV.

(define_insn "flushrs"
  [(unspec [(const_int 0)] 21)]
  ""
  ";;\;flushrs\;;;"
  [(set_attr "itanium_class" "rse_m")])

;; ::::::::::::::::::::
;; ::
;; :: Miscellaneous instructions
;; ::
;; ::::::::::::::::::::

;; ??? Emiting a NOP instruction isn't very useful.  This should probably
;; be emitting ";;" to force a break in the instruction packing.

;; No operation, needed in case the user uses -g but not -O.
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop 0"
  [(set_attr "itanium_class" "nop")])

(define_insn "nop_m"
  [(const_int 1)]
  ""
  "nop.m 0"
  [(set_attr "itanium_class" "nop_m")])

(define_insn "nop_i"
  [(const_int 2)]
  ""
  "nop.i 0"
  [(set_attr "itanium_class" "nop_i")])

(define_insn "nop_f"
  [(const_int 3)]
  ""
  "nop.f 0"
  [(set_attr "itanium_class" "nop_f")])

(define_insn "nop_b"
  [(const_int 4)]
  ""
  "nop.b 0"
  [(set_attr "itanium_class" "nop_b")])

(define_insn "nop_x"
  [(const_int 5)]
  ""
  ""
  [(set_attr "itanium_class" "nop_x")])

;; The following insn will be never generated.  It is used only by
;; insn scheduler to change state before advancing cycle.
(define_insn "pre_cycle"
  [(const_int 6)]
  ""
  ""
  [(set_attr "itanium_class" "pre_cycle")])
 
(define_insn "bundle_selector"
  [(unspec [(match_operand 0 "const_int_operand" "")] 22)]
  ""
  "*
{
  return get_bundle_name (INTVAL (operands[0]));
}"
  [(set_attr "itanium_class" "ignore")
   (set_attr "predicable" "no")])

;; Pseudo instruction that prevents the scheduler from moving code above this
;; point.
(define_insn "blockage"
  [(unspec_volatile [(const_int 0)] 1)]
  ""
  ""
  [(set_attr "itanium_class" "ignore")
   (set_attr "predicable" "no")])

(define_insn "insn_group_barrier"
  [(unspec_volatile [(match_operand 0 "const_int_operand" "")] 2)]
  ""
  ";;"
  [(set_attr "itanium_class" "stop_bit")
   (set_attr "predicable" "no")])

(define_expand "trap"
  [(trap_if (const_int 1) (const_int 0))]
  ""
  "")

;; ??? We don't have a match-any slot type.  Setting the type to unknown
;; produces worse code that setting the slot type to A.

(define_insn "*trap"
  [(trap_if (const_int 1) (match_operand 0 "const_int_operand" ""))]
  ""
  "break %0"
  [(set_attr "itanium_class" "chk_s")])

(define_expand "conditional_trap"
  [(trap_if (match_operand 0 "" "") (match_operand 1 "" ""))]
  ""
{
  operands[0] = ia64_expand_compare (GET_CODE (operands[0]), VOIDmode);
})

(define_insn "*conditional_trap"
  [(trap_if (match_operator 0 "predicate_operator"
	      [(match_operand:BI 1 "register_operand" "c")
	       (const_int 0)])  
	    (match_operand 2 "const_int_operand" ""))]
  ""
  "(%J0) break %2"
  [(set_attr "itanium_class" "chk_s")
   (set_attr "predicable" "no")])

(define_insn "break_f"
  [(unspec_volatile [(const_int 0)] 3)]
  ""
  "break.f 0"
  [(set_attr "itanium_class" "nop_f")])

(define_insn "prefetch"
  [(prefetch (match_operand:DI 0 "address_operand" "p")
	     (match_operand:DI 1 "const_int_operand" "n")
	     (match_operand:DI 2 "const_int_operand" "n"))]
  ""
{
  static const char * const alt[2][4] = {
    {
      "lfetch.nta [%0]",
      "lfetch.nt1 [%0]",
      "lfetch.nt2 [%0]",
      "lfetch [%0]"
    },
    {
      "lfetch.excl.nta [%0]",
      "lfetch.excl.nt1 [%0]",
      "lfetch.excl.nt2 [%0]",
      "lfetch.excl [%0]"
    }
  };
  int i = (INTVAL (operands[1]));
  int j = (INTVAL (operands[2]));

  if (i != 0 && i != 1)
    abort ();
  if (j < 0 || j > 3)
    abort ();
  return alt[i][j];
}
  [(set_attr "itanium_class" "lfetch")])

;; Non-local goto support.

(define_expand "save_stack_nonlocal"
  [(use (match_operand:OI 0 "memory_operand" ""))
   (use (match_operand:DI 1 "register_operand" ""))]
  ""
  "
{
  emit_library_call (gen_rtx_SYMBOL_REF (Pmode,
					 \"__ia64_save_stack_nonlocal\"),
		     0, VOIDmode, 2, XEXP (operands[0], 0), Pmode,
		     operands[1], Pmode);
  DONE;
}")

(define_expand "nonlocal_goto"
  [(use (match_operand 0 "general_operand" ""))
   (use (match_operand 1 "general_operand" ""))
   (use (match_operand 2 "general_operand" ""))
   (use (match_operand 3 "general_operand" ""))]
  ""
  "
{
  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__ia64_nonlocal_goto\"),
		     LCT_NORETURN, VOIDmode, 3,
		     operands[1], Pmode,
		     copy_to_reg (XEXP (operands[2], 0)), Pmode,
		     operands[3], Pmode);
  emit_barrier ();
  DONE;
}")

;; The rest of the setjmp processing happens with the nonlocal_goto expander.
;; ??? This is not tested.
(define_expand "builtin_setjmp_setup"
  [(use (match_operand:DI 0 "" ""))]
  ""
  "
{
  emit_move_insn (ia64_gp_save_reg (0), gen_rtx_REG (DImode, GR_REG (1)));
  DONE;
}")

(define_expand "builtin_setjmp_receiver"
  [(use (match_operand:DI 0 "" ""))]
  ""
  "
{
  emit_move_insn (gen_rtx_REG (DImode, GR_REG (1)), ia64_gp_save_reg (0));
  DONE;
}")

(define_expand "eh_epilogue"
  [(use (match_operand:DI 0 "register_operand" "r"))
   (use (match_operand:DI 1 "register_operand" "r"))
   (use (match_operand:DI 2 "register_operand" "r"))]
  ""
  "
{
  rtx bsp = gen_rtx_REG (Pmode, 10);
  rtx sp = gen_rtx_REG (Pmode, 9);

  if (GET_CODE (operands[0]) != REG || REGNO (operands[0]) != 10)
    {
      emit_move_insn (bsp, operands[0]);
      operands[0] = bsp;
    }
  if (GET_CODE (operands[2]) != REG || REGNO (operands[2]) != 9)
    {
      emit_move_insn (sp, operands[2]);
      operands[2] = sp;
    }
  emit_insn (gen_rtx_USE (VOIDmode, sp));
  emit_insn (gen_rtx_USE (VOIDmode, bsp));

  cfun->machine->ia64_eh_epilogue_sp = sp;
  cfun->machine->ia64_eh_epilogue_bsp = bsp;
}")

;; Builtin apply support.

(define_expand "restore_stack_nonlocal"
  [(use (match_operand:DI 0 "register_operand" ""))
   (use (match_operand:OI 1 "memory_operand" ""))]
  ""
  "
{
  emit_library_call (gen_rtx_SYMBOL_REF (Pmode,
					 \"__ia64_restore_stack_nonlocal\"),
		     0, VOIDmode, 1,
		     copy_to_reg (XEXP (operands[1], 0)), Pmode);
  DONE;
}")


;;; Intrinsics support.

(define_expand "mf"
  [(set (mem:BLK (match_dup 0))
	(unspec:BLK [(mem:BLK (match_dup 0))] 12))]
  ""
  "
{
  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));
  MEM_VOLATILE_P (operands[0]) = 1;
}")

(define_insn "*mf_internal"
  [(set (match_operand:BLK 0 "" "")
	(unspec:BLK [(match_operand:BLK 1 "" "")] 12))]
  ""
  "mf"
  [(set_attr "itanium_class" "syst_m")])

(define_insn "fetchadd_acq_si"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(match_dup 1))
   (set (match_operand:SI 1 "not_postinc_memory_operand" "+S")
	(unspec:SI [(match_dup 1)
		    (match_operand:SI 2 "fetchadd_operand" "n")] 19))]
  ""
  "fetchadd4.acq %0 = %1, %2"
  [(set_attr "itanium_class" "sem")])

(define_insn "fetchadd_acq_di"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(match_dup 1))
   (set (match_operand:DI 1 "not_postinc_memory_operand" "+S")
	(unspec:DI [(match_dup 1)
		    (match_operand:DI 2 "fetchadd_operand" "n")] 19))]
  ""
  "fetchadd8.acq %0 = %1, %2"
  [(set_attr "itanium_class" "sem")])

(define_insn "cmpxchg_acq_si"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
	(match_dup 1))
   (set (match_operand:SI 1 "not_postinc_memory_operand" "+S")
        (unspec:SI [(match_dup 1)
                    (match_operand:SI 2 "gr_register_operand" "r")
		    (match_operand 3 "ar_ccv_reg_operand" "")] 13))]
  ""
  "cmpxchg4.acq %0 = %1, %2, %3"
  [(set_attr "itanium_class" "sem")])

(define_insn "cmpxchg_acq_di"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
	(match_dup 1))
   (set (match_operand:DI 1 "not_postinc_memory_operand" "+S")
        (unspec:DI [(match_dup 1)
                    (match_operand:DI 2 "gr_register_operand" "r")
		    (match_operand:DI 3 "ar_ccv_reg_operand" "")] 13))]
  ""
  "cmpxchg8.acq %0 = %1, %2, %3"
  [(set_attr "itanium_class" "sem")])

(define_insn "xchgsi"
  [(set (match_operand:SI 0 "gr_register_operand" "=r")
        (match_operand:SI 1 "not_postinc_memory_operand" "+S"))
   (set (match_dup 1)
        (match_operand:SI 2 "gr_register_operand" "r"))]
  ""
  "xchg4 %0 = %1, %2"
  [(set_attr "itanium_class" "sem")])

(define_insn "xchgdi"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
        (match_operand:DI 1 "not_postinc_memory_operand" "+S"))
   (set (match_dup 1)
        (match_operand:DI 2 "gr_register_operand" "r"))]
  ""
  "xchg8 %0 = %1, %2"
  [(set_attr "itanium_class" "sem")])

;; Predication.

(define_cond_exec
  [(match_operator 0 "predicate_operator"
     [(match_operand:BI 1 "register_operand" "c")
      (const_int 0)])]
  ""
  "(%J0)")

(define_insn "pred_rel_mutex"
  [(set (match_operand:BI 0 "register_operand" "+c")
       (unspec:BI [(match_dup 0)] 7))]
  ""
  ".pred.rel.mutex %0, %I0"
  [(set_attr "itanium_class" "ignore")
   (set_attr "predicable" "no")])

(define_insn "safe_across_calls_all"
  [(unspec_volatile [(const_int 0)] 8)]
  ""
  ".pred.safe_across_calls p1-p63"
  [(set_attr "itanium_class" "ignore")
   (set_attr "predicable" "no")])

(define_insn "safe_across_calls_normal"
  [(unspec_volatile [(const_int 0)] 9)]
  ""
  "*
{
  emit_safe_across_calls (asm_out_file);
  return \"\";
}"
  [(set_attr "itanium_class" "ignore")
   (set_attr "predicable" "no")])

;;
;;
;; UNSPEC instruction definition to "swizzle" 32 bit pointer into 64 bit
;; pointer.  This is used by the HP-UX 32 bit mode.

(define_insn "ptr_extend"
  [(set (match_operand:DI 0 "gr_register_operand" "=r")
        (unspec:DI [(match_operand:SI 1 "gr_register_operand" "r")] 24))]
  ""
  "addp4 %0 = 0,%1"
  [(set_attr "itanium_class" "ialu")])

;;
;; As USE insns aren't meaningful after reload, this is used instead
;; to prevent deleting instructions setting registers for EH handling
(define_insn "prologue_use"
  [(unspec:DI [(match_operand:DI 0 "register_operand" "")] 25)]
  ""
  "// %0 needed for EH"
  [(set_attr "itanium_class" "ignore")
   (set_attr "predicable" "no")])
