/** Copyright (C) 2014 Free Software Foundation, Inc.
  This generated file meltrunsup-inc.cc is part of GCC.

                  [DON'T EDIT THIS GENERATED FILE]

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
**/




/* start of code generated by generate_runtypesupport_cod2ctype */
melt_ptr_t melt_code_to_ctype (int code)
{
    switch (code)
        {

        /* #1: CTYPE_BASIC_BLOCK */
        case MELTBPAR_BB:
            return MELT_PREDEF(CTYPE_BASIC_BLOCK);
        /* #2: CTYPE_BITMAP */
        case MELTBPAR_BITMAP:
            return MELT_PREDEF(CTYPE_BITMAP);
        /* #3: CTYPE_CSTRING */
        case MELTBPAR_CSTRING:
            return MELT_PREDEF(CTYPE_CSTRING);
        /* #4: CTYPE_EDGE */
        case MELTBPAR_EDGE:
            return MELT_PREDEF(CTYPE_EDGE);
        /* #5: CTYPE_GIMPLE */
        case MELTBPAR_GIMPLE:
            return MELT_PREDEF(CTYPE_GIMPLE);
        /* #6: CTYPE_GIMPLE_SEQ */
        case MELTBPAR_GIMPLESEQ:
            return MELT_PREDEF(CTYPE_GIMPLE_SEQ);
        /* #7: CTYPE_LONG */
        case MELTBPAR_LONG:
            return MELT_PREDEF(CTYPE_LONG);
        /* #8: CTYPE_LOOP */
        case MELTBPAR_LOOP:
            return MELT_PREDEF(CTYPE_LOOP);
        /* #9: CTYPE_RTVEC */
        case MELTBPAR_RTVEC:
            return MELT_PREDEF(CTYPE_RTVEC);
        /* #10: CTYPE_RTX */
        case MELTBPAR_RTX:
            return MELT_PREDEF(CTYPE_RTX);
        /* #11: CTYPE_TREE */
        case MELTBPAR_TREE:
            return MELT_PREDEF(CTYPE_TREE);
        /* #12: CTYPE_VALUE */
        case MELTBPAR_PTR:
            return MELT_PREDEF(CTYPE_VALUE);
        /* #13: CTYPE_VOID */

        default:
            break;
        } /*end switch code*/
    return NULL;
} /* end of generated melt_code_to_ctype */



/** start of code generated by generate_runtypesupport_mag2str **/
const char* melt_obmag_string (int i)
{
#define MELT_MAG2STR_CACHEBUF 17
#define MELT_MAG2STR_MAGLEN   16
    static char melt_cacheobmagbuf[MELT_MAG2STR_CACHEBUF][MELT_MAG2STR_MAGLEN] ;
    switch (i)
        {
        case 0:
            return "MeltObMag!0" ;
        /*gtyctype #1 CTYPE_BASIC_BLOCK*/
        case MELTOBMAG_BASICBLOCK:
            return "MELTOBMAG_BASICBLOCK";
        case MELTOBMAG_MAPBASICBLOCKS:
            return "MELTOBMAG_MAPBASICBLOCKS";

        /*gtyctype #2 CTYPE_BITMAP*/
        case MELTOBMAG_BITMAP:
            return "MELTOBMAG_BITMAP";
        case MELTOBMAG_MAPBITMAPS:
            return "MELTOBMAG_MAPBITMAPS";

        /*gtyctype #3 CTYPE_CSTRING*/
        /*runtypesupport_mag2str no boxed magic */
        /*runtypesupport_mag2str no map magic */

        /*gtyctype #4 CTYPE_EDGE*/
        case MELTOBMAG_EDGE:
            return "MELTOBMAG_EDGE";
        case MELTOBMAG_MAPEDGES:
            return "MELTOBMAG_MAPEDGES";

        /*gtyctype #5 CTYPE_GIMPLE*/
        case MELTOBMAG_GIMPLE:
            return "MELTOBMAG_GIMPLE";
        case MELTOBMAG_MAPGIMPLES:
            return "MELTOBMAG_MAPGIMPLES";

        /*gtyctype #6 CTYPE_GIMPLE_SEQ*/
        case MELTOBMAG_GIMPLESEQ:
            return "MELTOBMAG_GIMPLESEQ";
        case MELTOBMAG_MAPGIMPLESEQS:
            return "MELTOBMAG_MAPGIMPLESEQS";

        /*gtyctype #7 CTYPE_LONG*/
        /*runtypesupport_mag2str no boxed magic */
        /*runtypesupport_mag2str no map magic */

        /*gtyctype #8 CTYPE_LOOP*/
        case MELTOBMAG_LOOP:
            return "MELTOBMAG_LOOP";
        case MELTOBMAG_MAPLOOPS:
            return "MELTOBMAG_MAPLOOPS";

        /*gtyctype #9 CTYPE_RTVEC*/
        case MELTOBMAG_RTVEC:
            return "MELTOBMAG_RTVEC";
        case MELTOBMAG_MAPRTVECS:
            return "MELTOBMAG_MAPRTVECS";

        /*gtyctype #10 CTYPE_RTX*/
        case MELTOBMAG_RTX:
            return "MELTOBMAG_RTX";
        case MELTOBMAG_MAPRTXS:
            return "MELTOBMAG_MAPRTXS";

        /*gtyctype #11 CTYPE_TREE*/
        case MELTOBMAG_TREE:
            return "MELTOBMAG_TREE";
        case MELTOBMAG_MAPTREES:
            return "MELTOBMAG_MAPTREES";

        /*gtyctype #12 CTYPE_VALUE*/
        /*runtypesupport_mag2str no boxed magic */
        /*runtypesupport_mag2str no map magic */

        /*gtyctype #13 CTYPE_VOID*/
        /*runtypesupport_mag2str no boxed magic */
        /*runtypesupport_mag2str no map magic */


        /*valdesc #1 VALDESC_BUCKETLONGS*/
        case MELTOBMAG_BUCKETLONGS:
            return "MELTOBMAG_BUCKETLONGS";

        /*valdesc #2 VALDESC_CLOSURE*/
        case MELTOBMAG_CLOSURE:
            return "MELTOBMAG_CLOSURE";

        /*valdesc #3 VALDESC_DECAY*/
        case MELTOBMAG_DECAY:
            return "MELTOBMAG_DECAY";

        /*valdesc #4 VALDESC_HOOK*/
        case MELTOBMAG_HOOK:
            return "MELTOBMAG_HOOK";

        /*valdesc #5 VALDESC_INT*/
        case MELTOBMAG_INT:
            return "MELTOBMAG_INT";

        /*valdesc #6 VALDESC_JSONOBJECT*/
        case MELTOBMAG_JSONOBJECT:
            return "MELTOBMAG_JSONOBJECT";

        /*valdesc #7 VALDESC_LIST*/
        case MELTOBMAG_LIST:
            return "MELTOBMAG_LIST";

        /*valdesc #8 VALDESC_MAPOBJECTS*/
        case MELTOBMAG_MAPOBJECTS:
            return "MELTOBMAG_MAPOBJECTS";

        /*valdesc #9 VALDESC_MAPSTRINGS*/
        case MELTOBMAG_MAPSTRINGS:
            return "MELTOBMAG_MAPSTRINGS";

        /*valdesc #10 VALDESC_MIXBIGINT*/
        case MELTOBMAG_MIXBIGINT:
            return "MELTOBMAG_MIXBIGINT";

        /*valdesc #11 VALDESC_MIXINT*/
        case MELTOBMAG_MIXINT:
            return "MELTOBMAG_MIXINT";

        /*valdesc #12 VALDESC_MIXLOC*/
        case MELTOBMAG_MIXLOC:
            return "MELTOBMAG_MIXLOC";

        /*valdesc #13 VALDESC_MULTIPLE*/
        case MELTOBMAG_MULTIPLE:
            return "MELTOBMAG_MULTIPLE";

        /*valdesc #14 VALDESC_OBJECT*/
        case MELTOBMAG_OBJECT:
            return "MELTOBMAG_OBJECT";

        /*valdesc #15 VALDESC_PAIR*/
        case MELTOBMAG_PAIR:
            return "MELTOBMAG_PAIR";

        /*valdesc #16 VALDESC_REAL*/
        case MELTOBMAG_REAL:
            return "MELTOBMAG_REAL";

        /*valdesc #17 VALDESC_ROUTINE*/
        case MELTOBMAG_ROUTINE:
            return "MELTOBMAG_ROUTINE";

        /*valdesc #18 VALDESC_SPECIAL_DATA*/
        case MELTOBMAG_SPECIAL_DATA:
            return "MELTOBMAG_SPECIAL_DATA";

        /*valdesc #19 VALDESC_STRBUF*/
        case MELTOBMAG_STRBUF:
            return "MELTOBMAG_STRBUF";

        /*valdesc #20 VALDESC_STRING*/
        case MELTOBMAG_STRING:
            return "MELTOBMAG_STRING";
        default:
        {
            int ix = (i & 0x3ffffff) % MELT_MAG2STR_CACHEBUF;
            snprintf (melt_cacheobmagbuf[ix], MELT_MAG2STR_MAGLEN-1, "?MeltObjMag?%d", i);
            return melt_cacheobmagbuf[ix];
        }
        } /* end switch */
} /* end generated melt_obmag_string */

/** end of code generated by generate_runtypesupport_mag2str **/


/** generated by generate_runtypesupport_forwcopy_fun **/

/* cheney like forwarding generated function */
melt_ptr_t
melt_forwarded_copy (melt_ptr_t p)
{
    /* header generated by generate_runtypesupport_forwcopy_fun */
    melt_ptr_t n = 0;
    int mag = 0;
    gcc_assert (melt_is_young (p));
    gcc_assert (p->u_discr && p->u_discr != MELT_FORWARDED_DISCR);
    if (p->u_discr->meltobj_class == MELT_FORWARDED_DISCR)
        mag =
            ((meltobject_ptr_t)
             (((struct meltforward_st *) p->u_discr)->forward))->meltobj_magic;
    else
        mag = p->u_discr->meltobj_magic;
    melt_forward_counter++;
    switch (mag)   /* end of generated header */
        {

        /* value descriptor forward copy for melt_forwarded_copy  */

        /*valdesc #1 VALDESC_BUCKETLONGS*/
        case MELTOBMAG_BUCKETLONGS:
        {
            struct meltbucketlongs_st*src = (struct meltbucketlongs_st*) p;
            struct meltbucketlongs_st*dst = NULL;
            /* copy chunk from  VALDESC_BUCKETLONGS  in warmelt-base.melt */
            /* ggc_alloc_meltbucketlongs_st should be gengtype generated for VALDESC_BUCKETLONGS */
            unsigned lnix = src->buckl_lenix;
            unsigned len = melt_primtab[lnix];
            unsigned ucnt = 0;
            unsigned ix = 0;
            size_t sz = len*sizeof (struct melt_bucketlongentry_st)
                        + offsetof(struct meltbucketlongs_st, buckl_entab);
            gcc_assert (lnix > 0);
            gcc_assert (len > 0);
            dst = /* Don't need a cleared allocation! */
                ggc_alloc_meltbucketlongs_st (sz);
            melt_forwarded_copy_byte_count += sz;
            dst->discr = src->discr;
            dst->buckl_lenix = src->buckl_lenix;
            dst->buckl_aux = src->buckl_aux;
            dst->buckl_xnum = src->buckl_xnum;
            ucnt = dst->buckl_ucount = src->buckl_ucount;
            for (ix = 0;
                    ix < ucnt;
                    ix++)
                dst->buckl_entab[ix] = src->buckl_entab[ix];
            for (ix = ucnt;
                    ix < len;
                    ix++)
                {
                    dst->buckl_entab[ix].ebl_at = 0L;
                    dst->buckl_entab[ix].ebl_va = NULL;
                }
            /* end copy chunk VALDESC_BUCKETLONGS */

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #2 VALDESC_CLOSURE*/
        case MELTOBMAG_CLOSURE:
        {
            struct meltclosure_st*src = (struct meltclosure_st*) p;
            struct meltclosure_st*dst = NULL;
            /* copy VALDESC_CLOSURE in warmelt-base.melt  */
            /* ggc_alloc_meltclosure_st should be gengtype generated for VALDESC_CLOSURE */
#ifndef ggc_alloc_meltclosure_st
#define ggc_alloc_meltclosure_st(SIZE) ((struct meltclosure_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
            int nbv = (int) src->nbval;
            size_t sz = nbv*sizeof(void*) + offsetof(struct meltclosure_st, tabval);
            dst =
                /* Don't need a cleared allocation!  */
                ggc_alloc_meltclosure_st  (sz);
            melt_forwarded_copy_byte_count += sz;
            dst->discr = src->discr;
            dst->rout = src->rout;
            dst->nbval = (unsigned) nbv;
            for (int ix = 0;
                    ix < nbv;
                    ix++)
                dst->tabval[ix] = src->tabval[ix];

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #3 VALDESC_DECAY*/
        case MELTOBMAG_DECAY:
        {
            struct meltdecay_st*src = (struct meltdecay_st*) p;
            struct meltdecay_st*dst = NULL;
            /* from VALDESC_DECAY */
            /* ggc_alloc_meltdecay_st should be gengtype generated for VALDESC_DECAY */
#ifndef ggc_alloc_meltdecay_st
#define ggc_alloc_meltdecay_st() ((struct meltdecay_st *)(ggc_internal_alloc_stat (sizeof (struct meltdecay_st) MEM_STAT_INFO)))
#endif
            dst = ggc_alloc_meltdecay_st ();
            *dst = *src;
            melt_forwarded_copy_byte_count += sizeof(*dst);

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #4 VALDESC_HOOK*/
        case MELTOBMAG_HOOK:
        {
            struct melthook_st*src = (struct melthook_st*) p;
            struct melthook_st*dst = NULL;
            /* from VALDESC_HOOK in warmelt-base.melt */
            /* ggc_alloc_melthook_st should be gengtype generated for VALDESC_HOOK */
#ifndef ggc_alloc_melthook_st
#define ggc_alloc_melthook_st(SIZE) ((struct melthook_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
            int nbv = (int) src->nbval;
            int ix = 0;
            size_t sz = nbv*sizeof(void*) + offsetof(struct melthook_st, tabval);
            dst =
                /* Don't need a cleared allocation!  */
                ggc_alloc_melthook_st (sz);
            melt_forwarded_copy_byte_count += sz;
            dst->discr = src->discr;
            strncpy (dst->hookname, src->hookname, MELT_HOOKNAME_LEN);
            dst->hookname[MELT_HOOKNAME_LEN - 1] = 0;
            dst->nbval = (unsigned) nbv;
            dst->hookad = src->hookad;
            for (ix = 0;
                    ix < nbv;
                    ix++)
                dst->tabval[ix] = src->tabval[ix];
            dst->hookdata = src->hookdata;

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #5 VALDESC_INT*/
        case MELTOBMAG_INT:
        {
            struct meltint_st*src = (struct meltint_st*) p;
            struct meltint_st*dst = NULL;
            /* from VALDESC_INT */
            /* ggc_alloc_meltint_st should be gengtype generated for VALDESC_INT */
#ifndef ggc_alloc_meltint_st
#define ggc_alloc_meltint_st() ((struct meltint_st *)(ggc_internal_alloc_stat (sizeof (struct meltint_st) MEM_STAT_INFO)))
#endif
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltint_st ();
            melt_forwarded_copy_byte_count += sizeof(*dst);
            *dst = *src;

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #6 VALDESC_JSONOBJECT*/
        case MELTOBMAG_JSONOBJECT:
        {
            struct meltjsonobject_st*src = (struct meltjsonobject_st*) p;
            struct meltjsonobject_st*dst = NULL;
            /* copy chunk from  VALDESC_JSONOBJECT in warmelt-base.melt */
            /* ggc_alloc_meltjsonobject_st should be gengtype generated for VALDESC_JSONOBJECT */
            unsigned srcsize = src->jsob_size;
            size_t sz = srcsize * sizeof(melt_jsonobentry_st)
                        + offsetof(struct meltjsonobject_st, jsob_entab);
            dst = /* Don't need a cleared allocation! */
                ggc_alloc_meltjsonobject_st (sz);
            melt_forwarded_copy_byte_count += sz;
            dst->discr = src->discr;
            dst->jsob_aux = src->jsob_aux;
            dst->jsob_size = srcsize;
            for (unsigned ix = 0;
                    ix < srcsize;
                    ix++)
                dst->jsob_entab[ix] = src->jsob_entab[ix];
            /* end copy chunk VALDESC_JSONOBJECT */

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #7 VALDESC_LIST*/
        case MELTOBMAG_LIST:
        {
            struct meltlist_st*src = (struct meltlist_st*) p;
            struct meltlist_st*dst = NULL;
            /* copy chunk from VALDESC_LIST */
            /* ggc_alloc_meltlist_st should be gengtype gengtype for VALDESC_LIST */
#ifndef ggc_alloc_meltlist_st
#define ggc_alloc_meltlist_st() ((struct meltlist_st *)(ggc_internal_alloc_stat (sizeof (struct meltlist_st) MEM_STAT_INFO)))
#endif
            dst =
                /* Don't need a cleared allocation!  */
                ggc_alloc_meltlist_st ();
            *dst = *src;
            melt_forwarded_copy_byte_count += sizeof(*dst);
            /* end chunk from VALDESC_LIST */

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #8 VALDESC_MAPOBJECTS*/
        case MELTOBMAG_MAPOBJECTS:
        {
            struct meltmapobjects_st*src = (struct meltmapobjects_st*) p;
            struct meltmapobjects_st*dst = NULL;
            /* copy VALDESC_MAPOBJECTS in warmelt-base.melt */
            /* ggc_alloc_meltmapobjects_st should be gengtype generated for VALDESC_MAPOBJECTS */
#ifndef ggc_alloc_meltmapobjects_st
#define ggc_alloc_meltmapobjects_st() ((struct meltmapobjects_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapobjects_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entryobjectsmelt_st
#define ggc_alloc_vec_entryobjectsmelt_st(N) ((struct entryobjectsmelt_st *) (ggc_internal_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), N MEM_STAT_INFO)))
#endif
#ifndef  ggc_alloc_cleared_vec_entryobjectsmelt_st
#define ggc_alloc_cleared_vec_entryobjectsmelt_st(n) ((struct entryobjectsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), n MEM_STAT_INFO)))
#endif
            int siz = melt_primtab[src->lenix];
            size_t sz = 0;
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltmapobjects_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            sz = sizeof(*dst);
            if (siz > 0 && src->entab)
                {
                    /* Don't need a cleared allocation.  */
                    dst->entab = ggc_alloc_vec_entryobjectsmelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                    sz += siz * sizeof(dst->entab[0]);
                }
            else
                dst->entab = NULL;
            melt_forwarded_copy_byte_count += sz;

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #9 VALDESC_MAPSTRINGS*/
        case MELTOBMAG_MAPSTRINGS:
        {
            struct meltmapstrings_st*src = (struct meltmapstrings_st*) p;
            struct meltmapstrings_st*dst = NULL;
            /* copy VALDESC_MAPSTRINGS in warmelt-base.melt */
            /* ggc_alloc_meltmapstrings_st should be gengtype generated for VALDESC_MAPSTRINGS */
#ifndef ggc_alloc_meltmapstrings_st
#define ggc_alloc_meltmapstrings_st() ((struct meltmapstrings_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapstrings_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entrystringsmelt_st
#define ggc_alloc_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_cleared_vec_entrystringsmelt_st
#define ggc_alloc_cleared_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
            int siz = melt_primtab[src->lenix];
            size_t sz = 0;
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltmapstrings_st ();
            sz = sizeof (*dst);
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    /* Don't need a cleared allocation.  */
                    dst->entab = ggc_alloc_vec_entrystringsmelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                    sz += siz * sizeof(dst->entab[0]);
                }
            else
                dst->entab = NULL;
            melt_forwarded_copy_byte_count += sz;

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #10 VALDESC_MIXBIGINT*/
        case MELTOBMAG_MIXBIGINT:
        {
            struct meltmixbigint_st*src = (struct meltmixbigint_st*) p;
            struct meltmixbigint_st*dst = NULL;
            /* from VALDESC_MIXBIGINT */
            /* ggc_alloc_meltmixbigint_st should be gengtype generated for VALDESC_MIXBIGINT */
#ifndef ggc_alloc_meltmixbigint_st
#define ggc_alloc_meltmixbigint_st(SIZE) ((struct meltmixbigint_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
            unsigned blen = src->biglen;
            size_t sz = blen*sizeof(long) + offsetof(struct meltmixbigint_st, tabig);
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltmixbigint_st   (sz);
            dst->discr = src->discr;
            dst->ptrval = src->ptrval;
            dst->negative = src->negative;
            dst->biglen = blen;
            memcpy (dst->tabig, src->tabig, blen*sizeof(dst->tabig[0]));
            melt_forwarded_copy_byte_count += sz;

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #11 VALDESC_MIXINT*/
        case MELTOBMAG_MIXINT:
        {
            struct meltmixint_st*src = (struct meltmixint_st*) p;
            struct meltmixint_st*dst = NULL;
            /* from VALDESC_MIXINT */
            /* ggc_alloc_meltmixint_st should be gengtype generated for VALDESC_MIXINT */
#ifndef ggc_alloc_meltmixint_st
#define ggc_alloc_meltmixint_st() ((struct meltmixint_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixint_st) MEM_STAT_INFO)))
#endif
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltmixint_st ();
            melt_forwarded_copy_byte_count += sizeof(*dst);
            *dst = *src;

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #12 VALDESC_MIXLOC*/
        case MELTOBMAG_MIXLOC:
        {
            struct meltmixloc_st*src = (struct meltmixloc_st*) p;
            struct meltmixloc_st*dst = NULL;
            /* from VALDESC_MIXLOC */
            /* ggc_alloc_meltmixloc_st should be gengtype generated for VALDESC_MIXLOC */
#ifndef ggc_alloc_meltmixloc_st
#define ggc_alloc_meltmixloc_st() ((struct meltmixloc_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixloc_st) MEM_STAT_INFO)))
#endif
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltmixloc_st ();
            *dst = *src;
            melt_forwarded_copy_byte_count += sizeof(*dst);

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #13 VALDESC_MULTIPLE*/
        case MELTOBMAG_MULTIPLE:
        {
            struct meltmultiple_st*src = (struct meltmultiple_st*) p;
            struct meltmultiple_st*dst = NULL;
            /* copy chunk from VALDESC_MULTIPLE */
            /* ggc_alloc_meltmultiple_st should be gengtype generated for VALDESC_MULTIPLE */
#ifndef ggc_alloc_meltmultiple_st
#define ggc_alloc_meltmultiple_st(SIZE) ((struct meltmultiple_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
            int nbv = (int) src->nbval;
            size_t sz = nbv*sizeof(void*) + offsetof(struct meltmultiple_st, tabval);
            dst =
                /* Don't need a cleared allocation!  */
                ggc_alloc_meltmultiple_st (sz);
            melt_forwarded_copy_byte_count += sz;
            /* we cannot copy the whole src, because MELT_FLEXIBLE_DIM might be
               1 and nbval could be 0 */
            dst->discr = src->discr;
            dst->nbval = src->nbval;
            for (int ix = 0;
                    ix < nbv;
                    ix++)
                dst->tabval[ix] = src->tabval[ix];
            /* end copy chunk from VALDESC_MULTIPLE */

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #14 VALDESC_OBJECT*/
        case MELTOBMAG_OBJECT:
        {
            struct meltobject_st*src = (struct meltobject_st*) p;
            struct meltobject_st*dst = NULL;
            /* from VALDESC_OBJECT */
            /* ggc_alloc_meltobject_st should be gengtype generated for VALDESC_OBJECT */
#ifndef ggc_alloc_meltobject_st
#define ggc_alloc_meltobject_st(SIZE) ((struct meltobject_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
            int ix = 0;
            int oblen = (int) (src->obj_len);
            size_t sz = 0;
            /* We don't need to clear at allocation, since the object is
               explicitly filled here! */
            sz = oblen*sizeof(void*)
                 + offsetof(struct meltobject_st, obj_vartab);
            dst = ggc_alloc_meltobject_st (sz);
            melt_forwarded_copy_byte_count += sz;
            /* we cannot copy the whole src, because MELT_FLEXIBLE_DIM might be 1 */
            dst->meltobj_class = src->meltobj_class;
            dst->obj_hash = src->obj_hash;
            dst->obj_num = src->obj_num;
            dst->obj_len = oblen;
            for (ix = 0;
                    ix < oblen;
                    ix++)
                dst->obj_vartab[ix] = src->obj_vartab[ix];
#if ENABLE_CHECKING
            /* for low level debugging with gdb, we may want to catch some copy operations */
            if (melt_alptr_1 && (void*) src == melt_alptr_1)
                melt_break_alptr_1 ("copyobj src=alptr1");
            if (melt_alptr_2 && (void*) src == melt_alptr_2)
                melt_break_alptr_2 ("copyobj src=alptr2");
            if (src->obj_hash == melt_objhash_1)
                melt_break_objhash_1("copyobj src with objhash1");
            if (src->obj_hash == melt_objhash_2)
                melt_break_objhash_2("copyobj src with objhash2");
#endif /* ENABLE_CHECKING */

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #15 VALDESC_PAIR*/
        case MELTOBMAG_PAIR:
        {
            struct meltpair_st*src = (struct meltpair_st*) p;
            struct meltpair_st*dst = NULL;
            /* copy VALDESC_PAIR in warmelt-base.melt */
            /* ggc_alloc_meltpair_st should be gengtype gengtype for VALDESC_PAIR */
#ifndef ggc_alloc_meltpair_st
#define ggc_alloc_meltpair_st() ((struct meltpair_st *)(ggc_internal_alloc_stat (sizeof (struct meltpair_st) MEM_STAT_INFO)))
#endif
            dst = /* Don't need a cleared allocation.  */
                ggc_alloc_meltpair_st ();
            *dst = *src;
            melt_forwarded_copy_byte_count += sizeof(*dst);

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #16 VALDESC_REAL*/
        case MELTOBMAG_REAL:
        {
            struct meltreal_st*src = (struct meltreal_st*) p;
            struct meltreal_st*dst = NULL;
            /* from VALDESC_REAL */
            /* ggc_alloc_meltreal_st should be gengtype generated for VALDESC_REAL */
#ifndef ggc_alloc_meltreal_st
#define ggc_alloc_meltreal_st() ((struct meltreal_st *)(ggc_internal_alloc_stat (sizeof (struct meltreal_st) MEM_STAT_INFO)))
#endif
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltreal_st ();
            melt_forwarded_copy_byte_count += sizeof(*dst);
            *dst = *src;

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #17 VALDESC_ROUTINE*/
        case MELTOBMAG_ROUTINE:
        {
            struct meltroutine_st*src = (struct meltroutine_st*) p;
            struct meltroutine_st*dst = NULL;
            /* from VALDESC_ROUTINE */
            /* ggc_alloc_meltroutine_st should be gengtype generated for VALDESC_ROUTINE */
#ifndef ggc_alloc_meltroutine_st
#define ggc_alloc_meltroutine_st(SIZE) ((struct meltroutine_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
            int nbv = (int) src->nbval;
            size_t sz = nbv*sizeof(void*) + offsetof(struct meltroutine_st, tabval);
            int ix = 0;
            dst =
                /* Don't need a cleared allocation!  */
                ggc_alloc_meltroutine_st (sz);
            melt_forwarded_copy_byte_count += sz;
            dst->discr = src->discr;
            strncpy (dst->routdescr, src->routdescr, MELT_ROUTDESCR_LEN);
            dst->routdescr[MELT_ROUTDESCR_LEN - 1] = 0;
            dst->nbval = (unsigned) nbv;
            dst->routfunad = src->routfunad;
            for (ix = 0;
                    ix < nbv;
                    ix++)
                dst->tabval[ix] = src->tabval[ix];
            dst->routdata = src->routdata;

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #18 VALDESC_SPECIAL_DATA*/
        case MELTOBMAG_SPECIAL_DATA:
        {
            struct meltspecialdata_st*src = (struct meltspecialdata_st*) p;
            struct meltspecialdata_st*dst = NULL;
            /* from VALDESC_SPECIAL_DATA */
            /* ggc_alloc_meltspecialdata_st should be gengtype generated for VALDESC_SPECIAL_DATA */
#ifndef ggc_alloc_meltspecialdata_st
#define ggc_alloc_meltspecialdata_st() ((struct meltspecialdata_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialdata_st) MEM_STAT_INFO)))
#endif
            dst = ggc_alloc_meltspecialdata_st ();
            *dst = *src;
            /* mark the new copy! */
            dst->meltspec_mark = 1;
            /* add the new copy to the old (major) special list */
            dst->meltspec_next = melt_oldspecdatalist;
            melt_oldspecdatalist = dst;
            melt_forwarded_copy_byte_count += sizeof(*dst);

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #19 VALDESC_STRBUF*/
        case MELTOBMAG_STRBUF:
        {
            struct meltstrbuf_st*src = (struct meltstrbuf_st*) p;
            struct meltstrbuf_st*dst = NULL;
            /* copy chunk from VALDESC_STRBUF */
            /* ggc_alloc_meltstrbuf_st should be gengtype gengtype for VALDESC_STRBUF */
#ifndef ggc_alloc_meltstrbuf_st
#define ggc_alloc_meltstrbuf_st() ((struct meltstrbuf_st *)(ggc_internal_alloc_stat (sizeof (struct meltstrbuf_st) MEM_STAT_INFO)))
#endif
            unsigned blen = melt_primtab[src->buflenix];
            size_t sz = sizeof(*dst);
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltstrbuf_st ();
            dst->discr = src->discr;
            dst->bufstart = src->bufstart;
            dst->bufend = src->bufend;
            dst->buflenix = src->buflenix;
            if (blen > 0)
                {
                    dst->bufzn = CONST_CAST (char *, ggc_alloc_string (src->bufzn, blen+1));
                    dst->bufzn[blen] = (char)0;
                    sz += blen+1;
                }
            else
                dst->bufzn = NULL;
            melt_forwarded_copy_byte_count += sz;
            /* end copy chunk from VALDESC_STRBUF */

            n = (melt_ptr_t) dst;
            break;
        }

        /*valdesc #20 VALDESC_STRING*/
        case MELTOBMAG_STRING:
        {
            struct meltstring_st*src = (struct meltstring_st*) p;
            struct meltstring_st*dst = NULL;
            /* copy from VALDESC_STRING file warmelt-base.melt*/
            /* ggc_alloc_meltstring_st should be gengtype generated for VALDESC_STRING */
#ifndef ggc_alloc_meltstring_st
#define ggc_alloc_meltstring_st(SIZE) ((struct meltstring_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
            int srclen = (src->val)?strlen (src->val):0;
            size_t sz = offsetof(struct meltstring_st, val) + (srclen+1);
            dst =
                /* Don't need a cleared allocation.  */
                ggc_alloc_meltstring_st  (sz);
            melt_forwarded_copy_byte_count += sz;
            dst->discr = src->discr;
            memcpy (dst->val, src->val, srclen);
            dst->val[srclen] = (char)0;
            dst->slen = (unsigned) srclen;
            /* end copy from VALDESC_STRING */

            n = (melt_ptr_t) dst;
            break;
        }


        /* gty ctype forward copy for melt_forwarded_copy */
        /*forwcopy gtyctype #1 CTYPE_BASIC_BLOCK*/
        case MELTOBMAG_BASICBLOCK:
        {
            /* macro ggc_alloc_meltbasicblock_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltbasicblock_st
#define ggc_alloc_meltbasicblock_st() ((struct meltbasicblock_st*)(ggc_internal_alloc_stat (sizeof (struct meltbasicblock_st) MEM_STAT_INFO)))
#endif
            struct meltbasicblock_st *src = (struct meltbasicblock_st*) p;
            struct meltbasicblock_st *dst = ggc_alloc_meltbasicblock_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPBASICBLOCKS:
        {
            /* ggc_alloc_meltmapbasicblocks_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapbasicblocks_st
#define ggc_alloc_meltmapbasicblocks_st() ((struct meltmapbasicblocks_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapbasicblocks_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entrybasicblockmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrybasicblockmelt_st
#define ggc_alloc_vec_entrybasicblockmelt_st(n) ((struct entrybasicblockmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrybasicblockmelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmapbasicblocks_st *src = (struct meltmapbasicblocks_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmapbasicblocks_st *dst = ggc_alloc_meltmapbasicblocks_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entrybasicblockmelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /*forwcopy gtyctype #2 CTYPE_BITMAP*/
        case MELTOBMAG_BITMAP:
        {
            /* macro ggc_alloc_meltbitmap_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltbitmap_st
#define ggc_alloc_meltbitmap_st() ((struct meltbitmap_st*)(ggc_internal_alloc_stat (sizeof (struct meltbitmap_st) MEM_STAT_INFO)))
#endif
            struct meltbitmap_st *src = (struct meltbitmap_st*) p;
            struct meltbitmap_st *dst = ggc_alloc_meltbitmap_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPBITMAPS:
        {
            /* ggc_alloc_meltmapbitmaps_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapbitmaps_st
#define ggc_alloc_meltmapbitmaps_st() ((struct meltmapbitmaps_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapbitmaps_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entrybitmapmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrybitmapmelt_st
#define ggc_alloc_vec_entrybitmapmelt_st(n) ((struct entrybitmapmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrybitmapmelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmapbitmaps_st *dst = ggc_alloc_meltmapbitmaps_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entrybitmapmelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /*forwcopy gtyctype #3 CTYPE_EDGE*/
        case MELTOBMAG_EDGE:
        {
            /* macro ggc_alloc_meltedge_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltedge_st
#define ggc_alloc_meltedge_st() ((struct meltedge_st*)(ggc_internal_alloc_stat (sizeof (struct meltedge_st) MEM_STAT_INFO)))
#endif
            struct meltedge_st *src = (struct meltedge_st*) p;
            struct meltedge_st *dst = ggc_alloc_meltedge_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPEDGES:
        {
            /* ggc_alloc_meltmapedges_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapedges_st
#define ggc_alloc_meltmapedges_st() ((struct meltmapedges_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapedges_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entryedgemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryedgemelt_st
#define ggc_alloc_vec_entryedgemelt_st(n) ((struct entryedgemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryedgemelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmapedges_st *src = (struct meltmapedges_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmapedges_st *dst = ggc_alloc_meltmapedges_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entryedgemelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /*forwcopy gtyctype #4 CTYPE_GIMPLE*/
        case MELTOBMAG_GIMPLE:
        {
            /* macro ggc_alloc_meltgimple_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltgimple_st
#define ggc_alloc_meltgimple_st() ((struct meltgimple_st*)(ggc_internal_alloc_stat (sizeof (struct meltgimple_st) MEM_STAT_INFO)))
#endif
            struct meltgimple_st *src = (struct meltgimple_st*) p;
            struct meltgimple_st *dst = ggc_alloc_meltgimple_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPGIMPLES:
        {
            /* ggc_alloc_meltmapgimples_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapgimples_st
#define ggc_alloc_meltmapgimples_st() ((struct meltmapgimples_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapgimples_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entrygimplemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrygimplemelt_st
#define ggc_alloc_vec_entrygimplemelt_st(n) ((struct entrygimplemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrygimplemelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmapgimples_st *src = (struct meltmapgimples_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmapgimples_st *dst = ggc_alloc_meltmapgimples_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entrygimplemelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /*forwcopy gtyctype #5 CTYPE_GIMPLE_SEQ*/
        case MELTOBMAG_GIMPLESEQ:
        {
            /* macro ggc_alloc_meltgimpleseq_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltgimpleseq_st
#define ggc_alloc_meltgimpleseq_st() ((struct meltgimpleseq_st*)(ggc_internal_alloc_stat (sizeof (struct meltgimpleseq_st) MEM_STAT_INFO)))
#endif
            struct meltgimpleseq_st *src = (struct meltgimpleseq_st*) p;
            struct meltgimpleseq_st *dst = ggc_alloc_meltgimpleseq_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPGIMPLESEQS:
        {
            /* ggc_alloc_meltmapgimpleseqs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapgimpleseqs_st
#define ggc_alloc_meltmapgimpleseqs_st() ((struct meltmapgimpleseqs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapgimpleseqs_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entrygimpleseqmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrygimpleseqmelt_st
#define ggc_alloc_vec_entrygimpleseqmelt_st(n) ((struct entrygimpleseqmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrygimpleseqmelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmapgimpleseqs_st *dst = ggc_alloc_meltmapgimpleseqs_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entrygimpleseqmelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /*forwcopy gtyctype #6 CTYPE_LOOP*/
        case MELTOBMAG_LOOP:
        {
            /* macro ggc_alloc_meltloop_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltloop_st
#define ggc_alloc_meltloop_st() ((struct meltloop_st*)(ggc_internal_alloc_stat (sizeof (struct meltloop_st) MEM_STAT_INFO)))
#endif
            struct meltloop_st *src = (struct meltloop_st*) p;
            struct meltloop_st *dst = ggc_alloc_meltloop_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPLOOPS:
        {
            /* ggc_alloc_meltmaploops_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaploops_st
#define ggc_alloc_meltmaploops_st() ((struct meltmaploops_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaploops_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entryloopmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryloopmelt_st
#define ggc_alloc_vec_entryloopmelt_st(n) ((struct entryloopmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryloopmelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmaploops_st *src = (struct meltmaploops_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmaploops_st *dst = ggc_alloc_meltmaploops_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entryloopmelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /*forwcopy gtyctype #7 CTYPE_RTVEC*/
        case MELTOBMAG_RTVEC:
        {
            /* macro ggc_alloc_meltrtvec_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltrtvec_st
#define ggc_alloc_meltrtvec_st() ((struct meltrtvec_st*)(ggc_internal_alloc_stat (sizeof (struct meltrtvec_st) MEM_STAT_INFO)))
#endif
            struct meltrtvec_st *src = (struct meltrtvec_st*) p;
            struct meltrtvec_st *dst = ggc_alloc_meltrtvec_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPRTVECS:
        {
            /* ggc_alloc_meltmaprtvecs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaprtvecs_st
#define ggc_alloc_meltmaprtvecs_st() ((struct meltmaprtvecs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaprtvecs_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entryrtvecmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryrtvecmelt_st
#define ggc_alloc_vec_entryrtvecmelt_st(n) ((struct entryrtvecmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryrtvecmelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmaprtvecs_st *dst = ggc_alloc_meltmaprtvecs_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entryrtvecmelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /*forwcopy gtyctype #8 CTYPE_RTX*/
        case MELTOBMAG_RTX:
        {
            /* macro ggc_alloc_meltrtx_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltrtx_st
#define ggc_alloc_meltrtx_st() ((struct meltrtx_st*)(ggc_internal_alloc_stat (sizeof (struct meltrtx_st) MEM_STAT_INFO)))
#endif
            struct meltrtx_st *src = (struct meltrtx_st*) p;
            struct meltrtx_st *dst = ggc_alloc_meltrtx_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPRTXS:
        {
            /* ggc_alloc_meltmaprtxs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaprtxs_st
#define ggc_alloc_meltmaprtxs_st() ((struct meltmaprtxs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaprtxs_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entryrtxmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryrtxmelt_st
#define ggc_alloc_vec_entryrtxmelt_st(n) ((struct entryrtxmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryrtxmelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmaprtxs_st *src = (struct meltmaprtxs_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmaprtxs_st *dst = ggc_alloc_meltmaprtxs_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entryrtxmelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /*forwcopy gtyctype #9 CTYPE_TREE*/
        case MELTOBMAG_TREE:
        {
            /* macro ggc_alloc_melttree_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_melttree_st
#define ggc_alloc_melttree_st() ((struct melttree_st*)(ggc_internal_alloc_stat (sizeof (struct melttree_st) MEM_STAT_INFO)))
#endif
            struct melttree_st *src = (struct melttree_st*) p;
            struct melttree_st *dst = ggc_alloc_melttree_st ();
            *dst = *src;
            n = (melt_ptr_t) dst;
            break;
        }
        case MELTOBMAG_MAPTREES:
        {
            /* ggc_alloc_meltmaptrees_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaptrees_st
#define ggc_alloc_meltmaptrees_st() ((struct meltmaptrees_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaptrees_st) MEM_STAT_INFO)))
#endif
            /* ggc_alloc_vec_entrytreemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrytreemelt_st
#define ggc_alloc_vec_entrytreemelt_st(n) ((struct entrytreemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrytreemelt_st), n MEM_STAT_INFO)))
#endif
            struct meltmaptrees_st *src = (struct meltmaptrees_st*) p;
            int siz = melt_primtab[src->lenix];
            struct meltmaptrees_st *dst = ggc_alloc_meltmaptrees_st ();
            dst->discr = src->discr;
            dst->count = src->count;
            dst->lenix = src->lenix;
            dst->meltmap_aux = src->meltmap_aux;
            if (siz > 0 && src->entab)
                {
                    dst->entab = ggc_alloc_vec_entrytreemelt_st (siz);
                    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
                }
            else dst->entab = NULL;
            n = (melt_ptr_t) dst;
            break;
        }
        /* trailer generated by generate_runtypesupport_forwcopy_fun  */
        default:
            fatal_error ("MELT corruption: forward invalid p=%p discr=%p magic=%d [%s]",
                         (void *) p, (void *) p->u_discr, mag, melt_obmag_string (mag));
        } /* end switch (mag) */

    melt_debuggc_eprintf ("melt_forwarded_copy#%ld/%04ld %p => %p %s",
                          melt_nb_garbcoll, melt_forward_counter, (void*)p,
                          (void*)n, melt_obmag_string (mag));
    if (n)
        {
#if ENABLE_CHECKING
            if (melt_alptr_1 && (void*)melt_alptr_1 == (void*)n)
                {
                    fprintf (stderr, "melt_forwarded_copy to alptr_1 %p mag %d\n",  melt_alptr_1, mag);
                    fflush (stderr);
                    melt_debuggc_eprintf("melt_forwarded_copy #%ld alptr_1 %p mag %d",
                                         melt_nb_garbcoll, melt_alptr_1, mag);
                    melt_break_alptr_1 ("forwarded copy to alptr_1");
                }
            if (melt_alptr_2 && (void*)melt_alptr_2 == (void*)n)
                {
                    fprintf (stderr, "melt_forwarded_copy to alptr_2 %p mag %d\n",  melt_alptr_2, mag);
                    fflush (stderr);
                    melt_debuggc_eprintf("melt_forwarded_copy #%ld alptr_2 %p",
                                         melt_nb_garbcoll, melt_alptr_2);
                    melt_break_alptr_2 ("forwarded copy to alptr_2");
                };
#endif /*ENABLE_CHECKING*/

            p->u_forward.discr = MELT_FORWARDED_DISCR;
            p->u_forward.forward = n;

            gcc_assert (melt_scangcvect != NULL);
            {
                unsigned long ulen = melt_scangcvect->vv_ulen;
                if (MELT_UNLIKELY(ulen + 3 < melt_scangcvect->vv_size))
                    {
                        unsigned long newsiz = (ulen + ulen/4 + 100);
                        melt_resize_scangcvect (newsiz);
                    }
                melt_scangcvect->vv_tab[ulen] = n;
                melt_scangcvect->vv_ulen = ulen+1;
            }

        }
    return n;
}  /* end of melt_forwarded_copy generated by generate_runtypesupport_forwcopy_fun */

/** end of code generated by generate_runtypesupport_forwcopy_fun **/



/** start of code generated by generate_runtypesupport_scanning **/
/* header from generate_runtypesupport_scanning */
/* The melt_scanning routine is mostly Chesney like ; however some types,
   including objects, strbuf, stringmaps, objectmaps, all the other
   *maps, contain a pointer to a non value ; this pointer should be
   carefully updated if it was young. */
static void
melt_scanning (melt_ptr_t p)
{
    unsigned omagic = 0;
    if (!p)
        return;
    gcc_assert (p != (void *) HTAB_DELETED_ENTRY);
    gcc_assert (p->u_discr && p->u_discr != (meltobject_ptr_t) 1);
    MELT_FORWARDED (p->u_discr);
    gcc_assert (!melt_is_young (p));
    omagic = p->u_discr->meltobj_magic;
    switch (omagic)
        {
        /* end of header from generate_runtypesupport_scanning*/

        /*valdesc #1 VALDESC_BUCKETLONGS*/
        case MELTOBMAG_BUCKETLONGS:
        {
            struct meltbucketlongs_st*src = (struct meltbucketlongs_st*) p;
            /* forwarding chunk from VALDESC_BUCKETLONGS in warmelt-base.melt */
            unsigned lnix = src->buckl_lenix;
            unsigned len = melt_primtab[lnix];
            unsigned ucnt = src->buckl_ucount;
            unsigned ix = 0;
            gcc_assert (lnix > 0);
            gcc_assert (len > 0);
            MELT_FORWARDED (src->buckl_aux);
            gcc_assert (ucnt <= len);
            for (ix = 0;
                    ix < ucnt;
                    ix++)
                MELT_FORWARDED (src->buckl_entab[ix].ebl_va);
            /* end forwarding VALDESC_BUCKETLONGS */

            break;
        }

        /*valdesc #2 VALDESC_CLOSURE*/
        case MELTOBMAG_CLOSURE:
        {
            struct meltclosure_st*src = (struct meltclosure_st*) p;
            /* forwarding from VALDESC_CLOSURE */
            int nbval = (int) src->nbval;
            MELT_FORWARDED (src->rout);
            for (int ix = 0;
                    ix < nbval;
                    ix++)
                MELT_FORWARDED (src->tabval[ix]);

            break;
        }

        /*valdesc #3 VALDESC_DECAY*/
        case MELTOBMAG_DECAY:
        {
            struct meltdecay_st*src = (struct meltdecay_st*) p;
            /* from VALDESC_DECAY */
            MELT_FORWARDED (src->val);

            break;
        }

        /*valdesc #4 VALDESC_HOOK*/
        case MELTOBMAG_HOOK:
        {
            struct melthook_st*src = (struct melthook_st*) p;
            /* from VALDESC_HOOK in warmelt-base.melt */
            int nbval = (int) src->nbval;
            int ix = 0;
            for (ix = 0;
                    ix < nbval;
                    ix++)
                MELT_FORWARDED (src->tabval[ix]);
            MELT_FORWARDED (src->hookdata);

            break;
        }

        /*valdesc #5 VALDESC_INT*/
        case MELTOBMAG_INT:
        {
            break;
        }

        /*valdesc #6 VALDESC_JSONOBJECT*/
        case MELTOBMAG_JSONOBJECT:
        {
            struct meltjsonobject_st*src = (struct meltjsonobject_st*) p;
            /* forwarding chunk from VALDESC_JSONOBJECT in warmelt-base.melt */
            unsigned srcsize = src->jsob_size;
            MELT_FORWARDED(src->jsob_aux);
            for (unsigned ix = 0;
                    ix < srcsize;
                    ix++)
                {
                    MELT_FORWARDED(src->jsob_entab[ix].jsonob_name);
                    MELT_FORWARDED(src->jsob_entab[ix].jsonob_val);
                };
            /* end forwarding chunk VALDESC_JSONOBJECT */

            break;
        }

        /*valdesc #7 VALDESC_LIST*/
        case MELTOBMAG_LIST:
        {
            struct meltlist_st*src = (struct meltlist_st*) p;
            /* from VALDESC_LIST */
            MELT_FORWARDED (src->first);
            MELT_FORWARDED (src->last);

            break;
        }

        /*valdesc #8 VALDESC_MAPOBJECTS*/
        case MELTOBMAG_MAPOBJECTS:
        {
            struct meltmapobjects_st*src = (struct meltmapobjects_st*) p;
            /* forwarding from VALDESC_MAPOBJECTS */
            int siz, ix;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab)
                break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz > 0);
            if (melt_is_young (src->entab))
                {
                    struct entryobjectsmelt_st *newtab =
                    /* Don't need a cleared allocation!  */
                    ggc_alloc_vec_entryobjectsmelt_st (siz);
                    memcpy (newtab, src->entab,
                            siz * sizeof (struct entryobjectsmelt_st));
                    src->entab = newtab;
                }
            for (ix = 0;
                    ix < siz;
                    ix++)
                {
                    meltobject_ptr_t at = src->entab[ix].e_at;
                    if (!at || at == (void *) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        }
                    MELT_FORWARDED (at);
                    src->entab[ix].e_at = at;
                    MELT_FORWARDED (src->entab[ix].e_va);
                }
            /* end forwarding from VALDESC_MAPOBJECTS */

            break;
        }

        /*valdesc #9 VALDESC_MAPSTRINGS*/
        case MELTOBMAG_MAPSTRINGS:
        {
            struct meltmapstrings_st*src = (struct meltmapstrings_st*) p;
            /* forwarding from VALDESC_MAPSTRINGS */
            int ix, siz;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab)
                break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz > 0);
            if (melt_is_young (src->entab))
                {
                    struct entrystringsmelt_st *newtab
                /* Don't need a cleared allocation!  */
                    = ggc_alloc_vec_entrystringsmelt_st (siz);
                    memcpy (newtab, src->entab,
                            siz * sizeof (struct entrystringsmelt_st));
                    src->entab = newtab;
                }
            for (ix = 0;
                    ix < siz;
                    ix++)
                {
                    const char *at = src->entab[ix].e_at;
                    if (!at || at == (void *) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        }
                    if (melt_is_young ((const void *) at))
                        src->entab[ix].e_at = (const char *) ggc_strdup (at);
                    MELT_FORWARDED (src->entab[ix].e_va);
                }
            /* end  forwarding from VALDESC_MAPSTRINGS */

            break;
        }

        /*valdesc #10 VALDESC_MIXBIGINT*/
        case MELTOBMAG_MIXBIGINT:
        {
            struct meltmixbigint_st*src = (struct meltmixbigint_st*) p;
            /* from VALDESC_MIXBIGINT */
            MELT_FORWARDED (src->ptrval);

            break;
        }

        /*valdesc #11 VALDESC_MIXINT*/
        case MELTOBMAG_MIXINT:
        {
            struct meltmixint_st*src = (struct meltmixint_st*) p;
            /* from VALDESC_MIXINT */
            MELT_FORWARDED (src->ptrval);

            break;
        }

        /*valdesc #12 VALDESC_MIXLOC*/
        case MELTOBMAG_MIXLOC:
        {
            struct meltmixloc_st*src = (struct meltmixloc_st*) p;
            /* from VALDESC_MIXLOC */
            MELT_FORWARDED (src->ptrval);

            break;
        }

        /*valdesc #13 VALDESC_MULTIPLE*/
        case MELTOBMAG_MULTIPLE:
        {
            struct meltmultiple_st*src = (struct meltmultiple_st*) p;
            /* forwarding chunk from VALDESC_MULTIPLE */
            int nbval = (int) src->nbval;
            for (int ix = 0;
                    ix < nbval;
                    ix++)
                MELT_FORWARDED (src->tabval[ix]);
            /* end forwarding chunk from VALDESC_MULTIPLE */

            break;
        }

        /*valdesc #14 VALDESC_OBJECT*/
        case MELTOBMAG_OBJECT:
        {
            struct meltobject_st*src = (struct meltobject_st*) p;
            /* from VALDESC_OBJECT */
            int ix = 0;
            int oblen = (int) (src->obj_len);
            for (ix = 0; ix < oblen; ix++)
                MELT_FORWARDED (src->obj_vartab[ix]);
#if ENABLE_CHECKING
            /* for low level debugging with gdb, we may want to catch some forwarding operations */
            if (melt_alptr_1 && (void*) src == melt_alptr_1)
                melt_break_alptr_1 ("forwardobj src=alptr1");
            if (melt_alptr_2 && (void*) src == melt_alptr_2)
                melt_break_alptr_2 ("forwardobj src=alptr2");
            if (src->obj_hash == melt_objhash_1)
                melt_break_objhash_1("forwardobj src with objhash1");
            if (src->obj_hash == melt_objhash_2)
                melt_break_objhash_2("forwardobj src with objhash2");
#endif /* ENABLE_CHECKING */

            break;
        }

        /*valdesc #15 VALDESC_PAIR*/
        case MELTOBMAG_PAIR:
        {
            struct meltpair_st*src = (struct meltpair_st*) p;
            /* forward VALDESC_PAIR in warmelt-base.melt */
            MELT_FORWARDED (src->hd);
            MELT_FORWARDED (src->tl);

            break;
        }

        /*valdesc #16 VALDESC_REAL*/
        case MELTOBMAG_REAL:
        {
            break;
        }

        /*valdesc #17 VALDESC_ROUTINE*/
        case MELTOBMAG_ROUTINE:
        {
            struct meltroutine_st*src = (struct meltroutine_st*) p;
            /* from VALDESC_ROUTINE */
            int nbval = (int) src->nbval;
            for (int ix = 0;
                    ix < nbval;
                    ix++)
                MELT_FORWARDED (src->tabval[ix]);
            MELT_FORWARDED (src->routdata);

            break;
        }

        /*valdesc #18 VALDESC_SPECIAL_DATA*/
        case MELTOBMAG_SPECIAL_DATA:
        {
            struct meltspecialdata_st*src = (struct meltspecialdata_st*) p;
            /* from VALDESC_SPECIAL_DATA */
            src->meltspec_mark = 1;
            MELT_FORWARDED (src->meltspec_value);

            break;
        }

        /*valdesc #19 VALDESC_STRBUF*/
        case MELTOBMAG_STRBUF:
        {
            break;
        }

        /*valdesc #20 VALDESC_STRING*/
        case MELTOBMAG_STRING:
        {
            break;
        }

        /* GTY-ed ctypes scan forward for melt_scanning  */
        /*gtyctype #1 CTYPE_BASIC_BLOCK*/
        case MELTOBMAG_BASICBLOCK:
            break;
        case MELTOBMAG_MAPBASICBLOCKS:
        {
            struct meltmapbasicblocks_st *src = (struct meltmapbasicblocks_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entrybasicblockmelt_st* newtab = ggc_alloc_vec_entrybasicblockmelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entrybasicblockmelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    basic_block at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPBASICBLOCKS */
        break;
        /*gtyctype #2 CTYPE_BITMAP*/
        case MELTOBMAG_BITMAP:
            break;
        case MELTOBMAG_MAPBITMAPS:
        {
            struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entrybitmapmelt_st* newtab = ggc_alloc_vec_entrybitmapmelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entrybitmapmelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    bitmap at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPBITMAPS */
        break;
        /*gtyctype #3 CTYPE_EDGE*/
        case MELTOBMAG_EDGE:
            break;
        case MELTOBMAG_MAPEDGES:
        {
            struct meltmapedges_st *src = (struct meltmapedges_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entryedgemelt_st* newtab = ggc_alloc_vec_entryedgemelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entryedgemelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    edge at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPEDGES */
        break;
        /*gtyctype #4 CTYPE_GIMPLE*/
        case MELTOBMAG_GIMPLE:
            break;
        case MELTOBMAG_MAPGIMPLES:
        {
            struct meltmapgimples_st *src = (struct meltmapgimples_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entrygimplemelt_st* newtab = ggc_alloc_vec_entrygimplemelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entrygimplemelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    gimple at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPGIMPLES */
        break;
        /*gtyctype #5 CTYPE_GIMPLE_SEQ*/
        case MELTOBMAG_GIMPLESEQ:
            break;
        case MELTOBMAG_MAPGIMPLESEQS:
        {
            struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entrygimpleseqmelt_st* newtab = ggc_alloc_vec_entrygimpleseqmelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entrygimpleseqmelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    gimple_seq at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPGIMPLESEQS */
        break;
        /*gtyctype #6 CTYPE_LOOP*/
        case MELTOBMAG_LOOP:
            break;
        case MELTOBMAG_MAPLOOPS:
        {
            struct meltmaploops_st *src = (struct meltmaploops_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entryloopmelt_st* newtab = ggc_alloc_vec_entryloopmelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entryloopmelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    loop_p at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPLOOPS */
        break;
        /*gtyctype #7 CTYPE_RTVEC*/
        case MELTOBMAG_RTVEC:
            break;
        case MELTOBMAG_MAPRTVECS:
        {
            struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entryrtvecmelt_st* newtab = ggc_alloc_vec_entryrtvecmelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entryrtvecmelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    rtvec at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPRTVECS */
        break;
        /*gtyctype #8 CTYPE_RTX*/
        case MELTOBMAG_RTX:
            break;
        case MELTOBMAG_MAPRTXS:
        {
            struct meltmaprtxs_st *src = (struct meltmaprtxs_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entryrtxmelt_st* newtab = ggc_alloc_vec_entryrtxmelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entryrtxmelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    rtx at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPRTXS */
        break;
        /*gtyctype #9 CTYPE_TREE*/
        case MELTOBMAG_TREE:
            break;
        case MELTOBMAG_MAPTREES:
        {
            struct meltmaptrees_st *src = (struct meltmaptrees_st*) p;
            int siz=0, ix=0;
            MELT_FORWARDED(src->meltmap_aux);
            if (!src->entab) break;
            siz = melt_primtab[src->lenix];
            gcc_assert (siz>0);
            if (melt_is_young (src->entab))
                {
                    struct entrytreemelt_st* newtab = ggc_alloc_vec_entrytreemelt_st (siz);
                    memcpy (newtab, src->entab, siz * sizeof (struct entrytreemelt_st));
                    src->entab = newtab;
                } /*end if young entab */
            for (ix = 0; ix < siz; ix++)
                {
                    tree at = src->entab[ix].e_at;
                    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY)
                        {
                            src->entab[ix].e_va = NULL;
                            continue;
                        } /*end if empty at */
                    MELT_FORWARDED (src->entab[ix].e_va);
                } /*end for ix*/
            };    /* end case MELTOBMAG_MAPTREES */
        break;
        /* trailer generated by generate_runtypesupport_scanning */
        default:
            /* gcc_unreachable (); */
            fatal_error ("melt melt_scanning GC: corrupted heap, p=%p omagic=%d\n",
                         (void *) p, (int) omagic);
        }
} /* end of melt_scanning generated by generate_runtypesupport_scanning */

/**end of code generated by generate_runtypesupport_scanning **/


/** start of code generated by generate_runtypesupport_boxingfun **/
/*gtyctype #1 CTYPE_BASIC_BLOCK*/

melt_ptr_t
meltgc_new_basicblock(meltobject_ptr_t discr_p, basic_block val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_BASIC_BLOCK);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_BASICBLOCK) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct meltbasicblock_st), 0);
    ((struct meltbasicblock_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct meltbasicblock_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_basicblock */

void
meltgc_basicblock_updatebox(melt_ptr_t box_p, basic_block val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_BASICBLOCK) goto end;
    if (((melt_ptr_t) boxv)->u_discr
            /* generated updatebox nonconst */
            == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_BASIC_BLOCK))
        goto end ;
    ((struct meltbasicblock_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun meltgc_basicblock_updatebox */

/*gtyctype #2 CTYPE_BITMAP*/

melt_ptr_t
meltgc_new_bitmap(meltobject_ptr_t discr_p, bitmap val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_BITMAP);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_BITMAP) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct meltbitmap_st), 0);
    ((struct meltbitmap_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct meltbitmap_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_bitmap */

void
meltgc_bitmap_updatebox(melt_ptr_t box_p, bitmap val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_BITMAP) goto end;
    ((struct meltbitmap_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun meltgc_bitmap_updatebox */

/*gtyctype #3 CTYPE_EDGE*/

melt_ptr_t
meltgc_new_edge(meltobject_ptr_t discr_p, edge val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_EDGE);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_EDGE) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct meltedge_st), 0);
    ((struct meltedge_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct meltedge_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_edge */

void
meltgc_edge_updatebox(melt_ptr_t box_p, edge val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_EDGE) goto end;
    if (((melt_ptr_t) boxv)->u_discr
            /* generated updatebox nonconst */
            == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_EDGE))
        goto end ;
    ((struct meltedge_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun meltgc_edge_updatebox */

/*gtyctype #4 CTYPE_GIMPLE*/

melt_ptr_t
meltgc_new_gimple(meltobject_ptr_t discr_p, gimple val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_GIMPLE);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_GIMPLE) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct meltgimple_st), 0);
    ((struct meltgimple_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct meltgimple_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_gimple */

void
meltgc_gimple_updatebox(melt_ptr_t box_p, gimple val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_GIMPLE) goto end;
    if (((melt_ptr_t) boxv)->u_discr
            /* generated updatebox nonconst */
            == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_GIMPLE))
        goto end ;
    ((struct meltgimple_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun meltgc_gimple_updatebox */

/*gtyctype #5 CTYPE_GIMPLE_SEQ*/

melt_ptr_t
meltgc_new_gimpleseq(meltobject_ptr_t discr_p, gimple_seq val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_GIMPLE_SEQ);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_GIMPLESEQ) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct meltgimpleseq_st), 0);
    ((struct meltgimpleseq_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct meltgimpleseq_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_gimpleseq */

void
meltgc_gimpleseq_updatebox(melt_ptr_t box_p, gimple_seq val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_GIMPLESEQ) goto end;
    if (((melt_ptr_t) boxv)->u_discr
            /* generated updatebox nonconst */
            == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_GIMPLE_SEQ))
        goto end ;
    ((struct meltgimpleseq_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun meltgc_gimpleseq_updatebox */

/*gtyctype #6 CTYPE_LOOP*/

melt_ptr_t
meltgc_new_loop(meltobject_ptr_t discr_p, loop_p val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_LOOP);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_LOOP) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct meltloop_st), 0);
    ((struct meltloop_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct meltloop_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_loop */

void
melt_loop_updatebox(melt_ptr_t box_p, loop_p val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_LOOP) goto end;
    if (((melt_ptr_t) boxv)->u_discr
            /* generated updatebox nonconst */
            == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_LOOP))
        goto end ;
    ((struct meltloop_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun melt_loop_updatebox */

/*gtyctype #7 CTYPE_RTVEC*/

melt_ptr_t
meltgc_new_rtvec(meltobject_ptr_t discr_p, rtvec val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_RTVEC);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_RTVEC) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct meltrtvec_st), 0);
    ((struct meltrtvec_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct meltrtvec_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_rtvec */

void
meltgc_rtvec_updatebox(melt_ptr_t box_p, rtvec val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_RTVEC) goto end;
    ((struct meltrtvec_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun meltgc_rtvec_updatebox */

/*gtyctype #8 CTYPE_RTX*/

melt_ptr_t
meltgc_new_rtx(meltobject_ptr_t discr_p, rtx val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_RTX);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_RTX) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct meltrtx_st), 0);
    ((struct meltrtx_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct meltrtx_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_rtx */

void
meltgc_rtx_updatebox(melt_ptr_t box_p, rtx val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_RTX) goto end;
    ((struct meltrtx_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun meltgc_rtx_updatebox */

/*gtyctype #9 CTYPE_TREE*/

melt_ptr_t
meltgc_new_tree(meltobject_ptr_t discr_p, tree val)   /*runtypesupport generated boxingfun*/
{
    MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
    discrv = (melt_ptr_t) discr_p;
    if (!discrv) discrv = MELT_PREDEF(DISCR_TREE);
    if (melt_magic_discr((melt_ptr_t)discrv) != MELTOBMAG_OBJECT) goto end;
    if (((meltobject_ptr_t)(discrv))->meltobj_magic != MELTOBMAG_TREE) goto end;
    resv = (melt_ptr_t) meltgc_allocate (sizeof (struct melttree_st), 0);
    ((struct melttree_st*) (resv))->discr = (meltobject_ptr_t)discrv;
    ((struct melttree_st*) (resv))->val = val;
end:
    MELT_EXITFRAME ();
    return ((melt_ptr_t)(resv));
#undef resv
#undef discrv
} /* end generated boxingfun meltgc_new_tree */

void
meltgc_tree_updatebox(melt_ptr_t box_p, tree val)   /*generated updateboxfun */
{
    MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
    boxv = box_p;
    if (melt_magic_discr((melt_ptr_t)boxv) != MELTOBMAG_TREE) goto end;
    if (((melt_ptr_t) boxv)->u_discr
            /* generated updatebox nonconst */
            == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_TREE))
        goto end ;
    ((struct melttree_st*) (boxv))->val = val;
    meltgc_touch ((melt_ptr_t)boxv);
end:
    MELT_EXITFRAME ();
#undef boxv
} /* end generated updateboxfun meltgc_tree_updatebox */


/** end of code generated by generate_runtypesupport_boxingfun **/



/** generated by generate_runtypesupport_cloning_fun **/
/* generated cloning routine head */
melt_ptr_t
meltgc_clone_with_discriminant (melt_ptr_t srcval_p, melt_ptr_t newdiscr_p)
{
    unsigned srcmagic = 0;
    unsigned newmagic = 0;
    MELT_ENTERFRAME (5, NULL);
#define resv       meltfram__.mcfr_varptr[0]
#define srcvalv    meltfram__.mcfr_varptr[1]
#define newdiscrv  meltfram__.mcfr_varptr[2]
#define srcdiscrv  meltfram__.mcfr_varptr[3]
#define compv      meltfram__.mcfr_varptr[4]
    srcvalv = srcval_p;
    newdiscrv = newdiscr_p;
    resv = srcvalv;
    if (!srcvalv)
        goto end;
    srcdiscrv = (melt_ptr_t) (((melt_ptr_t)srcvalv)->u_discr);
    if (!newdiscrv)
        newdiscrv = srcdiscrv;
    if (melt_magic_discr((melt_ptr_t)newdiscrv) != MELTOBMAG_OBJECT
            || ((meltobject_ptr_t)newdiscrv)->obj_len < MELTLENGTH_CLASS_DISCRIMINANT)
        goto end;
    if (!melt_is_instance_of((melt_ptr_t)newdiscrv,
                             MELT_PREDEF (CLASS_DISCRIMINANT)))
        goto end;
    srcmagic = melt_magic_discr ((melt_ptr_t)srcvalv);
    newmagic = ((meltobject_ptr_t)newdiscrv)->meltobj_magic;
    if (srcmagic != newmagic)
        goto end;
    switch (srcmagic)   /* end cloning heeader */
        {


        /*** cloning 9 GTY-ed ctypes ***/

        /*cloning gtyctype #1 CTYPE_BASIC_BLOCK */
        case MELTOBMAG_BASICBLOCK :   /* cloning boxed value CTYPE_BASIC_BLOCK */
        {
            struct meltbasicblock_st *src = (struct meltbasicblock_st *) srcvalv;
            struct meltbasicblock_st *dst = (struct meltbasicblock_st *) meltgc_allocate (sizeof(struct meltbasicblock_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPBASICBLOCKS :   /* cloning map value CTYPE_BASIC_BLOCK */
        {
            struct meltmapbasicblocks_st *src = (struct meltmapbasicblocks_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmapbasicblocks_st *dst =
            (struct meltmapbasicblocks_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        basic_block curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (basic_block) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;
        /*cloning gtyctype #2 CTYPE_BITMAP */
        case MELTOBMAG_BITMAP :   /* cloning boxed value CTYPE_BITMAP */
        {
            struct meltbitmap_st *src = (struct meltbitmap_st *) srcvalv;
            struct meltbitmap_st *dst = (struct meltbitmap_st *) meltgc_allocate (sizeof(struct meltbitmap_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPBITMAPS :   /* cloning map value CTYPE_BITMAP */
        {
            struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmapbitmaps_st *dst =
            (struct meltmapbitmaps_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        bitmap curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (bitmap) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;
        /*cloning gtyctype #3 CTYPE_EDGE */
        case MELTOBMAG_EDGE :   /* cloning boxed value CTYPE_EDGE */
        {
            struct meltedge_st *src = (struct meltedge_st *) srcvalv;
            struct meltedge_st *dst = (struct meltedge_st *) meltgc_allocate (sizeof(struct meltedge_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPEDGES :   /* cloning map value CTYPE_EDGE */
        {
            struct meltmapedges_st *src = (struct meltmapedges_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmapedges_st *dst =
            (struct meltmapedges_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        edge curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (edge) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;
        /*cloning gtyctype #4 CTYPE_GIMPLE */
        case MELTOBMAG_GIMPLE :   /* cloning boxed value CTYPE_GIMPLE */
        {
            struct meltgimple_st *src = (struct meltgimple_st *) srcvalv;
            struct meltgimple_st *dst = (struct meltgimple_st *) meltgc_allocate (sizeof(struct meltgimple_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPGIMPLES :   /* cloning map value CTYPE_GIMPLE */
        {
            struct meltmapgimples_st *src = (struct meltmapgimples_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmapgimples_st *dst =
            (struct meltmapgimples_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        gimple curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (gimple) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;
        /*cloning gtyctype #5 CTYPE_GIMPLE_SEQ */
        case MELTOBMAG_GIMPLESEQ :   /* cloning boxed value CTYPE_GIMPLE_SEQ */
        {
            struct meltgimpleseq_st *src = (struct meltgimpleseq_st *) srcvalv;
            struct meltgimpleseq_st *dst = (struct meltgimpleseq_st *) meltgc_allocate (sizeof(struct meltgimpleseq_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPGIMPLESEQS :   /* cloning map value CTYPE_GIMPLE_SEQ */
        {
            struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmapgimpleseqs_st *dst =
            (struct meltmapgimpleseqs_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        gimple_seq curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (gimple_seq) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;
        /*cloning gtyctype #6 CTYPE_LOOP */
        case MELTOBMAG_LOOP :   /* cloning boxed value CTYPE_LOOP */
        {
            struct meltloop_st *src = (struct meltloop_st *) srcvalv;
            struct meltloop_st *dst = (struct meltloop_st *) meltgc_allocate (sizeof(struct meltloop_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPLOOPS :   /* cloning map value CTYPE_LOOP */
        {
            struct meltmaploops_st *src = (struct meltmaploops_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmaploops_st *dst =
            (struct meltmaploops_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        loop_p curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (loop_p) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;
        /*cloning gtyctype #7 CTYPE_RTVEC */
        case MELTOBMAG_RTVEC :   /* cloning boxed value CTYPE_RTVEC */
        {
            struct meltrtvec_st *src = (struct meltrtvec_st *) srcvalv;
            struct meltrtvec_st *dst = (struct meltrtvec_st *) meltgc_allocate (sizeof(struct meltrtvec_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPRTVECS :   /* cloning map value CTYPE_RTVEC */
        {
            struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmaprtvecs_st *dst =
            (struct meltmaprtvecs_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        rtvec curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (rtvec) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;
        /*cloning gtyctype #8 CTYPE_RTX */
        case MELTOBMAG_RTX :   /* cloning boxed value CTYPE_RTX */
        {
            struct meltrtx_st *src = (struct meltrtx_st *) srcvalv;
            struct meltrtx_st *dst = (struct meltrtx_st *) meltgc_allocate (sizeof(struct meltrtx_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPRTXS :   /* cloning map value CTYPE_RTX */
        {
            struct meltmaprtxs_st *src = (struct meltmaprtxs_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmaprtxs_st *dst =
            (struct meltmaprtxs_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        rtx curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (rtx) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;
        /*cloning gtyctype #9 CTYPE_TREE */
        case MELTOBMAG_TREE :   /* cloning boxed value CTYPE_TREE */
        {
            struct melttree_st *src = (struct melttree_st *) srcvalv;
            struct melttree_st *dst = (struct melttree_st *) meltgc_allocate (sizeof(struct melttree_st), 0);

            *dst = *src;
            dst->discr = (meltobject_ptr_t) newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        case MELTOBMAG_MAPTREES :   /* cloning map value CTYPE_TREE */
        {
            struct meltmaptrees_st *src = (struct meltmaptrees_st *) srcvalv;
            unsigned oldlen =  melt_primtab[src->lenix];
            unsigned newlen = 4*src->count/3 + 5;
            struct meltmaptrees_st *dst =
            (struct meltmaptrees_st *) meltgc_raw_new_mappointers((meltobject_ptr_t)newdiscrv, newlen);
            unsigned ix = 0;
            dst->meltmap_aux = src->meltmap_aux;
            if (src->entab)
                for (ix=0; ix<oldlen;
                        ix++)
                    {
                        melt_ptr_t curva = src->entab[ix].e_va;
                        tree curat = src->entab[ix].e_at;
                        if (curva != NULL && curat != (tree) HTAB_DELETED_ENTRY)
                            meltgc_raw_put_mappointers((void*)dst, (const void*)curat, curva);
                    }
            resv = (melt_ptr_t) dst;
        };
        break;

        /******* cloning the 20 value descriptors *******/
        /** cloning value descriptor #1 VALDESC_BUCKETLONGS **/
        /*explicit cloning for VALDESC_BUCKETLONGS*/
        case MELTOBMAG_BUCKETLONGS:
        {
            struct meltbucketlongs_st *src = (struct meltbucketlongs_st*) srcvalv;
            struct meltbucketlongs_st *dst = NULL;
            /* clone chunk for VALDESC_BUCKETLONGS:*/
            /* cloning chunk  from VALDESC_BUCKETLONGS in warmelt-base.melt */
            unsigned lnix = src->buckl_lenix;
            unsigned len = melt_primtab[lnix];
            unsigned cnt = src->buckl_ucount;
            unsigned dstlen = 0;
            unsigned ix = 0;
            gcc_assert (lnix > 0);
            gcc_assert (len > 0);
            gcc_assert (cnt <= len);
            dst = (struct meltbucketlongs_st*)
                  meltgc_new_longsbucket ((meltobject_ptr_t)newdiscrv, cnt + cnt/8 + 2);
            resv = (melt_ptr_t) dst;
            dstlen = melt_primtab[dst->buckl_lenix];
            dst->buckl_aux = src->buckl_aux;
            dst->buckl_xnum = src->buckl_xnum;
            dst->buckl_lenix = src->buckl_lenix;
            for (ix = 0;
                    ix < cnt;
                    ix++)
                dst->buckl_entab[ix] = src->buckl_entab[ix];
            for (ix = cnt;
                    ix < dstlen;
                    ix++)
                {
                    dst->buckl_entab[ix].ebl_at = 0L;
                    dst->buckl_entab[ix].ebl_va = NULL;
                }
            /* end clone chunk VALDESC_BUCKETLONGS */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #2 VALDESC_CLOSURE **/
        /*explicit cloning for VALDESC_CLOSURE*/
        case MELTOBMAG_CLOSURE:
        {
            struct meltclosure_st *src = (struct meltclosure_st*) srcvalv;
            struct meltclosure_st *dst = NULL;
            /* clone chunk for VALDESC_CLOSURE:*/
            /* cloning from VALDESC_CLOSURE */
            unsigned nbval = (int) src->nbval;
            dst
                = (struct meltclosure_st*)meltgc_allocate (sizeof(struct meltclosure_st),
                        nbval*sizeof(void*));
            resv = (melt_ptr_t) dst;
            src = (struct meltclosure_st*)srcvalv;
            dst->discr = (meltobject_ptr_t)newdiscrv;
            dst->rout = src->rout;
            for (unsigned ix = 0;
                    ix < nbval;
                    ix++)
                dst->tabval[ix] = src->tabval[ix];
            /* end cloning from VALDESC_CLOSURE */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #3 VALDESC_DECAY **/
        /*default cloning for VALDESC_DECAY*/
        case MELTOBMAG_DECAY:
        {
            struct meltdecay_st *src = (struct meltdecay_st*) srcvalv;
            struct meltdecay_st *dst =
            (struct meltdecay_st*) meltgc_allocate (sizeof(struct meltdecay_st), 0);
            *dst = *src;
            dst->discr = (meltobject_ptr_t)newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        /** cloning value descriptor #4 VALDESC_HOOK **/
        /*no cloning for VALDESC_HOOK*/
        case MELTOBMAG_HOOK:
            break;
        /** cloning value descriptor #5 VALDESC_INT **/
        /*default cloning for VALDESC_INT*/
        case MELTOBMAG_INT:
        {
            struct meltint_st *src = (struct meltint_st*) srcvalv;
            struct meltint_st *dst =
            (struct meltint_st*) meltgc_allocate (sizeof(struct meltint_st), 0);
            *dst = *src;
            dst->discr = (meltobject_ptr_t)newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        /** cloning value descriptor #6 VALDESC_JSONOBJECT **/
        /*explicit cloning for VALDESC_JSONOBJECT*/
        case MELTOBMAG_JSONOBJECT:
        {
            struct meltjsonobject_st *src = (struct meltjsonobject_st*) srcvalv;
            struct meltjsonobject_st *dst = NULL;
            /* clone chunk for VALDESC_JSONOBJECT:*/
            /* cloning chunk from VALDESC_JSONOBJECT in warmelt-base.melt */
            unsigned srcsize = src->jsob_size;
            dst = (struct meltjsonobject_st*)meltgc_allocate(sizeof(struct meltjsonobject_st),
                    srcsize*sizeof(melt_jsonobentry_st));
            dst->discr = (meltobject_ptr_t)newdiscrv;
            dst->jsob_aux = src->jsob_aux;
            for (unsigned ix=0; ix<srcsize; ix++)
                dst->jsob_entab[ix] = src->jsob_entab[ix];
            /* end cloning chunk VALDESC_JSONOBJECT */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #7 VALDESC_LIST **/
        /*explicit cloning for VALDESC_LIST*/
        case MELTOBMAG_LIST:
        {
            struct meltlist_st *src = (struct meltlist_st*) srcvalv;
            struct meltlist_st *dst = NULL;
            /* clone chunk for VALDESC_LIST:*/
            /* cloning from VALDESC_LIST */
            struct meltpair_st* curpair = NULL;
            dst = (struct meltlist_st*) meltgc_new_list ((meltobject_ptr_t)newdiscrv);
            resv = (melt_ptr_t) dst;
            src = (struct meltlist_st*) srcvalv;
            for (curpair = ((struct meltlist_st *) src)->first;
                    melt_magic_discr ((melt_ptr_t) curpair) == MELTOBMAG_PAIR;
                    curpair = (struct meltpair_st *) (curpair->tl))
                {
                    src = (struct meltlist_st*) srcvalv;
                    dst = (struct meltlist_st*) resv;
                    compv = (melt_ptr_t) curpair;
                    meltgc_append_list ((melt_ptr_t) resv, curpair->hd);
                    /* copy, because GC might have moved values. */
                    curpair = (struct meltpair_st*) compv;
                    src = (struct meltlist_st*) srcvalv;
                    dst = (struct meltlist_st*) resv;
                }
            /* end cloning from VALDESC_LIST */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #8 VALDESC_MAPOBJECTS **/
        /*explicit cloning for VALDESC_MAPOBJECTS*/
        case MELTOBMAG_MAPOBJECTS:
        {
            struct meltmapobjects_st *src = (struct meltmapobjects_st*) srcvalv;
            struct meltmapobjects_st *dst = NULL;
            /* clone chunk for VALDESC_MAPOBJECTS:*/
            /* cloning, from VALDESC_MAPOBJECTS */
            unsigned srccount = src->count;
            unsigned srclen = melt_primtab[src->lenix];
            unsigned newlen = 4*srccount/3+4;
            dst = (struct meltmapobjects_st*)
                  meltgc_new_mapobjects ((meltobject_ptr_t)newdiscrv, newlen);
            resv = (melt_ptr_t) dst;
            dst->meltmap_aux = src->meltmap_aux;
            for (unsigned srcix = 0;
                    srcix < srclen;
                    srcix++)
                {
                    meltobject_ptr_t curat = NULL;
                    melt_ptr_t curva = NULL;
                    src = (struct meltmapobjects_st*) srcvalv;
                    curat = src->entab[srcix].e_at;
                    curva = src->entab[srcix].e_va;
                    if (!curat || curat == (meltobject_ptr_t) HTAB_DELETED_ENTRY
                            || !curva)
                        continue;
                    meltgc_put_mapobjects((meltmapobjects_ptr_t)resv, curat, curva);
                    /* update the dst, since it could have moved */
                    dst =  (struct meltmapobjects_st*) resv;
                } /* end cloning, from VALDESC_MAPOBJECTS */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #9 VALDESC_MAPSTRINGS **/
        /*explicit cloning for VALDESC_MAPSTRINGS*/
        case MELTOBMAG_MAPSTRINGS:
        {
            struct meltmapstrings_st *src = (struct meltmapstrings_st*) srcvalv;
            struct meltmapstrings_st *dst = NULL;
            /* clone chunk for VALDESC_MAPSTRINGS:*/
            /* cloning from VALDESC_MAPSTRINGS */
            unsigned srccount = src->count;
            unsigned srclen = melt_primtab[src->lenix];
            unsigned newlen = 4*srccount/3+4;
            dst = (struct meltmapstrings_st*) meltgc_new_mapstrings ((meltobject_ptr_t)newdiscrv, newlen);
            resv = (melt_ptr_t) dst;
            dst->meltmap_aux = src->meltmap_aux;
            for (unsigned srcix = 0;
                    srcix < srclen;
                    srcix++)
                {
                    const char* curat = NULL;
                    melt_ptr_t curva = NULL;
                    src = (struct meltmapstrings_st*) srcvalv;
                    dst = (struct meltmapstrings_st*) resv;
                    curat = src->entab[srcix].e_at;
                    if (!curat || curat == (const char*) HTAB_DELETED_ENTRY || !curat[0])
                        continue;
                    curva = src->entab[srcix].e_va;
                    if (!curva)
                        continue;
                    meltgc_put_mapstrings (dst, curat, curva);
                    dst = (struct meltmapstrings_st*) resv;
                }
            /* end  cloning from VALDESC_MAPSTRINGS */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #10 VALDESC_MIXBIGINT **/
        /*no cloning for VALDESC_MIXBIGINT*/
        case MELTOBMAG_MIXBIGINT:
            break;
        /** cloning value descriptor #11 VALDESC_MIXINT **/
        /*default cloning for VALDESC_MIXINT*/
        case MELTOBMAG_MIXINT:
        {
            struct meltmixint_st *src = (struct meltmixint_st*) srcvalv;
            struct meltmixint_st *dst =
            (struct meltmixint_st*) meltgc_allocate (sizeof(struct meltmixint_st), 0);
            *dst = *src;
            dst->discr = (meltobject_ptr_t)newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        /** cloning value descriptor #12 VALDESC_MIXLOC **/
        /*default cloning for VALDESC_MIXLOC*/
        case MELTOBMAG_MIXLOC:
        {
            struct meltmixloc_st *src = (struct meltmixloc_st*) srcvalv;
            struct meltmixloc_st *dst =
            (struct meltmixloc_st*) meltgc_allocate (sizeof(struct meltmixloc_st), 0);
            *dst = *src;
            dst->discr = (meltobject_ptr_t)newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        /** cloning value descriptor #13 VALDESC_MULTIPLE **/
        /*explicit cloning for VALDESC_MULTIPLE*/
        case MELTOBMAG_MULTIPLE:
        {
            struct meltmultiple_st *src = (struct meltmultiple_st*) srcvalv;
            struct meltmultiple_st *dst = NULL;
            /* clone chunk for VALDESC_MULTIPLE:*/
            /* cloning from VALDESC_MULTIPLE */
            unsigned srclen = src->nbval;
            dst =
                (struct meltmultiple_st*) meltgc_new_multiple ((meltobject_ptr_t)newdiscrv, srclen);
            resv = (melt_ptr_t) dst;
            src = (struct meltmultiple_st*) srcvalv; /* could have moved */
            for (unsigned srcix = 0;
                    srcix < srclen;
                    srcix++)
                dst->tabval[srcix] = src->tabval[srcix];
            /* end cloning from VALDESC_MULTIPLE */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #14 VALDESC_OBJECT **/
        /*explicit cloning for VALDESC_OBJECT*/
        case MELTOBMAG_OBJECT:
        {
            struct meltobject_st *src = (struct meltobject_st*) srcvalv;
            struct meltobject_st *dst = NULL;
            /* clone chunk for VALDESC_OBJECT:*/
            /* cloning, from VALDESC_OBJECT */
            unsigned newlen = 0;
            unsigned srclen = src->obj_len;
            unsigned slotix = 0;
            if (melt_is_subclass_of((meltobject_ptr_t)srcdiscrv,
                                    (meltobject_ptr_t)newdiscrv))
                {
                    newlen =
                        melt_multiple_length ((melt_ptr_t)
                                              (((meltobject_ptr_t)newdiscrv)->obj_vartab[MELTFIELD_CLASS_FIELDS]));
                    gcc_assert (newlen <= srclen);
                    dst =  meltgc_new_raw_object ((meltobject_ptr_t)newdiscrv, newlen);
                    for (slotix = 0;
                            slotix < newlen;
                            slotix++)
                        dst->obj_vartab[slotix] = src->obj_vartab[slotix];
                    dst->obj_num = src->obj_num;
                }
            else if (melt_is_subclass_of((meltobject_ptr_t)newdiscrv,
                                         (meltobject_ptr_t)srcdiscrv))
                {
                    newlen =
                        melt_multiple_length ((melt_ptr_t)
                                              (((meltobject_ptr_t)newdiscrv)->obj_vartab[MELTFIELD_CLASS_FIELDS]));
                    gcc_assert (newlen >= srclen);
                    dst =  meltgc_new_raw_object ((meltobject_ptr_t)newdiscrv, newlen);
                    for (slotix = 0;
                            slotix < srclen;
                            slotix++)
                        dst->obj_vartab[slotix] = src->obj_vartab[slotix];
                    dst->obj_num = src->obj_num;
                }
#if ENABLE_CHECKING
            /* for low level debugging with gdb, we may want to catch some clone operations */
            if (melt_alptr_1 && (void*) src == melt_alptr_1)
                melt_break_alptr_1 ("cloneobj src=alptr1");
            if (melt_alptr_2 && (void*) src == melt_alptr_2)
                melt_break_alptr_2 ("cloneobj src=alptr2");
            if (src->obj_hash == melt_objhash_1)
                melt_break_objhash_1("cloneobj src with objhash1");
            if (src->obj_hash == melt_objhash_2)
                melt_break_objhash_2("cloneobj src with objhash2");
#endif /* ENABLE_CHECKING */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #15 VALDESC_PAIR **/
        /*default cloning for VALDESC_PAIR*/
        case MELTOBMAG_PAIR:
        {
            struct meltpair_st *src = (struct meltpair_st*) srcvalv;
            struct meltpair_st *dst =
            (struct meltpair_st*) meltgc_allocate (sizeof(struct meltpair_st), 0);
            *dst = *src;
            dst->discr = (meltobject_ptr_t)newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        /** cloning value descriptor #16 VALDESC_REAL **/
        /*default cloning for VALDESC_REAL*/
        case MELTOBMAG_REAL:
        {
            struct meltreal_st *src = (struct meltreal_st*) srcvalv;
            struct meltreal_st *dst =
            (struct meltreal_st*) meltgc_allocate (sizeof(struct meltreal_st), 0);
            *dst = *src;
            dst->discr = (meltobject_ptr_t)newdiscrv;
            resv = (melt_ptr_t) dst;
        }
        break;
        /** cloning value descriptor #17 VALDESC_ROUTINE **/
        /*no cloning for VALDESC_ROUTINE*/
        case MELTOBMAG_ROUTINE:
            break;
        /** cloning value descriptor #18 VALDESC_SPECIAL_DATA **/
        /*no cloning for VALDESC_SPECIAL_DATA*/
        case MELTOBMAG_SPECIAL_DATA:
            break;
        /** cloning value descriptor #19 VALDESC_STRBUF **/
        /*explicit cloning for VALDESC_STRBUF*/
        case MELTOBMAG_STRBUF:
        {
            struct meltstrbuf_st *src = (struct meltstrbuf_st*) srcvalv;
            struct meltstrbuf_st *dst = NULL;
            /* clone chunk for VALDESC_STRBUF:*/
            /* clone chunk from VALDESC_STRBUF */
            dst = (struct meltstrbuf_st*)
                  meltgc_new_strbuf ((meltobject_ptr_t)newdiscrv, NULL);
            resv = (melt_ptr_t) dst;
            src = (struct meltstrbuf_st*)srcvalv;
            meltgc_add_strbuf ((melt_ptr_t) dst, melt_strbuf_str ((melt_ptr_t)src));
            /* end clone chunk from VALDESC_STRBUF */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;
        /** cloning value descriptor #20 VALDESC_STRING **/
        /*explicit cloning for VALDESC_STRING*/
        case MELTOBMAG_STRING:
        {
            struct meltstring_st *src = (struct meltstring_st*) srcvalv;
            struct meltstring_st *dst = NULL;
            /* clone chunk for VALDESC_STRING:*/
            /* clone from VALDESC_STRING  */
            dst = (struct meltstring_st*)
                  meltgc_new_stringdup ((meltobject_ptr_t)newdiscrv,
                                        src->val);
            resv = (melt_ptr_t) dst;
            /* end clone from VALDESC_STRING  */
            ;
            if (dst)
                resv = (melt_ptr_t) dst;
        };
        break;

        /* generated cloning routine trailer */
        default:
            ;
        } /*end switch srcmagic for cloning */
end:
    MELT_EXITFRAME();
    return (melt_ptr_t) resv;
}  /* end of generated meltgc_clone_with_discriminant */
#undef resv
#undef srcvalv
#undef newdiscrv
#undef discrv
#undef compv


/*code generated by generate_runtypesupport_predefined_hooks for 155 predefined */












































































































/*predefined hook definition HOOK_ALL_IPA_PASSES_END #108*/
void melthookproc_HOOK_ALL_IPA_PASSES_END()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_ALL_IPA_PASSES_END*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_ALL_IPA_PASSES_END);
    typedef void melthooksig_HOOK_ALL_IPA_PASSES_END_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_ALL_IPA_PASSES_END exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_ALL_IPA_PASSES_END is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_ALL_IPA_PASSES_END */
    melthooksig_HOOK_ALL_IPA_PASSES_END_t *melthookptr_HOOK_ALL_IPA_PASSES_END =
        reinterpret_cast <melthooksig_HOOK_ALL_IPA_PASSES_END_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_ALL_IPA_PASSES_END",
                   melthookptr_HOOK_ALL_IPA_PASSES_END);

    /* check predefhook HOOK_ALL_IPA_PASSES_END name */
    melt_assertmsg("check predefhook name HOOK_ALL_IPA_PASSES_END",
                   !strncmp (melthkp->hookname,
                             "HOOK_ALL_IPA_PASSES_END", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_ALL_IPA_PASSES_END) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_ALL_IPA_PASSES_END */



/*predefined hook definition HOOK_ALL_IPA_PASSES_START #109*/
void melthookproc_HOOK_ALL_IPA_PASSES_START()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_ALL_IPA_PASSES_START*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_ALL_IPA_PASSES_START);
    typedef void melthooksig_HOOK_ALL_IPA_PASSES_START_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_ALL_IPA_PASSES_START exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_ALL_IPA_PASSES_START is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_ALL_IPA_PASSES_START */
    melthooksig_HOOK_ALL_IPA_PASSES_START_t *melthookptr_HOOK_ALL_IPA_PASSES_START =
        reinterpret_cast <melthooksig_HOOK_ALL_IPA_PASSES_START_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_ALL_IPA_PASSES_START",
                   melthookptr_HOOK_ALL_IPA_PASSES_START);

    /* check predefhook HOOK_ALL_IPA_PASSES_START name */
    melt_assertmsg("check predefhook name HOOK_ALL_IPA_PASSES_START",
                   !strncmp (melthkp->hookname,
                             "HOOK_ALL_IPA_PASSES_START", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_ALL_IPA_PASSES_START) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_ALL_IPA_PASSES_START */



/*predefined hook definition HOOK_ALL_PASSES_END #110*/
void melthookproc_HOOK_ALL_PASSES_END()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_ALL_PASSES_END*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_ALL_PASSES_END);
    typedef void melthooksig_HOOK_ALL_PASSES_END_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_ALL_PASSES_END exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_ALL_PASSES_END is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_ALL_PASSES_END */
    melthooksig_HOOK_ALL_PASSES_END_t *melthookptr_HOOK_ALL_PASSES_END =
        reinterpret_cast <melthooksig_HOOK_ALL_PASSES_END_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_ALL_PASSES_END",
                   melthookptr_HOOK_ALL_PASSES_END);

    /* check predefhook HOOK_ALL_PASSES_END name */
    melt_assertmsg("check predefhook name HOOK_ALL_PASSES_END",
                   !strncmp (melthkp->hookname,
                             "HOOK_ALL_PASSES_END", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_ALL_PASSES_END) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_ALL_PASSES_END */



/*predefined hook definition HOOK_ALL_PASSES_START #111*/
void melthookproc_HOOK_ALL_PASSES_START()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_ALL_PASSES_START*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_ALL_PASSES_START);
    typedef void melthooksig_HOOK_ALL_PASSES_START_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_ALL_PASSES_START exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_ALL_PASSES_START is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_ALL_PASSES_START */
    melthooksig_HOOK_ALL_PASSES_START_t *melthookptr_HOOK_ALL_PASSES_START =
        reinterpret_cast <melthooksig_HOOK_ALL_PASSES_START_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_ALL_PASSES_START",
                   melthookptr_HOOK_ALL_PASSES_START);

    /* check predefhook HOOK_ALL_PASSES_START name */
    melt_assertmsg("check predefhook name HOOK_ALL_PASSES_START",
                   !strncmp (melthkp->hookname,
                             "HOOK_ALL_PASSES_START", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_ALL_PASSES_START) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_ALL_PASSES_START */



/*predefined hook definition HOOK_EARLY_GIMPLE_PASSES_END #112*/
void melthookproc_HOOK_EARLY_GIMPLE_PASSES_END()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_EARLY_GIMPLE_PASSES_END*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_EARLY_GIMPLE_PASSES_END);
    typedef void melthooksig_HOOK_EARLY_GIMPLE_PASSES_END_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_EARLY_GIMPLE_PASSES_END exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_EARLY_GIMPLE_PASSES_END is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_EARLY_GIMPLE_PASSES_END */
    melthooksig_HOOK_EARLY_GIMPLE_PASSES_END_t *melthookptr_HOOK_EARLY_GIMPLE_PASSES_END =
        reinterpret_cast <melthooksig_HOOK_EARLY_GIMPLE_PASSES_END_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_EARLY_GIMPLE_PASSES_END",
                   melthookptr_HOOK_EARLY_GIMPLE_PASSES_END);

    /* check predefhook HOOK_EARLY_GIMPLE_PASSES_END name */
    melt_assertmsg("check predefhook name HOOK_EARLY_GIMPLE_PASSES_END",
                   !strncmp (melthkp->hookname,
                             "HOOK_EARLY_GIMPLE_PASSES_END", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_EARLY_GIMPLE_PASSES_END) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_EARLY_GIMPLE_PASSES_END */



/*predefined hook definition HOOK_EARLY_GIMPLE_PASSES_START #113*/
void melthookproc_HOOK_EARLY_GIMPLE_PASSES_START()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_EARLY_GIMPLE_PASSES_START*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_EARLY_GIMPLE_PASSES_START);
    typedef void melthooksig_HOOK_EARLY_GIMPLE_PASSES_START_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_EARLY_GIMPLE_PASSES_START exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_EARLY_GIMPLE_PASSES_START is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_EARLY_GIMPLE_PASSES_START */
    melthooksig_HOOK_EARLY_GIMPLE_PASSES_START_t *melthookptr_HOOK_EARLY_GIMPLE_PASSES_START =
        reinterpret_cast <melthooksig_HOOK_EARLY_GIMPLE_PASSES_START_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_EARLY_GIMPLE_PASSES_START",
                   melthookptr_HOOK_EARLY_GIMPLE_PASSES_START);

    /* check predefhook HOOK_EARLY_GIMPLE_PASSES_START name */
    melt_assertmsg("check predefhook name HOOK_EARLY_GIMPLE_PASSES_START",
                   !strncmp (melthkp->hookname,
                             "HOOK_EARLY_GIMPLE_PASSES_START", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_EARLY_GIMPLE_PASSES_START) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_EARLY_GIMPLE_PASSES_START */



/*predefined hook definition HOOK_EXIT_FINALIZER #114*/
void melthookproc_HOOK_EXIT_FINALIZER()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_EXIT_FINALIZER*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_EXIT_FINALIZER);
    typedef void melthooksig_HOOK_EXIT_FINALIZER_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_EXIT_FINALIZER exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_EXIT_FINALIZER is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_EXIT_FINALIZER */
    melthooksig_HOOK_EXIT_FINALIZER_t *melthookptr_HOOK_EXIT_FINALIZER =
        reinterpret_cast <melthooksig_HOOK_EXIT_FINALIZER_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_EXIT_FINALIZER",
                   melthookptr_HOOK_EXIT_FINALIZER);

    /* check predefhook HOOK_EXIT_FINALIZER name */
    melt_assertmsg("check predefhook name HOOK_EXIT_FINALIZER",
                   !strncmp (melthkp->hookname,
                             "HOOK_EXIT_FINALIZER", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_EXIT_FINALIZER) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_EXIT_FINALIZER */



/*predefined hook definition HOOK_FINISH_DECL #115*/
void melthookproc_HOOK_FINISH_DECL(tree meltin_TFNDECL_p0)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_FINISH_DECL*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_FINISH_DECL);
    typedef void melthooksig_HOOK_FINISH_DECL_t (melt_ptr_t, tree);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_FINISH_DECL exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_FINISH_DECL is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_FINISH_DECL */
    melthooksig_HOOK_FINISH_DECL_t *melthookptr_HOOK_FINISH_DECL =
        reinterpret_cast <melthooksig_HOOK_FINISH_DECL_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_FINISH_DECL",
                   melthookptr_HOOK_FINISH_DECL);

    /* check predefhook HOOK_FINISH_DECL name */
    melt_assertmsg("check predefhook name HOOK_FINISH_DECL",
                   !strncmp (melthkp->hookname,
                             "HOOK_FINISH_DECL", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_FINISH_DECL) ((melt_ptr_t)melthkp,
                                            meltin_TFNDECL_p0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_FINISH_DECL */



/*predefined hook definition HOOK_FINISH_TYPE #116*/
void melthookproc_HOOK_FINISH_TYPE(tree meltin_TFNDECL_p0)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_FINISH_TYPE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_FINISH_TYPE);
    typedef void melthooksig_HOOK_FINISH_TYPE_t (melt_ptr_t, tree);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_FINISH_TYPE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_FINISH_TYPE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_FINISH_TYPE */
    melthooksig_HOOK_FINISH_TYPE_t *melthookptr_HOOK_FINISH_TYPE =
        reinterpret_cast <melthooksig_HOOK_FINISH_TYPE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_FINISH_TYPE",
                   melthookptr_HOOK_FINISH_TYPE);

    /* check predefhook HOOK_FINISH_TYPE name */
    melt_assertmsg("check predefhook name HOOK_FINISH_TYPE",
                   !strncmp (melthkp->hookname,
                             "HOOK_FINISH_TYPE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_FINISH_TYPE) ((melt_ptr_t)melthkp,
                                            meltin_TFNDECL_p0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_FINISH_TYPE */



/*predefined hook definition HOOK_FINISH_UNIT #117*/
void melthookproc_HOOK_FINISH_UNIT()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_FINISH_UNIT*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_FINISH_UNIT);
    typedef void melthooksig_HOOK_FINISH_UNIT_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_FINISH_UNIT exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_FINISH_UNIT is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_FINISH_UNIT */
    melthooksig_HOOK_FINISH_UNIT_t *melthookptr_HOOK_FINISH_UNIT =
        reinterpret_cast <melthooksig_HOOK_FINISH_UNIT_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_FINISH_UNIT",
                   melthookptr_HOOK_FINISH_UNIT);

    /* check predefhook HOOK_FINISH_UNIT name */
    melt_assertmsg("check predefhook name HOOK_FINISH_UNIT",
                   !strncmp (melthkp->hookname,
                             "HOOK_FINISH_UNIT", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_FINISH_UNIT) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_FINISH_UNIT */



/*predefined hook definition HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER #118*/
melt_ptr_t melthookproc_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER(melt_ptr_t meltin_PREVENV_p0, const char* meltin_MODULNAME_p1)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER);
    typedef melt_ptr_t melthooksig_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER_t (melt_ptr_t, melt_ptr_t, const char*);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER */
    melthooksig_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER_t *melthookptr_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER =
        reinterpret_cast <melthooksig_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER",
                   melthookptr_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER);

    /* check predefhook HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER name */
    melt_assertmsg("check predefhook name HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER",
                   !strncmp (melthkp->hookname,
                             "HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER) ((melt_ptr_t)melthkp,
            meltin_PREVENV_p0,
            meltin_MODULNAME_p1);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER */



/*predefined hook definition HOOK_GIMPLE_EXECUTE #119*/
long melthookproc_HOOK_GIMPLE_EXECUTE()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_GIMPLE_EXECUTE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_GIMPLE_EXECUTE);
    typedef long melthooksig_HOOK_GIMPLE_EXECUTE_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_GIMPLE_EXECUTE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_GIMPLE_EXECUTE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_GIMPLE_EXECUTE */
    melthooksig_HOOK_GIMPLE_EXECUTE_t *melthookptr_HOOK_GIMPLE_EXECUTE =
        reinterpret_cast <melthooksig_HOOK_GIMPLE_EXECUTE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_GIMPLE_EXECUTE",
                   melthookptr_HOOK_GIMPLE_EXECUTE);

    /* check predefhook HOOK_GIMPLE_EXECUTE name */
    melt_assertmsg("check predefhook name HOOK_GIMPLE_EXECUTE",
                   !strncmp (melthkp->hookname,
                             "HOOK_GIMPLE_EXECUTE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_GIMPLE_EXECUTE) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_GIMPLE_EXECUTE */



/*predefined hook definition HOOK_GIMPLE_GATE #120*/
long melthookproc_HOOK_GIMPLE_GATE()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_GIMPLE_GATE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_GIMPLE_GATE);
    typedef long melthooksig_HOOK_GIMPLE_GATE_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_GIMPLE_GATE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_GIMPLE_GATE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_GIMPLE_GATE */
    melthooksig_HOOK_GIMPLE_GATE_t *melthookptr_HOOK_GIMPLE_GATE =
        reinterpret_cast <melthooksig_HOOK_GIMPLE_GATE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_GIMPLE_GATE",
                   melthookptr_HOOK_GIMPLE_GATE);

    /* check predefhook HOOK_GIMPLE_GATE name */
    melt_assertmsg("check predefhook name HOOK_GIMPLE_GATE",
                   !strncmp (melthkp->hookname,
                             "HOOK_GIMPLE_GATE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_GIMPLE_GATE) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_GIMPLE_GATE */



/*predefined hook definition HOOK_HANDLE_SIGALRM #121*/
void melthookproc_HOOK_HANDLE_SIGALRM()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_HANDLE_SIGALRM*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_HANDLE_SIGALRM);
    typedef void melthooksig_HOOK_HANDLE_SIGALRM_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_HANDLE_SIGALRM exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_HANDLE_SIGALRM is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_HANDLE_SIGALRM */
    melthooksig_HOOK_HANDLE_SIGALRM_t *melthookptr_HOOK_HANDLE_SIGALRM =
        reinterpret_cast <melthooksig_HOOK_HANDLE_SIGALRM_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_HANDLE_SIGALRM",
                   melthookptr_HOOK_HANDLE_SIGALRM);

    /* check predefhook HOOK_HANDLE_SIGALRM name */
    melt_assertmsg("check predefhook name HOOK_HANDLE_SIGALRM",
                   !strncmp (melthkp->hookname,
                             "HOOK_HANDLE_SIGALRM", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_HANDLE_SIGALRM) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_HANDLE_SIGALRM */



/*predefined hook definition HOOK_HANDLE_SIGCHLD #122*/
void melthookproc_HOOK_HANDLE_SIGCHLD()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_HANDLE_SIGCHLD*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_HANDLE_SIGCHLD);
    typedef void melthooksig_HOOK_HANDLE_SIGCHLD_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_HANDLE_SIGCHLD exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_HANDLE_SIGCHLD is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_HANDLE_SIGCHLD */
    melthooksig_HOOK_HANDLE_SIGCHLD_t *melthookptr_HOOK_HANDLE_SIGCHLD =
        reinterpret_cast <melthooksig_HOOK_HANDLE_SIGCHLD_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_HANDLE_SIGCHLD",
                   melthookptr_HOOK_HANDLE_SIGCHLD);

    /* check predefhook HOOK_HANDLE_SIGCHLD name */
    melt_assertmsg("check predefhook name HOOK_HANDLE_SIGCHLD",
                   !strncmp (melthkp->hookname,
                             "HOOK_HANDLE_SIGCHLD", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_HANDLE_SIGCHLD) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_HANDLE_SIGCHLD */



/*predefined hook definition HOOK_HANDLE_SIGIO #123*/
void melthookproc_HOOK_HANDLE_SIGIO()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_HANDLE_SIGIO*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_HANDLE_SIGIO);
    typedef void melthooksig_HOOK_HANDLE_SIGIO_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_HANDLE_SIGIO exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_HANDLE_SIGIO is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_HANDLE_SIGIO */
    melthooksig_HOOK_HANDLE_SIGIO_t *melthookptr_HOOK_HANDLE_SIGIO =
        reinterpret_cast <melthooksig_HOOK_HANDLE_SIGIO_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_HANDLE_SIGIO",
                   melthookptr_HOOK_HANDLE_SIGIO);

    /* check predefhook HOOK_HANDLE_SIGIO name */
    melt_assertmsg("check predefhook name HOOK_HANDLE_SIGIO",
                   !strncmp (melthkp->hookname,
                             "HOOK_HANDLE_SIGIO", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_HANDLE_SIGIO) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_HANDLE_SIGIO */



/*predefined hook definition HOOK_INTERN_KEYWORD #124*/
melt_ptr_t melthookproc_HOOK_INTERN_KEYWORD(melt_ptr_t meltin_KEYWV_p0)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_INTERN_KEYWORD*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_INTERN_KEYWORD);
    typedef melt_ptr_t melthooksig_HOOK_INTERN_KEYWORD_t (melt_ptr_t, melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_INTERN_KEYWORD exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_INTERN_KEYWORD is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_INTERN_KEYWORD */
    melthooksig_HOOK_INTERN_KEYWORD_t *melthookptr_HOOK_INTERN_KEYWORD =
        reinterpret_cast <melthooksig_HOOK_INTERN_KEYWORD_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_INTERN_KEYWORD",
                   melthookptr_HOOK_INTERN_KEYWORD);

    /* check predefhook HOOK_INTERN_KEYWORD name */
    melt_assertmsg("check predefhook name HOOK_INTERN_KEYWORD",
                   !strncmp (melthkp->hookname,
                             "HOOK_INTERN_KEYWORD", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_INTERN_KEYWORD) ((melt_ptr_t)melthkp,
            meltin_KEYWV_p0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_INTERN_KEYWORD */



/*predefined hook definition HOOK_INTERN_SYMBOL #125*/
melt_ptr_t melthookproc_HOOK_INTERN_SYMBOL(melt_ptr_t meltin_SYMBV_p0)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_INTERN_SYMBOL*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_INTERN_SYMBOL);
    typedef melt_ptr_t melthooksig_HOOK_INTERN_SYMBOL_t (melt_ptr_t, melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_INTERN_SYMBOL exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_INTERN_SYMBOL is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_INTERN_SYMBOL */
    melthooksig_HOOK_INTERN_SYMBOL_t *melthookptr_HOOK_INTERN_SYMBOL =
        reinterpret_cast <melthooksig_HOOK_INTERN_SYMBOL_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_INTERN_SYMBOL",
                   melthookptr_HOOK_INTERN_SYMBOL);

    /* check predefhook HOOK_INTERN_SYMBOL name */
    melt_assertmsg("check predefhook name HOOK_INTERN_SYMBOL",
                   !strncmp (melthkp->hookname,
                             "HOOK_INTERN_SYMBOL", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_INTERN_SYMBOL) ((melt_ptr_t)melthkp,
            meltin_SYMBV_p0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_INTERN_SYMBOL */



/*predefined hook definition HOOK_LOW_DEBUG_VALUE_AT #126*/
void melthookproc_HOOK_LOW_DEBUG_VALUE_AT(melt_ptr_t meltin_VAL_p0, const char* meltin_FILENAME_p1, long meltin_LINENO_p2, const char* meltin_MSG_p3, long meltin_COUNT_p4)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_LOW_DEBUG_VALUE_AT*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_LOW_DEBUG_VALUE_AT);
    typedef void melthooksig_HOOK_LOW_DEBUG_VALUE_AT_t (melt_ptr_t, melt_ptr_t, const char*, long, const char*, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_LOW_DEBUG_VALUE_AT exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_LOW_DEBUG_VALUE_AT is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_LOW_DEBUG_VALUE_AT */
    melthooksig_HOOK_LOW_DEBUG_VALUE_AT_t *melthookptr_HOOK_LOW_DEBUG_VALUE_AT =
        reinterpret_cast <melthooksig_HOOK_LOW_DEBUG_VALUE_AT_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_LOW_DEBUG_VALUE_AT",
                   melthookptr_HOOK_LOW_DEBUG_VALUE_AT);

    /* check predefhook HOOK_LOW_DEBUG_VALUE_AT name */
    melt_assertmsg("check predefhook name HOOK_LOW_DEBUG_VALUE_AT",
                   !strncmp (melthkp->hookname,
                             "HOOK_LOW_DEBUG_VALUE_AT", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_LOW_DEBUG_VALUE_AT) ((melt_ptr_t)melthkp,
            meltin_VAL_p0,
            meltin_FILENAME_p1,
            meltin_LINENO_p2,
            meltin_MSG_p3,
            meltin_COUNT_p4);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_LOW_DEBUG_VALUE_AT */



/*predefined hook definition HOOK_LOW_STDERR_VALUE_AT #127*/
void melthookproc_HOOK_LOW_STDERR_VALUE_AT(melt_ptr_t meltin_VAL_p0, const char* meltin_FILENAME_p1, long meltin_LINENO_p2, const char* meltin_MSG_p3, long meltin_COUNT_p4)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_LOW_STDERR_VALUE_AT*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_LOW_STDERR_VALUE_AT);
    typedef void melthooksig_HOOK_LOW_STDERR_VALUE_AT_t (melt_ptr_t, melt_ptr_t, const char*, long, const char*, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_LOW_STDERR_VALUE_AT exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_LOW_STDERR_VALUE_AT is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_LOW_STDERR_VALUE_AT */
    melthooksig_HOOK_LOW_STDERR_VALUE_AT_t *melthookptr_HOOK_LOW_STDERR_VALUE_AT =
        reinterpret_cast <melthooksig_HOOK_LOW_STDERR_VALUE_AT_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_LOW_STDERR_VALUE_AT",
                   melthookptr_HOOK_LOW_STDERR_VALUE_AT);

    /* check predefhook HOOK_LOW_STDERR_VALUE_AT name */
    melt_assertmsg("check predefhook name HOOK_LOW_STDERR_VALUE_AT",
                   !strncmp (melthkp->hookname,
                             "HOOK_LOW_STDERR_VALUE_AT", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_LOW_STDERR_VALUE_AT) ((melt_ptr_t)melthkp,
            meltin_VAL_p0,
            meltin_FILENAME_p1,
            meltin_LINENO_p2,
            meltin_MSG_p3,
            meltin_COUNT_p4);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_LOW_STDERR_VALUE_AT */



/*predefined hook definition HOOK_MACRO_EXPORTER #128*/
void melthookproc_HOOK_MACRO_EXPORTER(melt_ptr_t meltin_SYM_p0, melt_ptr_t meltin_VAL_p1, melt_ptr_t meltin_CONTENV_p2)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_MACRO_EXPORTER*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_MACRO_EXPORTER);
    typedef void melthooksig_HOOK_MACRO_EXPORTER_t (melt_ptr_t, melt_ptr_t, melt_ptr_t, melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_MACRO_EXPORTER exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_MACRO_EXPORTER is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_MACRO_EXPORTER */
    melthooksig_HOOK_MACRO_EXPORTER_t *melthookptr_HOOK_MACRO_EXPORTER =
        reinterpret_cast <melthooksig_HOOK_MACRO_EXPORTER_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_MACRO_EXPORTER",
                   melthookptr_HOOK_MACRO_EXPORTER);

    /* check predefhook HOOK_MACRO_EXPORTER name */
    melt_assertmsg("check predefhook name HOOK_MACRO_EXPORTER",
                   !strncmp (melthkp->hookname,
                             "HOOK_MACRO_EXPORTER", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_MACRO_EXPORTER) ((melt_ptr_t)melthkp,
            meltin_SYM_p0,
            meltin_VAL_p1,
            meltin_CONTENV_p2);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_MACRO_EXPORTER */



/*predefined hook definition HOOK_MACRO_INSTALLER #129*/
void melthookproc_HOOK_MACRO_INSTALLER(melt_ptr_t meltin_MBIND_p0, melt_ptr_t meltin_MEXPCLOS_p1)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_MACRO_INSTALLER*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_MACRO_INSTALLER);
    typedef void melthooksig_HOOK_MACRO_INSTALLER_t (melt_ptr_t, melt_ptr_t, melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_MACRO_INSTALLER exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_MACRO_INSTALLER is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_MACRO_INSTALLER */
    melthooksig_HOOK_MACRO_INSTALLER_t *melthookptr_HOOK_MACRO_INSTALLER =
        reinterpret_cast <melthooksig_HOOK_MACRO_INSTALLER_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_MACRO_INSTALLER",
                   melthookptr_HOOK_MACRO_INSTALLER);

    /* check predefhook HOOK_MACRO_INSTALLER name */
    melt_assertmsg("check predefhook name HOOK_MACRO_INSTALLER",
                   !strncmp (melthkp->hookname,
                             "HOOK_MACRO_INSTALLER", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_MACRO_INSTALLER) ((melt_ptr_t)melthkp,
            meltin_MBIND_p0,
            meltin_MEXPCLOS_p1);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_MACRO_INSTALLER */



/*predefined hook definition HOOK_MELT_ATTRIBUTE_DEFINER #130*/
void melthookproc_HOOK_MELT_ATTRIBUTE_DEFINER(tree meltin_DECL_p0, tree meltin_NAME_p1, melt_ptr_t meltin_ATTRSEQ_p2, const char* meltin_FILELOC_p3, long meltin_LINENO_p4)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_MELT_ATTRIBUTE_DEFINER*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_MELT_ATTRIBUTE_DEFINER);
    typedef void melthooksig_HOOK_MELT_ATTRIBUTE_DEFINER_t (melt_ptr_t, tree, tree, melt_ptr_t, const char*, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_MELT_ATTRIBUTE_DEFINER exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_MELT_ATTRIBUTE_DEFINER is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_MELT_ATTRIBUTE_DEFINER */
    melthooksig_HOOK_MELT_ATTRIBUTE_DEFINER_t *melthookptr_HOOK_MELT_ATTRIBUTE_DEFINER =
        reinterpret_cast <melthooksig_HOOK_MELT_ATTRIBUTE_DEFINER_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_MELT_ATTRIBUTE_DEFINER",
                   melthookptr_HOOK_MELT_ATTRIBUTE_DEFINER);

    /* check predefhook HOOK_MELT_ATTRIBUTE_DEFINER name */
    melt_assertmsg("check predefhook name HOOK_MELT_ATTRIBUTE_DEFINER",
                   !strncmp (melthkp->hookname,
                             "HOOK_MELT_ATTRIBUTE_DEFINER", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_MELT_ATTRIBUTE_DEFINER) ((melt_ptr_t)melthkp,
            meltin_DECL_p0,
            meltin_NAME_p1,
            meltin_ATTRSEQ_p2,
            meltin_FILELOC_p3,
            meltin_LINENO_p4);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_MELT_ATTRIBUTE_DEFINER */



/*predefined hook definition HOOK_MELT_DO_INITIAL_MODE #131*/
void melthookproc_HOOK_MELT_DO_INITIAL_MODE(melt_ptr_t meltin_MODATA_p0, const char* meltin_MODSTR_p1)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_MELT_DO_INITIAL_MODE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_MELT_DO_INITIAL_MODE);
    typedef void melthooksig_HOOK_MELT_DO_INITIAL_MODE_t (melt_ptr_t, melt_ptr_t, const char*);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_MELT_DO_INITIAL_MODE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_MELT_DO_INITIAL_MODE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_MELT_DO_INITIAL_MODE */
    melthooksig_HOOK_MELT_DO_INITIAL_MODE_t *melthookptr_HOOK_MELT_DO_INITIAL_MODE =
        reinterpret_cast <melthooksig_HOOK_MELT_DO_INITIAL_MODE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_MELT_DO_INITIAL_MODE",
                   melthookptr_HOOK_MELT_DO_INITIAL_MODE);

    /* check predefhook HOOK_MELT_DO_INITIAL_MODE name */
    melt_assertmsg("check predefhook name HOOK_MELT_DO_INITIAL_MODE",
                   !strncmp (melthkp->hookname,
                             "HOOK_MELT_DO_INITIAL_MODE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_MELT_DO_INITIAL_MODE) ((melt_ptr_t)melthkp,
            meltin_MODATA_p0,
            meltin_MODSTR_p1);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_MELT_DO_INITIAL_MODE */



/*predefined hook definition HOOK_MELT_MAKE_LOCATION #132*/
melt_ptr_t melthookproc_HOOK_MELT_MAKE_LOCATION(const char* meltin_FILENAME_p0, long meltin_LINENO_p1)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_MELT_MAKE_LOCATION*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_MELT_MAKE_LOCATION);
    typedef melt_ptr_t melthooksig_HOOK_MELT_MAKE_LOCATION_t (melt_ptr_t, const char*, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_MELT_MAKE_LOCATION exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_MELT_MAKE_LOCATION is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_MELT_MAKE_LOCATION */
    melthooksig_HOOK_MELT_MAKE_LOCATION_t *melthookptr_HOOK_MELT_MAKE_LOCATION =
        reinterpret_cast <melthooksig_HOOK_MELT_MAKE_LOCATION_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_MELT_MAKE_LOCATION",
                   melthookptr_HOOK_MELT_MAKE_LOCATION);

    /* check predefhook HOOK_MELT_MAKE_LOCATION name */
    melt_assertmsg("check predefhook name HOOK_MELT_MAKE_LOCATION",
                   !strncmp (melthkp->hookname,
                             "HOOK_MELT_MAKE_LOCATION", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_MELT_MAKE_LOCATION) ((melt_ptr_t)melthkp,
            meltin_FILENAME_p0,
            meltin_LINENO_p1);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_MELT_MAKE_LOCATION */



/*predefined hook definition HOOK_NAMED_KEYWORD #133*/
melt_ptr_t melthookproc_HOOK_NAMED_KEYWORD(const char* meltin_NAM_p0, long meltin_CREATE_p1)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_NAMED_KEYWORD*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_NAMED_KEYWORD);
    typedef melt_ptr_t melthooksig_HOOK_NAMED_KEYWORD_t (melt_ptr_t, const char*, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_NAMED_KEYWORD exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_NAMED_KEYWORD is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_NAMED_KEYWORD */
    melthooksig_HOOK_NAMED_KEYWORD_t *melthookptr_HOOK_NAMED_KEYWORD =
        reinterpret_cast <melthooksig_HOOK_NAMED_KEYWORD_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_NAMED_KEYWORD",
                   melthookptr_HOOK_NAMED_KEYWORD);

    /* check predefhook HOOK_NAMED_KEYWORD name */
    melt_assertmsg("check predefhook name HOOK_NAMED_KEYWORD",
                   !strncmp (melthkp->hookname,
                             "HOOK_NAMED_KEYWORD", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_NAMED_KEYWORD) ((melt_ptr_t)melthkp,
            meltin_NAM_p0,
            meltin_CREATE_p1);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_NAMED_KEYWORD */



/*predefined hook definition HOOK_NAMED_SYMBOL #134*/
melt_ptr_t melthookproc_HOOK_NAMED_SYMBOL(const char* meltin_NAM_p0, long meltin_CREATE_p1)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_NAMED_SYMBOL*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_NAMED_SYMBOL);
    typedef melt_ptr_t melthooksig_HOOK_NAMED_SYMBOL_t (melt_ptr_t, const char*, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_NAMED_SYMBOL exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_NAMED_SYMBOL is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_NAMED_SYMBOL */
    melthooksig_HOOK_NAMED_SYMBOL_t *melthookptr_HOOK_NAMED_SYMBOL =
        reinterpret_cast <melthooksig_HOOK_NAMED_SYMBOL_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_NAMED_SYMBOL",
                   melthookptr_HOOK_NAMED_SYMBOL);

    /* check predefhook HOOK_NAMED_SYMBOL name */
    melt_assertmsg("check predefhook name HOOK_NAMED_SYMBOL",
                   !strncmp (melthkp->hookname,
                             "HOOK_NAMED_SYMBOL", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_NAMED_SYMBOL) ((melt_ptr_t)melthkp,
            meltin_NAM_p0,
            meltin_CREATE_p1);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_NAMED_SYMBOL */



/*predefined hook definition HOOK_OVERRIDE_GATE #135*/
void melthookproc_HOOK_OVERRIDE_GATE(long meltin_BEFOREGATE_p0, long* meltout_AFTERGATE_o0)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_OVERRIDE_GATE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_OVERRIDE_GATE);
    typedef void melthooksig_HOOK_OVERRIDE_GATE_t (melt_ptr_t, long, long* );
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_OVERRIDE_GATE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_OVERRIDE_GATE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_OVERRIDE_GATE */
    melthooksig_HOOK_OVERRIDE_GATE_t *melthookptr_HOOK_OVERRIDE_GATE =
        reinterpret_cast <melthooksig_HOOK_OVERRIDE_GATE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_OVERRIDE_GATE",
                   melthookptr_HOOK_OVERRIDE_GATE);

    /* check predefhook HOOK_OVERRIDE_GATE name */
    melt_assertmsg("check predefhook name HOOK_OVERRIDE_GATE",
                   !strncmp (melthkp->hookname,
                             "HOOK_OVERRIDE_GATE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_OVERRIDE_GATE) ((melt_ptr_t)melthkp,
            meltin_BEFOREGATE_p0,
            meltout_AFTERGATE_o0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_OVERRIDE_GATE */



/*predefined hook definition HOOK_PASS_EXECUTION #136*/
void melthookproc_HOOK_PASS_EXECUTION(const char* meltin_PASSNAME_p0, long meltin_PASSNUM_p1, long meltin_TYPENUM_p2)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_PASS_EXECUTION*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_PASS_EXECUTION);
    typedef void melthooksig_HOOK_PASS_EXECUTION_t (melt_ptr_t, const char*, long, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_PASS_EXECUTION exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_PASS_EXECUTION is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_PASS_EXECUTION */
    melthooksig_HOOK_PASS_EXECUTION_t *melthookptr_HOOK_PASS_EXECUTION =
        reinterpret_cast <melthooksig_HOOK_PASS_EXECUTION_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_PASS_EXECUTION",
                   melthookptr_HOOK_PASS_EXECUTION);

    /* check predefhook HOOK_PASS_EXECUTION name */
    melt_assertmsg("check predefhook name HOOK_PASS_EXECUTION",
                   !strncmp (melthkp->hookname,
                             "HOOK_PASS_EXECUTION", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_PASS_EXECUTION) ((melt_ptr_t)melthkp,
            meltin_PASSNAME_p0,
            meltin_PASSNUM_p1,
            meltin_TYPENUM_p2);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_PASS_EXECUTION */



/*predefined hook definition HOOK_PATMACRO_EXPORTER #137*/
void melthookproc_HOOK_PATMACRO_EXPORTER(melt_ptr_t meltin_SYM_p0, melt_ptr_t meltin_MACVAL_p1, melt_ptr_t meltin_PATVAL_p2, melt_ptr_t meltin_CONTENV_p3)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_PATMACRO_EXPORTER*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_PATMACRO_EXPORTER);
    typedef void melthooksig_HOOK_PATMACRO_EXPORTER_t (melt_ptr_t, melt_ptr_t, melt_ptr_t, melt_ptr_t, melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_PATMACRO_EXPORTER exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_PATMACRO_EXPORTER is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_PATMACRO_EXPORTER */
    melthooksig_HOOK_PATMACRO_EXPORTER_t *melthookptr_HOOK_PATMACRO_EXPORTER =
        reinterpret_cast <melthooksig_HOOK_PATMACRO_EXPORTER_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_PATMACRO_EXPORTER",
                   melthookptr_HOOK_PATMACRO_EXPORTER);

    /* check predefhook HOOK_PATMACRO_EXPORTER name */
    melt_assertmsg("check predefhook name HOOK_PATMACRO_EXPORTER",
                   !strncmp (melthkp->hookname,
                             "HOOK_PATMACRO_EXPORTER", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_PATMACRO_EXPORTER) ((melt_ptr_t)melthkp,
            meltin_SYM_p0,
            meltin_MACVAL_p1,
            meltin_PATVAL_p2,
            meltin_CONTENV_p3);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_PATMACRO_EXPORTER */



/*predefined hook definition HOOK_POLL_INPUTS #138*/
void melthookproc_HOOK_POLL_INPUTS(long meltin_DELAYMS_p0)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_POLL_INPUTS*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_POLL_INPUTS);
    typedef void melthooksig_HOOK_POLL_INPUTS_t (melt_ptr_t, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_POLL_INPUTS exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_POLL_INPUTS is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_POLL_INPUTS */
    melthooksig_HOOK_POLL_INPUTS_t *melthookptr_HOOK_POLL_INPUTS =
        reinterpret_cast <melthooksig_HOOK_POLL_INPUTS_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_POLL_INPUTS",
                   melthookptr_HOOK_POLL_INPUTS);

    /* check predefhook HOOK_POLL_INPUTS name */
    melt_assertmsg("check predefhook name HOOK_POLL_INPUTS",
                   !strncmp (melthkp->hookname,
                             "HOOK_POLL_INPUTS", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_POLL_INPUTS) ((melt_ptr_t)melthkp,
                                            meltin_DELAYMS_p0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_POLL_INPUTS */



/*predefined hook definition HOOK_PRE_GENERICIZE #139*/
void melthookproc_HOOK_PRE_GENERICIZE(tree meltin_TFNDECL_p0)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_PRE_GENERICIZE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_PRE_GENERICIZE);
    typedef void melthooksig_HOOK_PRE_GENERICIZE_t (melt_ptr_t, tree);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_PRE_GENERICIZE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_PRE_GENERICIZE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_PRE_GENERICIZE */
    melthooksig_HOOK_PRE_GENERICIZE_t *melthookptr_HOOK_PRE_GENERICIZE =
        reinterpret_cast <melthooksig_HOOK_PRE_GENERICIZE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_PRE_GENERICIZE",
                   melthookptr_HOOK_PRE_GENERICIZE);

    /* check predefhook HOOK_PRE_GENERICIZE name */
    melt_assertmsg("check predefhook name HOOK_PRE_GENERICIZE",
                   !strncmp (melthkp->hookname,
                             "HOOK_PRE_GENERICIZE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_PRE_GENERICIZE) ((melt_ptr_t)melthkp,
            meltin_TFNDECL_p0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_PRE_GENERICIZE */



/*predefined hook definition HOOK_PROCESS_PRAGMA #140*/
void melthookproc_HOOK_PROCESS_PRAGMA(long meltin_LIX_p0)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_PROCESS_PRAGMA*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_PROCESS_PRAGMA);
    typedef void melthooksig_HOOK_PROCESS_PRAGMA_t (melt_ptr_t, long);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_PROCESS_PRAGMA exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_PROCESS_PRAGMA is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_PROCESS_PRAGMA */
    melthooksig_HOOK_PROCESS_PRAGMA_t *melthookptr_HOOK_PROCESS_PRAGMA =
        reinterpret_cast <melthooksig_HOOK_PROCESS_PRAGMA_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_PROCESS_PRAGMA",
                   melthookptr_HOOK_PROCESS_PRAGMA);

    /* check predefhook HOOK_PROCESS_PRAGMA name */
    melt_assertmsg("check predefhook name HOOK_PROCESS_PRAGMA",
                   !strncmp (melthkp->hookname,
                             "HOOK_PROCESS_PRAGMA", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_PROCESS_PRAGMA) ((melt_ptr_t)melthkp,
            meltin_LIX_p0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_PROCESS_PRAGMA */



/*predefined hook definition HOOK_REGISTER_PRAGMAS #141*/
void melthookproc_HOOK_REGISTER_PRAGMAS()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_REGISTER_PRAGMAS*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_REGISTER_PRAGMAS);
    typedef void melthooksig_HOOK_REGISTER_PRAGMAS_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_REGISTER_PRAGMAS exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_REGISTER_PRAGMAS is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_REGISTER_PRAGMAS */
    melthooksig_HOOK_REGISTER_PRAGMAS_t *melthookptr_HOOK_REGISTER_PRAGMAS =
        reinterpret_cast <melthooksig_HOOK_REGISTER_PRAGMAS_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_REGISTER_PRAGMAS",
                   melthookptr_HOOK_REGISTER_PRAGMAS);

    /* check predefhook HOOK_REGISTER_PRAGMAS name */
    melt_assertmsg("check predefhook name HOOK_REGISTER_PRAGMAS",
                   !strncmp (melthkp->hookname,
                             "HOOK_REGISTER_PRAGMAS", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_REGISTER_PRAGMAS) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_REGISTER_PRAGMAS */



/*predefined hook definition HOOK_RTL_EXECUTE #142*/
long melthookproc_HOOK_RTL_EXECUTE()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_RTL_EXECUTE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_RTL_EXECUTE);
    typedef long melthooksig_HOOK_RTL_EXECUTE_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_RTL_EXECUTE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_RTL_EXECUTE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_RTL_EXECUTE */
    melthooksig_HOOK_RTL_EXECUTE_t *melthookptr_HOOK_RTL_EXECUTE =
        reinterpret_cast <melthooksig_HOOK_RTL_EXECUTE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_RTL_EXECUTE",
                   melthookptr_HOOK_RTL_EXECUTE);

    /* check predefhook HOOK_RTL_EXECUTE name */
    melt_assertmsg("check predefhook name HOOK_RTL_EXECUTE",
                   !strncmp (melthkp->hookname,
                             "HOOK_RTL_EXECUTE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_RTL_EXECUTE) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_RTL_EXECUTE */



/*predefined hook definition HOOK_RTL_GATE #143*/
long melthookproc_HOOK_RTL_GATE()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_RTL_GATE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_RTL_GATE);
    typedef long melthooksig_HOOK_RTL_GATE_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_RTL_GATE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_RTL_GATE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_RTL_GATE */
    melthooksig_HOOK_RTL_GATE_t *melthookptr_HOOK_RTL_GATE =
        reinterpret_cast <melthooksig_HOOK_RTL_GATE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_RTL_GATE",
                   melthookptr_HOOK_RTL_GATE);

    /* check predefhook HOOK_RTL_GATE name */
    melt_assertmsg("check predefhook name HOOK_RTL_GATE",
                   !strncmp (melthkp->hookname,
                             "HOOK_RTL_GATE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_RTL_GATE) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_RTL_GATE */



/*predefined hook definition HOOK_SIMPLE_IPA_EXECUTE #144*/
long melthookproc_HOOK_SIMPLE_IPA_EXECUTE()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_SIMPLE_IPA_EXECUTE*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_SIMPLE_IPA_EXECUTE);
    typedef long melthooksig_HOOK_SIMPLE_IPA_EXECUTE_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_SIMPLE_IPA_EXECUTE exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_SIMPLE_IPA_EXECUTE is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_SIMPLE_IPA_EXECUTE */
    melthooksig_HOOK_SIMPLE_IPA_EXECUTE_t *melthookptr_HOOK_SIMPLE_IPA_EXECUTE =
        reinterpret_cast <melthooksig_HOOK_SIMPLE_IPA_EXECUTE_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_SIMPLE_IPA_EXECUTE",
                   melthookptr_HOOK_SIMPLE_IPA_EXECUTE);

    /* check predefhook HOOK_SIMPLE_IPA_EXECUTE name */
    melt_assertmsg("check predefhook name HOOK_SIMPLE_IPA_EXECUTE",
                   !strncmp (melthkp->hookname,
                             "HOOK_SIMPLE_IPA_EXECUTE", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_SIMPLE_IPA_EXECUTE) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_SIMPLE_IPA_EXECUTE */



/*predefined hook definition HOOK_SORT_COMPARE_LESS #145*/
long melthookproc_HOOK_SORT_COMPARE_LESS(melt_ptr_t meltin_LEFT_p0, melt_ptr_t meltin_RIGHT_p1, melt_ptr_t meltin_CMP_p2)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_SORT_COMPARE_LESS*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_SORT_COMPARE_LESS);
    typedef long melthooksig_HOOK_SORT_COMPARE_LESS_t (melt_ptr_t, melt_ptr_t, melt_ptr_t, melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_SORT_COMPARE_LESS exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_SORT_COMPARE_LESS is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_SORT_COMPARE_LESS */
    melthooksig_HOOK_SORT_COMPARE_LESS_t *melthookptr_HOOK_SORT_COMPARE_LESS =
        reinterpret_cast <melthooksig_HOOK_SORT_COMPARE_LESS_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_SORT_COMPARE_LESS",
                   melthookptr_HOOK_SORT_COMPARE_LESS);

    /* check predefhook HOOK_SORT_COMPARE_LESS name */
    melt_assertmsg("check predefhook name HOOK_SORT_COMPARE_LESS",
                   !strncmp (melthkp->hookname,
                             "HOOK_SORT_COMPARE_LESS", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_SORT_COMPARE_LESS) ((melt_ptr_t)melthkp,
            meltin_LEFT_p0,
            meltin_RIGHT_p1,
            meltin_CMP_p2);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_SORT_COMPARE_LESS */



/*predefined hook definition HOOK_START_UNIT #146*/
void melthookproc_HOOK_START_UNIT()
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_START_UNIT*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_START_UNIT);
    typedef void melthooksig_HOOK_START_UNIT_t (melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_START_UNIT exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_START_UNIT is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_START_UNIT */
    melthooksig_HOOK_START_UNIT_t *melthookptr_HOOK_START_UNIT =
        reinterpret_cast <melthooksig_HOOK_START_UNIT_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_START_UNIT",
                   melthookptr_HOOK_START_UNIT);

    /* check predefhook HOOK_START_UNIT name */
    melt_assertmsg("check predefhook name HOOK_START_UNIT",
                   !strncmp (melthkp->hookname,
                             "HOOK_START_UNIT", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_START_UNIT) ((melt_ptr_t)melthkp);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_START_UNIT */



/*predefined hook definition HOOK_SYMBOL_IMPORTER #147*/
melt_ptr_t melthookproc_HOOK_SYMBOL_IMPORTER(const char* meltin_SYMNAMESTR_p0, const char* meltin_MODULENAMESTR_p1, melt_ptr_t meltin_PARENV_p2)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_SYMBOL_IMPORTER*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_SYMBOL_IMPORTER);
    typedef melt_ptr_t melthooksig_HOOK_SYMBOL_IMPORTER_t (melt_ptr_t, const char*, const char*, melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_SYMBOL_IMPORTER exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_SYMBOL_IMPORTER is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_SYMBOL_IMPORTER */
    melthooksig_HOOK_SYMBOL_IMPORTER_t *melthookptr_HOOK_SYMBOL_IMPORTER =
        reinterpret_cast <melthooksig_HOOK_SYMBOL_IMPORTER_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_SYMBOL_IMPORTER",
                   melthookptr_HOOK_SYMBOL_IMPORTER);

    /* check predefhook HOOK_SYMBOL_IMPORTER name */
    melt_assertmsg("check predefhook name HOOK_SYMBOL_IMPORTER",
                   !strncmp (melthkp->hookname,
                             "HOOK_SYMBOL_IMPORTER", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_SYMBOL_IMPORTER) ((melt_ptr_t)melthkp,
            meltin_SYMNAMESTR_p0,
            meltin_MODULENAMESTR_p1,
            meltin_PARENV_p2);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_SYMBOL_IMPORTER */



/*predefined hook definition HOOK_VALUE_EXPORTER #148*/
void melthookproc_HOOK_VALUE_EXPORTER(melt_ptr_t meltin_SYM_p0, melt_ptr_t meltin_VAL_p1, melt_ptr_t meltin_CONTENV_p2)
{
    /* code emitted by generate_runtypesupport_predefined_hooks for HOOK_VALUE_EXPORTER*/
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
    melthook_ptr_t melthkp = (melthook_ptr_t) MELT_PREDEF (HOOK_VALUE_EXPORTER);
    typedef void melthooksig_HOOK_VALUE_EXPORTER_t (melt_ptr_t, melt_ptr_t, melt_ptr_t, melt_ptr_t);
    /*checkhook exist*/ melt_assertmsg (" check predefhook HOOK_VALUE_EXPORTER exists",
                                        melthkp != NULL);
    /*checkhook ishook*/ melt_assertmsg (" check predefhook HOOK_VALUE_EXPORTER is hook",
                                         melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);
    /* check hook routine HOOK_VALUE_EXPORTER */
    melthooksig_HOOK_VALUE_EXPORTER_t *melthookptr_HOOK_VALUE_EXPORTER =
        reinterpret_cast <melthooksig_HOOK_VALUE_EXPORTER_t*>
        (melthkp->hookad) ;
    melt_assertmsg("check predefhook routine HOOK_VALUE_EXPORTER",
                   melthookptr_HOOK_VALUE_EXPORTER);

    /* check predefhook HOOK_VALUE_EXPORTER name */
    melt_assertmsg("check predefhook name HOOK_VALUE_EXPORTER",
                   !strncmp (melthkp->hookname,
                             "HOOK_VALUE_EXPORTER", MELT_HOOKNAME_LEN-1));
    return (*melthookptr_HOOK_VALUE_EXPORTER) ((melt_ptr_t)melthkp,
            meltin_SYM_p0,
            meltin_VAL_p1,
            meltin_CONTENV_p2);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
} /* end  melthookproc_HOOK_VALUE_EXPORTER */









/* end of code generated by generate_runtypesupport_predefined_hooks for 155 predefined */

/*** End of code file meltbuild-sources/generated/meltrunsup-inc.cc generated on 2014 Apr 14
 * by GCC MELT 4.9.0 20140408 (experimental) [melt-branch revision 209365] MELT_1.1-pre . ***/
