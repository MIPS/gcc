;; -*- Lisp -*-
;; file libmelt-ana-tree.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008 - 2016  Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
                and Jeremie Salvucci  <jeremie.salvucci@free.fr>
                and Pierre Vittet  <piervit@pvittet.com>
                and Romain Geissler  <romain.geissler@gmail.com>

    This file libmelt-ana-tree.{melt,cc} is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to libmelt-ana-tree.melt and 
;; to the generated file  libmelt-ana-tree*.cc

;; This MELT module is GPL compatible since it is GPLv3+ licensed.
(module_is_gpl_compatible "GPLv3+")

;;; NB. The generated file _libmelt-treecode.melt is generated from 
;;; GCC tree.def file using emit-libmelt-treecode.inc
;;; it contains lines like
;;;;;; (gcc_tree_code ERROR_MARK "error_mark" tcc_exceptional 0)
;;; corresponding to a line like
;;;;;;; DEFTREECODE (ERROR_MARK, "error_mark", tcc_exceptional, 0)
;;; from file tree.def. We load that _libmelt-treecode.melt file
;;; several times.

(defclass class_gcc_tree_code
  :super class_named
  :fields (gcctreecode_string
	   gcctreecode_type
	   gcctreecode_nargs
	   gcctreecode_data))
(export_class class_gcc_tree_code)

;; the internal macro expander to define gcc tree code
(defun mexpand_gcc_tree_code_define (sexp env mexpander modctx)
  (debug "mexpand_gcc_tree_code_define" " start sexp=" sexp)
  (let (
	(sloc (get_field :loca_location sexp))
	(sexcont (get_field :sexp_contents sexp))
	(xargs (expand_restlist_as_tuple sexcont env mexpander modctx))
	(namecod (multiple_nth xargs 0))
	(strcod (multiple_nth xargs 1))
	(typcod (multiple_nth xargs 2))
	(nargcod (multiple_nth xargs 3))
	(nbargs (multiple_length xargs))
	)
    (when (!=i 4 nbargs)
      (error_at sloc "GCC_TREE_CODE need four arguments, got $1" xargs)
      (return))
    ;;
    (debug "mexpand_gcc_tree_code_define" 
	   " namecod=" namecod
	   " strcod=" strcod
	   " typcod=" typcod
	   " nargcod=" nargcod)
    (assert_msg "mexpand_gcc_tree_code_define check namecod"
		(is_a namecod class_symbol))
    (let ( (namcodstr (get_field :named_name namecod)) 
	   (xdefinst 
	    `(definstance ,namecod class_gcc_tree_code
	       :named_name ',namcodstr
	       :gcctreecode_string ',strcod
	       :gcctreecode_type ',typcod
	       :gcctreecode_nargs ',nargcod))
	   (xexport `(export_values ,namecod))
	  )
      (debug "mexpand_gcc_tree_code_define xdefinst=" xdefinst
	     "\n.. xexport=" xexport)
      (let ( (resultx (tuple (mexpander xdefinst env mexpander modctx)
			     (mexpander xexport  env mexpander modctx)))
	    )
	(debug "mexpand_gcc_tree_code_define resultx=" resultx)
	(return resultx)
))))


;;; first load of generated _libmelt-treecode.melt to define public instances
;;; of class_gcc_tree_code
(let ( (:macro gcc_tree_code (sexp env mexpander modctx)	      
	       (debug "gcc_tree_code:macro1" " sexp=" sexp)
	       (mexpand_gcc_tree_code_define sexp env mexpander modctx)
	       )
       )
  (debug "before loading1 libmelt-treecode")
  (load "_libmelt-treecode.melt")
  (debug "after loading1 libmelt-treecode")
  (void)
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defprimitive is_tree (v) :long
  :doc #{$IS_TREE test if value $V is a boxed tree}#
  #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_TREE)}# )

(defprimitive isnull_tree (:tree tr) :long
  :doc #{$ISNULL_TREE test if raw tree $TR is null}#
  #{$tr == NULL_TREE}#
)

(defprimitive make_tree (discr :tree tr) :value
  :doc #{$MAKE_TREE build a boxed tree of given $DISCR and tree $TR}#
  #{(meltgc_new_tree((meltobject_ptr_t)($DISCR),($TR)))}# )

(defprimitive tree_content (v) :tree
  :doc #{$TREE_CONTENT safely retrieve the tree inside boxed value $V}#
  #{(melt_tree_content((melt_ptr_t)($V)))}# )

(defprimitive ==t (:tree t1 t2) :long
  :doc #{==T safely compare tree $T1 and $T2 for identity}#
  #{(($t1) == ($t2))}# )

(defprimitive null_tree () :tree 
  :doc #{$NULL_TREE gives the null tree}#
#{(NULL_TREE)}#)

(defprimitive inform_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  :doc #{$INFORM_AT_TREE give a notice at location of tree $TR with message $MSG}#
  #{ /*inform_at_tree: */ inform ((($tr && DECL_P($tr))? DECL_SOURCE_LOCATION($tr)
	    : ($tr && EXPR_P($tr)) ? EXPR_LOCATION($tr) : UNKNOWN_LOCATION), 
  $msg );
  }# )

(defprimitive warning_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  :doc #{$WARNING_AT_TREE give a warning at location of tree $TR with message $MSG}#
  #{ /*warning_at_tree: */ warning_at((($tr && DECL_P($tr))? DECL_SOURCE_LOCATION($tr)
		 : ($tr && EXPR_P($tr)) ? EXPR_LOCATION($tr) : UNKNOWN_LOCATION), 
		 0, 
		 "MELT WARNING @Tree: %s", 
		 $msg);
  }# )


(defprimitive error_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  :doc #{$ERROR_AT_TREE give a warning at location of tree $TR with message $MSG}#
  #{ /*error_at_tree: */ error_at ((($tr && DECL_P($tr))? DECL_SOURCE_LOCATION($tr)
		 : ($tr && EXPR_P($tr)) ? EXPR_LOCATION($tr) : UNKNOWN_LOCATION), 
				   "MELT ERROR @Tree: %s",
				   $msg);
  }#)

(defprimitive warning_at_tree_decl_with_number
  (:tree trdecl :cstring msg :long num) :void
  :doc #{$WARNING_AT_TREE_DECL_WITH_NUMBER give a warning with declaration of tree $TRDECL message $MSG number $NUM}#
  #{ warning (0, "MELT warning %s at %q+D - #%ld", $MSG, ($TRDECL), ($NUM));
  }# )

(defprimitive tree_type (:tree tr) :tree
  :doc #{$TREE_TYPE gives the type of tree $TR}#
  #{(($TR) ? TREE_TYPE($TR) : (tree) NULL)}#)

(defprimitive tree_type_addr_space (:tree tr) :long
  :doc #{$TREE_TYPE_ADDR_SPACE gives the address space of type tree $TR}#
  #{(($TR && TYPE_P($TR))  ? TYPE_ADDR_SPACE($TR) : 0L)}#)

(defprimitive tree_uid (:tree tr) :long
  :doc #{$TREE_UID gives the uid of tree $TR}#
  #{(($TR) ? (long) DECL_UID($TR) : 0L)}#)

(defprimitive tree_useless_type_conversion_p (:tree tr1 tr2) :long
  :doc #{$TREE_USELESS_TYPE_CONVERSION_P checks that $TR1 and $TR2 are non-null and are type convertible using the @code{useless_type_conversion_p} function of GCC.}#
  #{/*tree_useless_type_conversion_p*/ ($TR1) && ($TR2)
  && useless_type_conversion_p(($TR1),($TR2))}#)

(defprimitive tree_types_compatible_p (:tree tr1 tr2) :long
  :doc #{$TREE_TYPES_COMPATIBLE_P checks that $TR1 and $TR2 are non-null and are type convertible using the @code{types_compatible_p} function of GCC.}#
  #{/*tree_types_compatible_p*/ ($TR1) && ($TR2)
  && types_compatible_p(($TR1),($TR2))}#)

(defprimitive tree_chain_prepend (:tree purpose value chain) :tree
	:doc #{Create a new TREE_LIST node with $PURPOSE and $VALUE trees
	and chain it at the begining of $CHAIN. Returns the newly created
	chain.}#
	#{ /* tree_chain_prepend */
		tree_cons ($PURPOSE, $VALUE, $CHAIN)
	}#)

(defprimitive tree_chain_append (:tree purpose value chain) :tree
	:doc #{Create a new TREE_LIST node with $PURPOSE and $VALUE trees
	and chain it at the end of $CHAIN. Returns the newly created
	chain (different from $CHAIN if $CHAIN is NULL_TREE).}#
	#{ /* tree_chain_append */
		chainon ($CHAIN, tree_cons ($PURPOSE, $VALUE, NULL_TREE))
	}#)

(defprimitive tree_chain_join (:tree chain1 chain2) :tree
	:doc #{Append $CHAIN2 to $CHAIN1 and returns the newly created
	chain (different from $CHAIN1 if $CHAIN1 is NULL_TREE).}#
	#{ /* tree_chain_join */
		chainon ($CHAIN1, $CHAIN2)
	}#)


;;;;;;;;;;;;;;;;
(defun tree_chain_to_tuple (discr :tree tr :value fun)
  :doc #{Make a boxed tree tuple of given $DISCR - default to
  $DISCR_MULTIPLE from the chain starting at tree $TR, i.e. unfold a
  tree chain into a tuple of boxed trees, if a closure $FUN is given,
  it is applied to every boxed component and its index before building
  the tuple.}#
  (debug "tree_chain_to_tuple" " discr=" discr "; tr=" tr)
  (if (null discr) (setq discr discr_multiple))
  (if (is_not_a discr class_discriminant)
      (return))
  (if (expr_chunk
       chdiscr_chk :long
       #{ /* tree_chain_to_tuple $CHDISCR_CHK */
       ((meltobject_ptr_t)$DISCR)->meltobj_magic != MELTOBMAG_MULTIPLE
       }#)
      (return))
  (let ( (:long len 0)
	 (:tree ctr tr)
	 )
    (forever
     cntloop
     (if (expr_chunk
	  chcount_chk :long
	  #{ /* tree_chain_to_tuple $CHCOUNT_CHK */
	  !$CTR || !CODE_CONTAINS_STRUCT (TREE_CODE($CTR), TS_COMMON)
	  }#)	 
	 (exit cntloop))
     (code_chunk chnext_chk
		 #{ /* tree_chain_to_tuple $CHNEXT_CHK */
		 $CTR = TREE_CHAIN($CTR) ;
		 }#)
     (setq len (+i len 1))
     )
    (let ( (tup (make_multiple discr len))
	   (:long ix 0)
	   )
      (setq ctr tr)
      (if (is_closure fun)
	  (forever filltreefunloop
		 (debug "tree_chain_to_tuple" " filltreefunloop ix=" ix "; ctr=" ctr)
		 (code_chunk
		  exitfillfun_chk
		  #{ /* tree_chain_to_tuple $EXITFILLFUN_CHK */
		  if (!$CTR || !CODE_CONTAINS_STRUCT (TREE_CODE($CTR), TS_COMMON))
		     $(exit filltreefunloop) ;
		  }#)
		 (multiple_put_nth tup ix (fun (constant_box ctr) ix))
		 (code_chunk
		  nextchainfun_chk
		  #{ /* tree_chain_to_tuple $NEXTCHAINFUN_CHK */
		  $CTR = TREE_CHAIN($CTR) ;
		  }#)
		 (setq ix (+i ix 1))
		   )
	(forever filltreeloop
		 (debug "tree_chain_to_tuple" " filltreeloop ix=" ix "; ctr=" ctr)
		 (code_chunk
		  exitfill_chk
		  #{ /* tree_chain_to_tuple $EXITFILL_CHK */
		  if (!$CTR || !CODE_CONTAINS_STRUCT (TREE_CODE($CTR), TS_COMMON))
		  $(exit filltreeloop)	;
		  }#)
		 (multiple_put_nth tup ix (constant_box ctr))
		 (code_chunk
		  nextchain_chk
		  #{ /* tree_chain_to_tuple $NEXTCHAIN_CHK */
		  $CTR = TREE_CHAIN($CTR) ;
		  }#)
		 (setq ix (+i ix 1))
		 )
	)
      (debug "tree_chain_to_tuple" " result tup=" tup)
      (return tup)
      )
    )
  )
;;;;;;;;;;;;;;;;

(defprimitive build_identifier_tree (name) :tree
	:doc #{Create and returns a new IDENTIFIER_NODE tree whose
	name is $NAME.}#
	#{ /* build_identifier_tree */
		get_identifier (melt_string_str ((melt_ptr_t) $NAME))
	}#)

(defprimitive build_string_tree (string_value) :tree
	:doc #{Create and returns a new STRING_CST tree whose
	value is $STRING_VALUE.}#
	#{ /* build_string_tree */
		build_string (strlen (melt_string_str ((melt_ptr_t) $STRING_VALUE)),
				     melt_string_str ((melt_ptr_t) $STRING_VALUE))
	}#)


(defprimitive build_int_tree (int_value) :tree
	:doc #{Create and returns a new INTEGER_CST tree whose
	value is $INT_VALUE and type is the default language
	integer type.}#
	#{
		build_int_cst (integer_type_node, (int)melt_get_int ($INT_VALUE))
	}#
)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;

(defcmatcher tree_error_mark
(:tree tr)
() ;output
treerr
:doc #{$TREE_ERROR_MARK match an error mark.}#
;; test
#{ /* tree_error_mark $TREERR ? */ (($TR) && TREE_CODE($TR) == ERROR_MARK) }#
;; fill
#{ /* tree_error_mark $TREERR ! */ }#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern (tree_function_decl_named <funame> <initialtree>) match a tree for a function
;; declaration
(defcmatcher tree_function_decl_named 
  (:tree tr) 				;matched
  ;; output 
  (:cstring funame
   :tree trresult
   )
  treefunam				;state symbol
  :doc #{$TREE_FUNCTION_DECL_NAMED match a function declaration extracting its name $FUNAME and result tree decl $TRRESULT}#
  ;; test expansion
  #{ /*  tree_function_decl_named $TREEFUNAM ? */ (($TR) && TREE_CODE($TR) == FUNCTION_DECL) }#
  ;; fill expansion
  #{/*  tree_function_decl_named $TREEFUNAM ! */ 
   $FUNAME = NULL; 
   $TRRESULT = NULL; 
   if (DECL_NAME($tr))
     $FUNAME = IDENTIFIER_POINTER(DECL_NAME($TR)); 
   $TRRESULT = DECL_RESULT($TR); 
  }#
)

(defcmatcher tree_function_decl_full
  (:tree tr)
  ;; output
  (:tree tname targs ttype tresult tctxt :long builtincode)
  treefunfull ;state symbol
  :doc #{$TREE_FUNCTION_DECL_FULL match a function declaration $TR extracting all the information}#
  ;; test
  #{ /* tree_function_decl_full $TREEFUNFULL ? */ (($TR) && TREE_CODE($TR) == FUNCTION_DECL) }#
  ;; fill expansion
  #{ /* tree_function_decl_full $TREEFUNFULL ! */
  $TNAME = DECL_NAME ($TR);
  $TARGS = DECL_ARGUMENTS ($TR);
  $TTYPE = TREE_TYPE ($TR);
  $TRESULT = DECL_RESULT ($TR);
  $TCTXT = DECL_CONTEXT ($TR);
  $BUILTINCODE = DECL_FUNCTION_CODE ($TR);
  }#)

;;

(defcmatcher tree_function_decl_named_of_type 
  (:tree tr) 				;matched
  ;; output 
  (:cstring funame
   :tree trtype
   )
  treefunam				;state symbol
  :doc #{$TREE_FUNCTION_DECL_NAMED_OF_TYPE match a function declaration extracting its name $FUNAME and type tree decl $TRTYPE}#
  ;; test expansion
  #{ /*  tree_function_decl_named_of_type $TREEFUNAM ? */ (($TR) && TREE_CODE($TR) == FUNCTION_DECL) }#
  ;; fill expansion
  #{/*  tree_function_decl_named_of_type $TREEFUNAM ! */ 
   $FUNAME = NULL;
   if (DECL_NAME($tr))
     $FUNAME = IDENTIFIER_POINTER(DECL_NAME($TR)); 
   $TRTYPE = TREE_TYPE($TR); 
  }#
)
;; match a function decl of a given name
(defcmatcher tree_function_decl_of_name 
  (:tree tr :cstring fname) 				;matched
  ;; output 
  (:tree tfunname
   :tree ttrresult
   )
  treefunofnam				;state symbol
  :doc #{$TREE_FUNCTION_DECL_OF_NAME match a function declaration tree $TR for function named $FNAME extracting the tree name $TFUNAME and result tree $TTRRESULT}#
  ;; test expansion
  #{ /* tree_function_decl_of_name $TREEFUNOFNAM ?*/ (($TR) && TREE_CODE($TR) == FUNCTION_DECL && DECL_NAME($TR) 
     && !strcmp($fname, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_function_decl_of_name  $TREEFUNOFNAM ! */
   $TFUNNAME = DECL_NAME ($TR);
   $TTRRESULT = DECL_RESULT ($TR); 
  }#
)


;; match a function decl of a given name
(defcmatcher tree_function_decl_of_type_and_result 
  (:tree tr :cstring fname) 				;matched
  ;; output 
  (:tree tfunname
   :tree tftype
   :tree ttrresult
   )
  treefunoftypres				;state symbol
  :doc #{$TREE_FUNCTION_DECL_OF_TYPE_AND_RESULT match a function
  declaration tree $TR for function named $FNAME extracting the tree
  name $TFUNAME, tree type $TFTYPE, and result tree $TTRRESULT}#
  ;; test expansion
  #{ /* tree_function_decl_of_type_and_result $TREEFUNOFTYPRES ?*/ (($TR) 
     && TREE_CODE($TR) == FUNCTION_DECL && DECL_NAME($TR) 
     && !strcmp($FNAME, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_function_decl_of_type_and_result $TREEFUNOFTYPRES ! */
   $TFUNNAME = DECL_NAME ($TR);
   $TFTYPE = TREE_TYPE ($TR); 
   $TTRRESULT = DECL_RESULT ($TR); 
  }#
)


(defcmatcher tree_function_decl 
  (:tree tr) 				;matched
  ;; output 
  (:tree tfuname
   :tree tresult
   )
  treefun				;state symbol
  :doc #{$TREE_FUNCTION_DECL match a function declaration tree, extracting the tree name $TFUNAME and the tree result $TRESULT.}#
  ;; test expansion
  #{ /* tree_function_decl $TREEFUN ?*/ (($TR) && TREE_CODE($TR) == FUNCTION_DECL) }#
  ;; fill expansion
  #{ /* tree_function_decl  $TREEFUN ! */
   $TFUNAME = DECL_NAME($TR);
   $TRESULT = DECL_RESULT($TR); 
  }#
)

;; pattern (tree_function_type <name> <return type> <argtypes>) match a tree function type.
(defcmatcher tree_function_type
  (:tree tr)
  (:tree trnam trtyp trargty trctx)
  tfunt
  :doc #{$TREE_FUNCTION_TYPE match a function type tree $TR extracting
  the name tree $TRNAM, result type tree $TRTYP and the list of type
  of arguments into $TRARGTY and the context into $TRCTX}#
  ;; test expansion
  #{ /* tree_function_type $tfunt ? */ (($TR) && TREE_CODE($TR) == FUNCTION_TYPE) }#
  ;; fill expansion
  #{ /* tree_function_type $tfunt ! */
  $TRNAM = TYPE_NAME ($TR);
  $TRTYP = TREE_TYPE($TR);
  $TRARGTY = TYPE_ARG_TYPES($TR);
  $TRCTX = TYPE_CONTEXT($TR);
  }#)

;; pattern (tree_method_type <return type>) match a tree method type.
(defcmatcher tree_method_type
  (:tree tr)
  (:tree  trnam trtyp trbasety trargty trctx)
  tmethoty
  :doc #{$TREE_METHOD_TYPE match a method type tree $TR extracting the
  result type tree $TRTYP, the basetype $TRBASETY, the arguments
  $TRARGTY.}#
  ;; test expansion
  #{ /*  tree_method_type $TMETHOTY ? */ (($tr) && TREE_CODE($tr) == METHOD_TYPE) }#
  ;; fill expansion
  #{ /*  tree_method_type $TMETHOTY ! */
  $TRNAM = TYPE_NAME ($TR);
  $TRTYP = TREE_TYPE($tr);
  $TRBASETY = TYPE_METHOD_BASETYPE($TR);
  $TRARGTY = TYPE_ARG_TYPES($TR);
  $TRCTX = TYPE_CONTEXT($TR);
  }#)

;; pattern (tree_lang_type)
(defcmatcher tree_lang_type
  (:tree tr)
  ()
  tlangty
  :doc #{$TREE_LANG_TYPE match a language specific type.}#
  #{ /* tree_lang_type $TLANGTY ? */ (($TR) && TREE_CODE($TR) == LANG_TYPE) }#
  )
  
;;;;;;;;;;;;;;;;
(defcmatcher tree_of_type 
  (:tree tr)
  (:tree trtyp)
  treeoftype
  :doc #{$TREE_OF_TYPE match any non-null tree $TR extracting the type tree $TRTYP}#
  ;; test expansion
  #{ /* tree_of_type $treeoftype ?*/ ($TR) != NULL }#
  ;; fill expansion
  #{ /* tree_of_type $treeoftype !*/ $TRTYP = TREE_TYPE($tr); }#
)


;;;;;;;;;;;;;;;;
;; pattern for variables (tree_var_decl <type> <name> <uid>)
(defcmatcher tree_var_decl_named 
  (:tree tr)
  (:tree type :cstring varname :long uid)
  treevardnam				;statesym
  :doc #{$TREE_VAR_DECL_NAMED match a variable declartion tree $TR extracting its type tree $TYPE, its $VARNAME and its $UID}#
  ;; test expansion
  #{/* tree_var_decl_named $TREEVARDNAM ?*/ (($TR) && TREE_CODE($TR) == VAR_DECL) }#
  ;; fill expansion
  #{/* tree_var_decl_named $TREEVARDNAM !*/
   $VARNAME =NULL;
   $TYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $VARNAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )

;; pattern for variables (tree_var_decl <type> <name> <uid>)
(defcmatcher tree_var_decl 
  (:tree tr)
  (:tree ttype tname :long uid)
  treevard				;statesym
  :doc #{$TREE_VAR_DECL match a variable declaration tree $TR extracting its type tree $TTYPE, its name tree $TNAME and its $UID}#
  ;; test expansion
  #{/* tree_var_decl $TREEVARD ?*/ (($TR) && TREE_CODE($TR) == VAR_DECL) }#
  ;; fill expansion
  #{/* tree_var_decl $TREEVARD !*/
   $TTYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   $TNAME = DECL_NAME($TR);
   }# )

;;;;;;;;
;; pattern for a var_decl of given name
	   
(defcmatcher tree_var_decl_of_name 
  (:tree tr :cstring varname)
  (:tree ttype)
  treevarn				;statesym
  :doc #{$TREE_VAR_DECL match a variable declaration tree $TR of name $VARNAME extracting its type tree $TTYPE}#
  ;; test expansion
  #{ /* tree_var_decl_of_name $TREEVARN ?*/ (($TR) && TREE_CODE($TR) == VAR_DECL && DECL_NAME($TR) 
      && !strcmp($varname, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_var_decl_of_name $TREEVARN !*/ 
   $TTYPE = TREE_TYPE($TR);
  }# )

;;;;;;;;;;;;;;;;
;; pattern for constants (tree_const_decl <type> <name> <uid>)
(defcmatcher tree_const_decl 
  (:tree tr)
  (:tree ttype :cstring constname :long uid)
  treeconstd				;statesym
  :doc #{$TREE_CONST_DECL match a const declaration tree $TR extracting its type tree $TTYPE, its name $CONSTNAME, its $UID}#
  ;; test expansion
  #{/* tree_const_decl $TREECONSTD ?*/ (($TR) && TREE_CODE($TR) == CONST_DECL) }#
  ;; fill expansion
  #{/* tree_const_decl $TREECONSTD !*/
   $CONSTNAME =NULL;
   $TTYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $CONSTNAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )

;;;;;;;;
;; pattern for a const_decl of given name
	   
(defcmatcher tree_const_decl_of_name 
  (:tree tr :cstring constname)
  (:tree ttype)
  treeconstn				;statesym
  :doc #{$TREE_CONST_DECL_OF_NAME match a const declaration tree $TR of name $CONSTNAME extracting its type tree $TTYPE}#
  ;; test expansion
  #{ /* tree_const_decl_of_name $TREECONSTN ?*/ (($TR) && TREE_CODE($TR) == CONST_DECL && DECL_NAME($TR) 
      && !strcmp($constname, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_const_decl_of_name $TREECONSTN !*/
   $TTYPE = TREE_TYPE($TR); }# )

;; pattern for constant declaration  (tree_const_decl_named <type> <name> <uid>)
(defcmatcher tree_const_decl_named 
  (:tree tr)
  (:tree ttype :cstring constname :long uid)
  treeconstnam				;statesym
  :doc #{$TREE_CONST_DECL_NAMED match a const declaration tree $TR extracting its type $TTYPE, its name $CONSTNAME its $UID}#
  ;; test expansion
  #{/* tree_const_decl_named $TREECONSTNAM ?*/ (($TR) && TREE_CODE($TR) == CONST_DECL) }#
  ;; fill expansion
  #{/* tree_const_decl_named $TREECONSTNAM !*/
   $CONSTNAME = NULL;
   $TTYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $CONSTNAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for label
(defcmatcher tree_label_decl 
  (:tree tr)
  (:tree trlabel
   :long uidlabel)
  treelabel
  :doc #{$TREE_LABEL_DECL match a label declaration tree 
  $TR extracting its label tree $TRLABEL and uid $UIDLABEL}#
  ;;; test expansion
  #{ /* tree_label_decl $TREELABEL ?*/ (($TR) && 
					TREE_CODE($TR) == LABEL_DECL) }#
  ;;; test fill
  #{ /* tree_label_decl $TREELABEL !*/ 
     $TRLABEL = LABEL_EXPR_LABEL ($TR);
     $UIDLABEL = LABEL_DECL_UID ($TR);
  }#
)

(defprimitive tree_create_artificial_label ()
  :tree
  :doc #{Create an artifical label tree, without source location.}#
  #{ /* tree_create_artificial_label */ create_artificial_label (UNKNOWN_LOCATION) }#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for case label in switches
(defcmatcher tree_case_label_expr
  (:tree tr)
  (:tree tclow tchigh tlabel tchain)
  treecaselabel
  :doc #{$TREE_CASE_LABEL_EXPR match a @code{CASE_LABEL_EXPR} tree.
  $TCLOW is the CASE_LOW, TCHIGH is the CASE_HIGH, TLABEL is the CASE_LABEL, TCHAIN is the CASE_CHAIN. See also $BUILD_CASE_LABEL.}#
  ;; test
  #{ /* tree_case_label_expr $TREECASELABEL ? */
  $TR && TREE_CODE($TR) == CASE_LABEL_EXPR
  }#
  ;; fill
  #{ /* tree_case_label_expr $TREECASELABEL ! */
  $TCLOW = CASE_LOW($TR);
  $TCHIGH = CASE_HIGH($TR);
  $TLABEL = CASE_LABEL($TR);
  $TCHAIN = CASE_CHAIN($TR);
  }#)

;;; build a case label
(defprimitive build_case_label (:tree tclow tchigh tlabel) :tree
  :doc #{Build a case label with its low $TCLOW, high $TCHIGH, and label $TLABEL sub-trees.}#
  #{ build_case_label($TCLOW, $TCHIGH, $TLABEL) }#)
			      
		      
  
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for parameters (tree_parm_decl <type> <name> <uid>)
(defcmatcher tree_parm_decl_named 
  (:tree tr)
  (:tree type :cstring parmname :long uid)
  treeparmdcnam				;statesym
  :doc #{$TREE_PARM_DECL_NAMED match a parm declaration tree $TR extracting its type $TTYPE, its name $PARMNAME its $UID}#
  ;; test expansion
  #{/* tree_parm_decl_named $TREEPARMDCNAM ?*/ (($TR) && TREE_CODE($TR) == PARM_DECL) }#
  ;; fill expansion
  #{/* tree_parm_decl_named $TREEPARMDCNAM !*/
   $PARMNAME =NULL;
   $TYPE = DECL_ARG_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $PARMNAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )

;; pattern for a parm_decl of given name
(defcmatcher tree_parm_decl_of_name 
  (:tree tr :cstring parmname)
  (:tree type)
  treeparmofnam				;statesym
  :doc #{$TREE_PARM_DECL_OF_NAME match a parm declaration tree $TR named $PARMNAME extracting its $TYPE}#
  ;; test expansion
  #{ /* tree_parm_decl_of_name $TREEPARMOFNAM ?*/ (($TR) && TREE_CODE($TR) == PARM_DECL && DECL_NAME($TR) 
      && !strcmp($PARMNAME, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_parm_decl_of_name $TREEPARMOFNAM !*/ 
   $TYPE = DECL_ARG_TYPE($TR); }# )


;; pattern for a parm_decl
(defcmatcher tree_parm_decl
  (:tree tr)
  (:tree trargtype trdeclnam)
  treeparmde				;statesym
  :doc #{$TREE_PARM_DECL_OF_NAME match a parm declaration tree $TR extracting its $TRARGTYPE and decl name tree $TRDECLNAME}#
  ;; test expansion
  #{ /* tree_parm_decl $TREEPARMDE ?*/ (($TR) && TREE_CODE($TR) == PARM_DECL) }#
  ;; fill expansion
  #{ /* tree_parm_decl $TREEPARMDE !*/ 
   $TRARGTYPE = DECL_ARG_TYPE($TR);
   $TRDECLNAM = DECL_NAME($TR);
   }# )


;;;; pattern for a debug_expr_decl
(defcmatcher tree_debug_expr_decl
  (:tree tr)
  (:tree trtype trname)
  trdbgexpdcl
  :doc #{$TREE_DEBUG_EXPR_DECL match a declaration of debug temporary,
  extracting its type $TRTYPE and name $TRNAME.}#
  ;; test expansion
  #{ /* tree_debug_expr_decl $TRDBGEXPDCL ? */ (($TR) && TREE_CODE($TR) == DEBUG_EXPR_DECL) }#
  ;; fill expansion
  #{ /* tree_debug_expr_decl $TRDBGEXPDCL ! */
  $TRTYPE = TREE_TYPE($TR);
  $TRNAME = DECL_NAME($TR);
  }#)
  


(defcmatcher tree_namespace_decl
  (:tree tr)
  (:tree trname)
  trnamespadcl
  :doc #{$TREE_NAMESPACE_DECL match a name space declaration, extracting its name in $TRNAME.}#
  ;; test
  #{ /* tree_namespace_decl $TRNAMESPADCL ? */ (($TR) && TREE_CODE($TR) == NAMESPACE_DECL) }#
  ;; fill
  #{ /* tree_namespace_decl $TRNAMESPADCL ! */ $TRNAME = DECL_NAME($TR);
  }#)


;;;;
(defcmatcher tree_imported_decl
  (:tree tr)
  (:tree trname)
  trimportdcl
  :doc #{$TREE_IMPORTED_DECL match an import declaration, extracting its name in $TRNAME.}#
  ;; test
  #{ /* tree_imported_decl $TRIMPORTDCL ? */ (($TR) && TREE_CODE($TR) == IMPORTED_DECL) }#
  ;; fill
  #{ /* tree_imported_decl $TRIMPORTDCL ! */ $TRNAME = DECL_NAME($TR);
  }#)
  
;;;;
(defcmatcher tree_namelist_decl
   (:tree tr)
   (:tree trdecl)
   trnamlisdcl
   :doc #{$TREE_NAMELIST_DECL match a namelist declaration, extracting the list into $TRDECL.}#
   ;; test
   #{ /* tree_namelist_decl $TRNAMLISDCL ? */ (($TR) && TREE_CODE($TR) == NAMELIST_DECL) }#
   ;; fill
   #{ /* tree_namelist_decl $TRNAMLISDCL ! */
   $TRDECL = NAMELIST_DECL_ASSOCIATED_DECL ($TR) ;
   }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_translation_unit_decl
  (:tree tr)
  (:tree tinit)
  translunidcl
  :doc #{$TREE_TRANSLATION_UNIT_DECL match a translation unit
  declaration extracting its initial declaration $TINIT.}#
  ;; test
  #{ /* tree_translation_unit_decl $TRANSLUNIDCL ? */  (($TR) && TREE_CODE($TR) == TRANSLATION_UNIT_DECL) }#
  ;; fill
  #{ /* tree_translation_unit_decl $TRANSLUNIDCL ! */
  $TINIT = DECL_INITIAL($TR);
  }#
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for results (tree_result_decl <type> <name> <uid>)
(defcmatcher tree_result_decl_named
  (:tree tr)
  (:tree type :cstring name :long uid)
  treeparmd				;statesym
  :doc #{$TREE_RESULT_DECL_NAMED match a result declaration tree $TR extracting its $TYPE, $NAME, $UID}#
  ;; test expansion
  #{/* tree_result_decl_named $TREEPARMD ?*/ (($TR) && TREE_CODE($TR) == RESULT_DECL) }#
  ;; fill expansion
  #{/* tree_result_decl_named $TREEPARMD !*/
   $NAME =NULL;
   $TYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $NAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )


(defcmatcher tree_result_decl
  (:tree tr)
  (:tree tnam ttyp)
  treeresd				;statesym
  :doc #{$TREE_RESULT_DECL match a result declaration $TR extracting its tree $TNAM and $TTYP}#
  ;; test expansion
  #{ /* tree_result_decl $TREERESD ?*/ (($TR) && TREE_CODE($TR) == RESULT_DECL) }#
  ;; fill expansion
  #{ /* tree_result_decl $TREERESD !*/ 
   $TNAM = DECL_NAME($TR);
   $TTYP = TREE_TYPE($TR); 
  }# )

;; pattern for a parm_decl of given name
(defcmatcher tree_result_decl_of_name 
  (:tree tr :cstring name)
  (:tree ttyp)
  treeparmn				;statesym
  :doc #{$TREE_RESULT_DECL_OF_NAME match a result declaration $TR named $NAME extracting its $TTYP}#
  ;; test expansion
  #{ /* tree_result_decl_of_name $TREEPARMN ?*/ (($TR) && TREE_CODE($TR) == RESULT_DECL && DECL_NAME($TR) 
      && !strcmp($NAME, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_result_decl_of_name $TREEPARMN !*/ 
   $TTYP = TREE_TYPE($TR); }# )



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for defined types (tree_type_decl_with_name <type> <name> <uid>)
(defcmatcher tree_type_decl_with_name
  (:tree tr)
  (:tree type :cstring name :long uid)
  treeparmd				;statesym
  :doc #{$TREE_TYPE_DECL_WITH_NAME match a tree type decl $TR
  extracting its $TYPE, $NAME, $UID. See also $TREE_TYPE_DECL and
  $TREE_TYPE_DECL_NAMED.}#
  ;; test expansion
  #{/* tree_type_decl_with_name $TREEPARMD ?*/ (($TR) && TREE_CODE($TR) == TYPE_DECL) }#
  ;; fill expansion
  #{/* tree_type_decl_with_name $TREEPARMD !*/
   $NAME =NULL;
   $TYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $NAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )

(defcmatcher tree_type_decl
  (:tree tr)
  (:tree type name ctx orig :long uid)
  treetypd
  :doc #{$TREE_TYPE_DECL match a tree type decl $TR extracting its
  type tree as $TYPE, name tree as $NAME, context tree as $CTX,
  original type as $ORIG and long $UID. See also
  $TREE_TYPE_DECL_WITH_NAME etc...}#
  ;; test
  #{ /* tree_type_decl $TREETYPD ? */ (($TR) && TREE_CODE($TR) == TYPE_DECL) }#
  ;; fill
  #{ /* tree_type_decl $TREETYPD !*/
  $TYPE = TREE_TYPE($TR);
  $NAME = DECL_NAME($TR);
  $CTX = TYPE_CONTEXT($TR);
  $ORIG = DECL_ORIGINAL_TYPE($TR);
  $UID = DECL_UID($TR);
  }#
  )

;; pattern for a typr_decl of given name
(defcmatcher tree_type_decl_named 
  (:tree tr :cstring name)
  (:tree type)
  treetypn				;statesym
  :doc #{$TREE_TYPE_DECL match a tree type decl $TR for a type named $NAME extracting its $TYPE}#
  ;; test expansion
  #{ /* tree_type_decl_named $TREETYPN ?*/ (($TR) && TREE_CODE($TR) == TYPE_DECL && DECL_NAME($TR) 
      && !strcmp($NAME, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_type_decl_named $TREETYPN !*/ 
   $TYPE = TREE_TYPE($TR);
  }# )



;;;;;;;;;;;;;;;;
;; pattern tree_array_ref matches an array reference with array and index
(defcmatcher tree_array_ref
  (:tree tr)				;input
  (:tree trarr trindex)
  treearrayref			 ;statesym
  :doc #{$TREE_ARRAY_REF match a tree array reference extracting array $TRARR and index $TRINDEX}#
  ;; test
  #{ /* tree_array_ref $TREEARRAYREF ?*/ (($TR) && TREE_CODE($TR) == ARRAY_REF) }#
  ;; fill
  #{ /* tree_array_ref $TREEARRAYREF !*/ 
    $TRARR = TREE_OPERAND ($TR, 0);
    $TRINDEX = TREE_OPERAND ($TR, 1);
  }#)

;; pattern tree_array_ref_full
(defcmatcher  tree_array_ref_full
  (:tree tr)				;input
  (:tree trarr trindex trmin trsize)
  treearrayreffull			 ;statesym
  :doc #{$TREE_ARRAY_REF_FULL match a tree array reference extracting array $TRARR and index $TRINDEX minimum $TRMIN and size $TRSIZE}#
  ;; test
  #{ /* tree_array_ref_full $TREEARRAYREFFULL ?*/ (($TR) && TREE_CODE($TR) == ARRAY_REF) }#
  ;; fill
  #{ /* tree_array_ref_full $TREEARRAYREFFULL !*/ 
    int $TREEARRAYREFFULL#_len = TREE_OPERAND_LENGTH($TR);
    $TRARR = TREE_OPERAND ($TR, 0);
    $TRINDEX = TREE_OPERAND ($TR, 1);
    $TRMIN = ($TREEARRAYREFFULL#_len >= 3) ? TREE_OPERAND ($TR, 2) : (NULL_TREE);
    $TRSIZE = ($TREEARRAYREFFULL#_len >= 4) ? TREE_OPERAND ($TR, 3) : (NULL_TREE);
  }#)


;;;;;;;;;;;;;;;;
;; pattern tree_array_range_ref_full
(defcmatcher  tree_array_range_ref_full
  (:tree tr)				;input
  (:tree trarr trindex trmin trsize)
  treearrayrangefull			 ;statesym
  :doc #{$TREE_ARRAY_RANGE_REF_FULL match a tree array reference extracting array $TRARR and index $TRINDEX minimum $TRMIN and size $TRSIZE, for @code{ARRAY_RANGE_REF}}#
  ;; test
  #{ /* tree_array_range_ref_full $TREEARRAYRANGEFULL ?*/ (($TR) && TREE_CODE($TR) == ARRAY_RANGE_REF) }#
  ;; fill
  #{ /* tree_array_range_ref_full $TREEARRAYRANGEFULL !*/ 
    int $TREEARRAYRANGEFULL#_len = TREE_OPERAND_LENGTH($TR);
    $TRARR = TREE_OPERAND ($TR, 0);
    $TRINDEX = TREE_OPERAND ($TR, 1);
    $TRMIN = ($TREEARRAYRANGEFULL#_len >= 3) ? TREE_OPERAND ($TR, 2) : (NULL_TREE);
    $TRSIZE = ($TREEARRAYRANGEFULL#_len >= 4) ? TREE_OPERAND ($TR, 3) : (NULL_TREE);
  }#)


;;;;;;;;;;;;;;;;
(defcmatcher tree_realpart_expr
  (:tree tr)
  (:tree tpart)
  trealpartx
  :doc #{$TREE_REALPART_EXPR match and extract the real part $TPART of
  complex tree expression $TR for @code{REALPART_EXPR}.}#
  ;; test
  #{ /* tree_realpart_expr $TREALPARTX ? */ (($TR) && TREE_CODE($TR) == REALPART_EXPR) }#
  ;; fill
  #{ /* tree_realpart_expr $TREALPARTX ! */
  $TPART = TREE_OPERAND ($TR, 0);
  }#)
  
;;;;;;;;;;;;;;;;
(defcmatcher tree_imagpart_expr
  (:tree tr)
  (:tree tpart)
  timagpartx
  :doc #{$TREE_IMAGPART_EXPR match and extract the imaginary part
  $TPART of complex tree expression $TR for @code{IMAGPART_EXPR}.}#
  ;; test
  #{ /* tree_imagpart_expr $TIMAGPARTX ? */ (($TR) && TREE_CODE($TR) == IMAGPART_EXPR) }#
  ;; fill
  #{ /* tree_imagpart_expr $TIMAGPARTX ! */
  $TPART = TREE_OPERAND ($TR, 0);
  }#)
  
;;;;;;;;;;;;;;;;
(defcmatcher tree_view_convert_expr
  (:tree tr)
  (:tree tview)
  tviewconx
  :doc #{$TREE_VIEW_CONVERT_EXPR match and extract the view conversion
  of tree expression $TR for @code{VIEW_CONVERT_EXPR}.}#
  ;; test
  #{ /* tree_view_convert_expr $TVIEWCONX ? */ (($TR) && TREE_CODE($TR) == VIEW_CONVERT_EXPR) }#
  ;; fill
  #{ /* tree_view_convert_expr $TVIEWCONX ! */
  $TVIEW = TREE_OPERAND ($TR, 0);
  }#)
  
;;;;;;;;;;;;;;;;
;; pattern tree_component_ref matches an component reference with component and index
(defcmatcher tree_component_ref
  (:tree tr)				;input
  ;; traggr is the aggregate (ie a struct or union)
  (:tree traggr trfield)		;output
  treecomponentref			 ;statesym
  :doc #{$TREE_COMPONENT_REF match a component reference tree $TR extracting aggregate $TRAGGR and field $TRFIELD}#
  ;; test
  #{ /* tree_component_ref $TREECOMPONENTREF ?*/ (($TR) && TREE_CODE($TR) == COMPONENT_REF) }#
  ;; fill
  #{ /* tree_component_ref $TREECOMPONENTREF !*/ 
    $TRAGGR = TREE_OPERAND ($TR, 0);
    $TRFIELD = TREE_OPERAND ($TR, 1);
  }#)

(defcmatcher tree_component_ref_full
  (:tree tr)				;input
  ;; traggr is the aggregate (ie a struct or union)
  (:tree traggr trfield troff)
  treecomponentreffull			 ;statesym
  :doc #{$TREE_COMPONENT_REF_FULL match a component reference tree $TR extracting aggregate $TRAGGR and field $TRFIELD and offset $TROFF}#
  ;; test
  #{ /* tree_component_ref_full $TREECOMPONENTREFFULL ?*/ (($TR) && TREE_CODE($TR) == COMPONENT_REF) }#
  ;; fill
  #{ /* tree_component_ref_full $TREECOMPONENTREFFULL !*/ 
    int $TREECOMPONENTREFFULL#_len = TREE_OPERAND_LENGTH($TR);
    $TRAGGR = TREE_OPERAND ($TR, 0);
    $TRFIELD = TREE_OPERAND ($TR, 1);
    $TROFF = ($TREECOMPONENTREFFULL#_len > 2) ? TREE_OPERAND ($TR, 2) : NULL_TREE;
  }#)

(defcmatcher tree_component_ref_typed
  (:tree tr)
  (:tree type
   :tree traggr
   :tree trfield)
  treecr
  :doc #{$TREE_COMPONENT_REF_TYPED match a component reference tree $TR extracting the $TYPE, aggregate $TRAGGR, field $TRFIELD }#

  #{ /*  tree_component_ref_typed $TREECR ? */
       (($tr) && TREE_CODE ($tr) == COMPONENT_REF)
  }#

  #{/*  tree_component_ref_typed $TREECR ! */
       $TYPE = TREE_TYPE ($tr);
       $TRAGGR = TREE_OPERAND ($tr, 0);
       $TRFIELD = TREE_OPERAND ($tr, 1);
  }#)


(defcmatcher tree_bit_field_ref
  (:tree tr)
  (:tree ttyp taggr tnbits tpos)
  trbitf
  :doc #{$TREE_BIT_FIELD_REF match a bit field reference tree $TR
  extracting the type in $TTYP, the aggregate -record or union-
  expression in $TAGGR, the number of bits tree in $TNBITS, the bit
  position tree in $TPOS.}#
  ;; test
  #{ /* tree_bit_field_ref $TRBITF ? */
  (($TR) && TREE_CODE($TR) == BIT_FIELD_REF)
  }#
  ;; fill
  #{ /* tree_bit_field_ref $TRBITF ! */
  $TTYP = TREE_TYPE ($TR);
  $TAGGR = TREE_OPERAND ($TR, 0);
  $TNBITS = TREE_OPERAND ($TR, 1);
  $TPOS = TREE_OPERAND ($TR, 2);
  }#)

;; pattern tree_mem_ref matches a memory reference with pointer and offset
(defcmatcher tree_mem_ref
  (:tree tr)				;input
  (:tree trptr troff)
  treememref			 ;statesym
  :doc #{$TREE_MEM_REF match a memory reference tree extracing pointer $TRPTR and offset $TROFF}#
  ;; test
  #{ /* tree_mem_ref $TREEMEMREF ?*/ (($TR) && TREE_CODE($TR) == MEM_REF) }#
  ;; fill
  #{ /* tree_mem_ref $TREEMEMREF !*/ 
    $TRPTR = TREE_OPERAND ($TR, 0);
    $TROFF = TREE_OPERAND ($TR, 1);
  }#)

;;;;;;;;;;;;;;;;
;; pattern tree_block matches a block
(defcmatcher tree_block 
  (:tree tr)
  (					;output
   :tree trvars trsubblocks trctxt trchain trorig
   )
  treeblock				;statesym
  :doc #{$TREE_BLOCK match a tree block extracting tree variables
  $TRVARS, subblocks $TRSUBBLOCKS, supercontext $TRCTXT, chain
  $TRCHAIN, abstract origin $TRORIG.}#
  ;; test expander
   #{/*tree_block $TREEBLOCK ?*/ (($TR) && TREE_CODE($TR) == BLOCK)}#
  ;; fill expander
   #{ /*tree_block $TREEBLOCK !*/
   $TRVARS = BLOCK_VARS($TR);
   $TRSUBBLOCKS = BLOCK_SUBBLOCKS($TR);
   $TRCTXT = BLOCK_SUPERCONTEXT($TR);
   $TRCHAIN = BLOCK_CHAIN($TR);
   $TRORIG = BLOCK_ABSTRACT_ORIGIN($TR);
   }# )

;;;;;;;;;;;;;;;;
;; pattern tree_offset_type is for pointers relative to object
(defcmatcher tree_offset_type
 (:tree tr)
 (:tree trtype trbasetype)
 treeoffsettype				;statesym
  :doc #{$TREE_OFFSET_TYPE match offset type tree $TR extracting type $TRTYPE and basetype $TRBASETYPE}#
 ;; expander
 #{/*tree_offset_type $TREEOFFSETTYPE ?*/ (($TR) && TREE_CODE($TR) == OFFSET_TYPE) }#
 ;; filler
 #{/*tree_offset_type $TREEOFFSETTYPE !*/ $TRTYPE = TREE_TYPE($TR);
   $TRBASETYPE = TYPE_OFFSET_BASETYPE ($TR);
 }#)


;;;;;;;;
;;; pattern tree_identifier matches any identifier node
(defcmatcher tree_identifier
  (:tree tr)
  (:cstring name)
  treeident			;statesym
  :doc #{$TREE_IDENTIFIER match an identifier tree $TR extracting its $NAME}#
  #{ /*tree_identifier  $TREEIDENT ?*/ $TR 
         && TREE_CODE ($TR) == IDENTIFIER_NODE }#
  #{ /*tree_identifier $TREEIDENT !*/ $NAME = (const char*) IDENTIFIER_POINTER ($TR); 
}#
)

;;; pattern tree_list matches any tree list node
(defcmatcher tree_list
  (:tree tr)
  (:tree trvalue trpurpose trchain)
  treelist
  :doc #{$TREE_LIST match a tree list node extracting $TRVALUE $TRPURPOSE $TRCHAIN}#
  #{ /* tree_list $TREELIST ?*/ $TR && TREE_CODE ($TR) == TREE_LIST }#
  #{ /* tree_list $TREELIST !*/ 
    $TRVALUE = TREE_VALUE ($TR);
    $TRPURPOSE = TREE_PURPOSE ($TR);
    $TRCHAIN = TREE_CHAIN ($TR);
  }#
)

;;; iterate inside TREE_LIST
(defciterator foreach_chain_value_purpose_in_tree_list
  (:tree tr)
  eachvalpu
  (:tree trchain trval trpurp)
  :doc #{FOREACH_CHAIN_VALUE_PURPOSE_IN_TREE_LIST iterates in a
  @code{TREE_LIST} tree $TR binding $TRVAL and $TRPURP to each value
  and purpose and $TRCHAIN to the current element.}#
  ;; before
  #{ /* foreach_chain_value_purpose_in_tree_list $EACHVALPU start */
  $TRCHAIN = NULL_TREE;
  $TRVAL = NULL_TREE;
  $TRPURP = NULL_TREE;
  for ($TRCHAIN = $TR;
       $TRCHAIN && TREE_CODE($TRCHAIN) == TREE_LIST;
       $TRCHAIN = TREE_CHAIN($TRCHAIN)) {
    $TRVAL = TREE_VALUE ($TRCHAIN);
    $TRPURP = TREE_PURPOSE ($TRCHAIN);
     /* foreach_chain_value_purpose_in_tree_list $EACHVALPU started */
   }#
   ;; after
   #{  /* foreach_chain_value_purpose_in_tree_list $EACHVALPU end */
     $TRVAL = NULL_TREE;
     $TRPURP = NULL_TREE;
   };
  $TRCHAIN = NULL_TREE;
  $TRVAL = NULL_TREE;
  $TRPURP = NULL_TREE;
  /* foreach_chain_value_purpose_in_tree_list $EACHVALPU ended */
  }#
  )

;;; pattern tree_vec matches any tree vector node
(defcmatcher tree_vec
  (:tree tr)
  (:long len :tree trchain)
  treevec
  :doc #{$TREE_VEC match a tree vector node extracting $LEN and $TRCHAIN}#
  #{ /* tree_vec $TREEVEC ?*/ $TR && TREE_CODE ($TR) == TREE_VEC }#
  #{ /* tree_vec $TREEVEC !*/ 
  $LEN = TREE_VEC_LENGTH ($TR);
  $TRCHAIN = TREE_CHAIN ($TR);
  }#
)

;;;;;;;;;;;;;;;;
;;; pattern tree_decl matches any declaration
(defcmatcher tree_decl 
  (:tree tr)
  (					;output
   :tree trname
   :cstring name
   :long uid
   )
  treedecl				;statesym
  :doc #{$TREE_DECL match any declaration extracting $TRANME $NAME $UID}#
  ;; test expander
  #{/* tree_decl $TREEDECL ? */ (($tr) && DECL_P($tr))}#
  ;; fill expander
  #{/* tree_decl $TREEDECL ! */ 
   tree  $treedecl#_name = DECL_NAME($tr);
   $TRNAME = $treedecl#_name;
   $NAME = ($treedecl#_name) ? IDENTIFIER_POINTER($treedecl#_name) : NULL;
   $UID = DECL_UID($tr);
   }# )



;;;;;;;;;;;;;;;;
(defcmatcher tree_any_decl_of_context
  (:tree tr)
  (:tree tctx)
  trdeclctx
  :doc #{$TREE_ANY_DECL_OF_CONTEXT match any declaration $TR extracting its context $TCTX.}#
  ;; test
  #{ /* tree_any_decl_of_context $TRDECLCTX ? */  (($TR) && DECL_P($TR))}#
  ;; fill
  #{ /* tree_any_decl_of_context $TRDECLCTX ! */
  $TCTX = DECL_CONTEXT($TR);
  }#)


;;;;;;;;;;;;;;;;
(defcmatcher tree_any_decl_of_type_align_size
  (:tree tr)
  (:tree ttyp tsize :long lalign)
  trdecltyas
  :doc #{$TREE_ANY_DECL_OF_TYPE_ALIGN_SIZE match any declaration $TR
  extracting its type $TTYP, unit-alignment tree $TALIGN, tree-unit-size $TSIZE, alignment in bytes $LALIGN}#
  ;; test
  #{ /* tree_any_decl_of_type_align_size $TRDECLTYAS ? */  (($TR) && DECL_P($TR))}#
  ;; fill
  #{ /* tree_any_decl_of_type_align_size $TRDECLTYAS ! */
  $TTYP = TREE_TYPE($TR);
  $TSIZE = DECL_SIZE_UNIT ($TR);
  $LALIGN = DECL_ALIGN_UNIT ($TR);
  }#)
  
;;;;;;;;;;;;;;;;
(defcmatcher tree_any_decl_of_origin
  (:tree tr)
  (:tree torig)
  trdeclorig
  :doc #{$TREE_ANY_DECL_OF_ORIGIN match any declaration $TR extracting its abstract origin $TORIG.}#
  ;; test
  #{ /* tree_any_decl_of_origin $TRDECLORIG ? */ (($TR) && DECL_P($TR))}#
  ;; fill
  #{ /* tree_any_decl_of_origin $TRDECLORIG ! */
  $TORIG = DECL_ORIGIN($TR);
  }#
  )


(defcmatcher tree_any_abstract_decl
  (:tree tr)
  ()
  trabstdcl
  :doc #{$TREE_ANY_ABSTRACT_DECL match any abstract declaration $TR}#
  ;; test
  #{ /* tree_any_abstract_decl $TRABSTDCL ? */ (($TR) && DECL_P($TR)
                        && DECL_ABSTRACT_P($TR)
						)
  }#
  )
  

(defcmatcher tree_any_ignored_decl
  (:tree tr)
  ()
  trigndcl
  :doc #{$TREE_ANY_IGNORED_DECL match any ignored declaration $TR}#
  ;; test
  #{ /* tree_any_ignored_decl $TRIGNDCL ? */ (($TR) && DECL_P($TR) && DECL_IGNORED_P($TR))}#
  )
  
(defcmatcher tree_any_external_decl
  (:tree tr)
  ()
  trextdcl
  :doc #{$TREE_ANY_EXTERNAL_DECL match any external declaration $TR}#
  ;; test
  #{ /* tree_any_external_decl $TREXTDCL ? */ (($TR) && DECL_P($TR) && DECL_EXTERNAL($TR))}#
  )
  
(defcmatcher tree_any_local_decl
  (:tree tr)
  ()
  trlocdcl
  :doc #{$TREE_ANY_LOCAL_DECL match any local declaration $TR}#
  ;; test
  #{ /* tree_any_local_decl $TRLOCDCL ? */ (($TR) && DECL_P($TR) && !DECL_NONLOCAL($TR))}#
  )
  
(defcmatcher tree_any_virtual_decl
  (:tree tr)
  ()
  trvirdcl
  :doc #{$TREE_ANY_VIRTUAL_DECL match any virtual declaration $TR}#
  ;; test
  #{ /* tree_any_virtual_decl $TRVIRDCL ? */ (($TR) && DECL_P($TR) && DECL_VIRTUAL_P($TR))}#
  )
  
(defcmatcher tree_any_artificial_decl
  (:tree tr)
  ()
  trartdcl
  :doc #{$TREE_ANY_ARTIFICIAL_DECL match any artificial declaration $TR}#
  ;; test
  #{ /* tree_any_artificial_decl $TRARTDCL ? */ (($TR) && DECL_P($TR) && DECL_ARTIFICIAL($TR))}#
  )
  
(defcmatcher tree_any_nonabstract_decl
  (:tree tr)
  ()
  trabstdcl
  :doc #{$TREE_ANY_NONABSTRACT_DECL match any nonabstract declaration $TR}#
  ;; test
  #{ /* tree_any_nonabstract_decl $TRABSTDCL ? */ (($TR) && DECL_P($TR)
						   && !DECL_ABSTRACT_P($TR)   )
  }#
  )
  
  
(defcmatcher tree_any_nonartificial_decl
  (:tree tr)
  ()
  trartdcl
  :doc #{$TREE_ANY_NONARTIFICIAL_DECL match any nonartificial declaration $TR}#
  ;; test
  #{ /* tree_any_nonartificial_decl $TRARTDCL ? */ (($TR) && DECL_P($TR) && !DECL_ARTIFICIAL($TR))}#
  )
  

(defcmatcher tree_any_nonignored_decl
  (:tree tr)
  ()
  trigndcl
  :doc #{$TREE_ANY_IGNORED_DECL match any nonignored declaration $TR}#
  ;; test
  #{ /* tree_any_nonignored_decl $TRIGNDCL ? */ (($TR) && DECL_P($TR) && !DECL_IGNORED_P($TR))}#
  )
  
(defcmatcher tree_any_nonexternal_decl
  (:tree tr)
  ()
  trextdcl
  :doc #{$TREE_ANY_NONEXTERNAL_DECL match any nonexternal declaration $TR}#
  ;; test
  #{ /* tree_any_nonexternal_decl $TREXTDCL ? */ (($TR) && DECL_P($TR) && !DECL_EXTERNAL($TR))}#
  )



  
(defcmatcher tree_any_nonlocal_decl
  (:tree tr)
  ()
  trlocdcl
  :doc #{$TREE_ANY_NONLOCAL_DECL match any nonlocal declaration $TR}#
  ;; test
  #{ /* tree_any_nonlocal_decl $TRLOCDCL ? */ (($TR) && DECL_P($TR) && DECL_NONLOCAL($TR))}#
  )
  
(defcmatcher tree_any_nonvirtual_decl
  (:tree tr)
  ()
  trvirdcl
  :doc #{$TREE_ANY_NONVIRTUAL_DECL match any nonvirtual declaration $TR}#
  ;; test
  #{ /* tree_any_nonvirtual_decl $TRVIRDCL ? */ (($TR) && DECL_P($TR) && !DECL_VIRTUAL_P($TR))}#
  )
  
;;;;;;;;;;;;;;;;
(defcmatcher tree_any_decl_of_initial
  (:tree tr)
  (:tree tinit)
  trdeclinit
  :doc #{$TREE_ANY_DECL_OF_INITIAL match any declaration $TR extracting its initialization $TINIT.}#
  ;; test
  #{ /* tree_any_decl_of_initial $TRDECLINIT ? */ (($TR) && DECL_P($TR))}#
  ;; fill
  #{ /* tree_any_decl_of_initial $TRDECLINIT ! */
  $TINIT = DECL_INITIAL ($TR);
  }#
  )
  
  
;; pattern tree_decl_at_source_location matches a declaration tree with a
;; known location
(defcmatcher tree_decl_at_source_location 
  (:tree tr)
  (:value filepathv
   :long line
   :long col)
  treedeclatloc				;statesym
  :doc #{$TREE_DECL_AT_SOURCE_LOCATION match any declaration with some
  known source location, extracting the cached $FILEPATHV string value and the
  $LINE and $COL info.}#
   ;; test expander
  #{/* tree_decl_at_source_location $TREEDECLATLOC ? */ (($TR)
      && DECL_P($TR) && DECL_SOURCE_LOCATION($TR) != UNKNOWN_LOCATION)}#
   ;; test filler
  #{/* tree_decl_at_source_location $TREEDECLATLOC ! */ {
     source_location $TREEDECLATLOC#_sloc = DECL_SOURCE_LOCATION($tr);
     $FILEPATHV =
         meltgc_cached_string_path_of_source_location ($TREEDECLATLOC#_sloc);
     $LINE = LOCATION_LINE ($TREEDECLATLOC#_sloc);
     $COL = LOCATION_COLUMN ($TREEDECLATLOC#_sloc);
   } /* end tree_decl_at_source_location $TREEDECLATLOC */ }#)


;; pattern tree_decl_at_source_location matches a declaration tree with a
;; known location
(defcmatcher tree_expr_at_source_location 
  (:tree tr)
  (:value filepathv
   :long line
   :long col)
  treeexpratloc				;statesym
  :doc #{$TREE_EXPR_AT_SOURCE_LOCATION match any expression with some
  known source location, extracting the cached $FILEPATHV string value and the
  $LINE and $COL info.}#
   ;; test expander
  #{/* tree_expr_at_source_location $TREEEXPRATLOC ? */ (($TR)
      && EXPR_P($TR) && EXPR_LOCATION($TR) != UNKNOWN_LOCATION)}#
   ;; test filler
  #{/* tree_expr_at_source_location $TREEEXPRATLOC ! */ {
     source_location $TREEEXPRATLOC#_sloc = EXPR_LOCATION($tr);
     $FILEPATHV =
         meltgc_cached_string_path_of_source_location ($TREEEXPRATLOC#_sloc);
     $LINE = LOCATION_LINE ($TREEEXPRATLOC#_sloc);
     $COL = LOCATION_COLUMN ($TREEEXPRATLOC#_sloc);
   } /* end tree_expr_at_source_location $TREEEXPRATLOC */ }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_any_type
  (:tree tr)
  ()
  tranytyp
  :doc #{$TREE_ANY_TYPE matches any type tree.}#
  ;;test
  #{ /* tree_any_type $TRANYTYP ? */ (($TR) && TYPE_P($TR)) }#
  )

;;;;;;;;;;;;;;;;
(defcmatcher tree_any_type_of_size
  (:tree tr)
  (:tree trsize)
  trsizmod
  :doc #{$TREE_ANY_TYPE_OF_SIZE matches any type tree and extracts its size.}#
  ;;test
  #{ /* tree_any_type_of_size $TRSIZMOD ? */ (($TR) && TYPE_P($TR)) }#
  ;;fill
  #{ /* tree_any_type_of_size $TRSIZMOD ! */
  $TRSIZE = TYPE_SIZE($TR);
  }#)
;;;;;;;;;;;;;;;;

(defcmatcher tree_any_type_of_pointer_to
  (:tree tr)
  (:tree tptrto)
  trpointerto
  :doc #{$TREE_ANY_TYPE_OF_POINTER_TO matches any type tree and
  extracts its pointer to field $TPTRTO.}#
  ;;test
  #{ /* tree_any_type_of_pointer_to $TRPOINTERTO ? */ (($TR) && TYPE_P($TR)) }#
  ;;fill
  #{ /* tree_any_type_of_pointer_to $TRPOINTERTO ! */
  $TPTRTO = TYPE_POINTER_TO($TR);
  }#)

;;;;;;;;;;;;;;;;

(defcmatcher tree_any_type_of_variant
  (:tree tr)
  (:tree tnextvariant tmainvariant)
  trtypvariant
  :doc #{$TREE_ANY_TYPE_OF_VARIANT matches any type tree and
  extracts its next variant $TNEXTVARIANT and main variant TMAINVARIANT fields.}#
  ;;test
  #{ /* tree_any_type_of_variant $TRTYPVARIANT ? */ (($TR) && TYPE_P($TR)) }#
  ;;fill
  #{ /* tree_any_type_of_variant $TRTYPVARIANT ! */
  $TNEXTVARIANT = TYPE_NEXT_VARIANT($TR);
  $TMAINVARIANT = TYPE_MAIN_VARIANT($TR);
  }#)
  
(defcmatcher tree_any_type_of_chain
  (:tree tr)
  (:tree tchain)
  trtypchain
  :doc #{$TREE_ANY_TYPE_OF_VARIANT matches any type tree and
  extracts its chain $TCHAIN field.}#
  ;;test
  #{ /* tree_any_type_of_chain $TRTYPCHAIN ? */ (($TR) && TYPE_P($TR)) }#
  ;;fill
  #{ /* tree_any_type_of_chain $TRTYPCHAIN ! */
  $TCHAIN = TREE_CHAIN($TR);
  }#)
  
(defcmatcher tree_any_type_of_context
  (:tree tr)
  (:tree tctx)
  trtypcontext
  :doc #{$TREE_ANY_TYPE_OF_CONTEXT matches any type tree and
  extracts its $TCTX context field.}#
  ;;test
  #{ /* tree_any_type_of_context $TRTYPCONTEXT ? */ (($TR) && TYPE_P($TR)) }#
  ;;fill
  #{ /* tree_any_type_of_context $TRTYPCONTEXT ! */
  $TCTX = TYPE_CONTEXT($TR);
  }#)
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; pattern tree_void_type
(defcmatcher tree_void_type
  (:tree tr)
  (:tree type)
  treevt
  :doc #{$TREE_VOID_TYPE match a void type $TR extracting its type $TYPE}#

  #{ /* tree_void_type $TREEVT ? */
       (($tr) && TREE_CODE ($tr) == VOID_TYPE)
  }#

  #{/* tree_void_type $TREEVT ! */
       $type = TYPE_NAME ($tr);
  }#)

;;;;;;;;;;;;;;;;
;;; pattern tree_integer_type
(defcmatcher tree_integer_type 
  (:tree tr)
  (					;output
   :tree type
   :value minbig maxbig 
   :tree size
   )
  treeinty				;statesym
  :doc #{$TREE_INTEGER_TYPE match an integer type tree $TR extracting its
  $TYPE and big minimal $MINBIG and maximal $MAXBIG values and tree size $SIZE.
  If minimal and maximal values are small enough, we use plain boxed integer values.}#
  ;; test expander
   #{ /* tree_integer_type $TREEINTY ?*/ (($tr) && TREE_CODE($tr) == INTEGER_TYPE) }#
  ;; fill expander
   #{ /* tree_integer_type $TREEINTY !*/
      mpz_t $TREEINTY#_minz;
      mpz_t $TREEINTY#_maxz;

      $TYPE = TYPE_NAME($tr);
      $SIZE = TYPE_SIZE($tr);
      mpz_init ($TREEINTY#_minz);
      mpz_init ($TREEINTY#_maxz);
      get_type_static_bounds($TR, $TREEINTY#_minz, $TREEINTY#_maxz);

      if (mpz_cmp_si ($TREEINTY#_minz, -(LONG_MAX/2))>=0
                    && mpz_cmp_si($TREEINTY#_minz, (LONG_MAX/2))<=0)
        $MINBIG = meltgc_new_int ((meltobject_ptr_t)MELT_PREDEF(DISCR_CONSTANT_INTEGER),
                                 mpz_get_si($TREEINTY#_minz));
      else
        $MINBIG = meltgc_new_mixbigint_mpz((meltobject_ptr_t) MELT_PREDEF (DISCR_MIXED_BIGINT), 
                                        NULL, 
                                        $TREEINTY#_minz);
      if (mpz_cmp_si($TREEINTY#_maxz, -(LONG_MAX/2))>=0
                    && mpz_cmp_si($TREEINTY#_maxz, (LONG_MAX/2))<=0)
      $MAXBIG = meltgc_new_int ((meltobject_ptr_t)MELT_PREDEF(DISCR_CONSTANT_INTEGER),
                               mpz_get_si($TREEINTY#_maxz));
      else
        $MAXBIG = meltgc_new_mixbigint_mpz((meltobject_ptr_t) MELT_PREDEF (DISCR_MIXED_BIGINT), 
                                        NULL, 
                                        $TREEINTY#_maxz);
      mpz_clear ($treeinty#_minz);
      mpz_clear ($treeinty#_maxz);

      }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_enumeral_type
  (:tree tr)
  (:tree ttype
   :tree tmin tmax
   :tree tsize
   :tree tvalues)
  treeenumtype
  :doc #{$TREE_ENUMERAL_TYPE match a tree $TR enumeral extracting $TTYPE $TMIN $TMAX $TSIZE $TVALUES}#
  ;; test
  #{/* tree_enumeral_type $TREEENUMTYPE ?*/ (($TR) && TREE_CODE($TR) == ENUMERAL_TYPE) }#
  ;; fill
  #{/* tree_enumeral_type $TREEENUMTYPE !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);
      $TVALUES = TYPE_VALUES ($TR); }#
)

;;;;;;;;;;;;;;;;;
(defcmatcher tree_boolean_type
  (:tree tr)
  (:tree ttype
   :tree tmin tmax
   :tree tsize
  )
  treebooltype
  :doc #{$TREE_BOOLEAN_TYPE match a boolean type tree $TR extracting $TTYPE $TMIN $TMAX $TSIZE}#
  ;; test
  #{/* tree_boolean_type $TREEBOOLTYPE ?*/ (($TR) && TREE_CODE($TR) == BOOLEAN_TYPE) }#
  ;; fill
  #{/* tree_boolean_type $TREEBOOLTYPE !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);}#
)


;;;;;;;;;;;;;;;;
;;; pattern tree_integer_type_bounded, the bounds are trees
(defcmatcher tree_integer_type_bounded
  (:tree tr)
  (					;output
   :tree ttype
   :tree tmin tmax
   :tree tsize
   )
  treeintybnd				;statesym
  :doc #{$TREE_INTEGER_TYPE_BOUNDED match an integer type tree $TR  extracting $TTYPE $TMIN $TMAX $TSIZE}#
  ;; test expander
   #{ /* tree_integer_type_bounded $TREEINTYBND ?*/ (($TR) && TREE_CODE($TR) == INTEGER_TYPE) }#
  ;; fill expander
   #{ /* tree_integer_type_bounded $TREEINTYBND !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);
    }#)


;;;; pattern for fixed point type

(defcmatcher tree_fixed_point_type
  (:tree tr)
  (					;output
   :tree ttype
   :tree tmin tmax
   :tree tsize
   )
  treefixpt				;statesym
  :doc #{$TREE_FIXED_POINT_TYPE match an fixed point type tree $TR  extracting $TTYPE $TMIN $TMAX $TSIZE}#
  ;; test expander
   #{ /* tree_fixed_point_type $TREEFIXPT ?*/ (($TR) && TREE_CODE($TR) == FIXED_POINT_TYPE) }#
  ;; fill expander
   #{ /* tree_fixed_point_type $TREEFIXPT !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);
    }#)

;;;; pattern for the type of nullptr
(defcmatcher tree_nullptr_type 
  (:tree tr)
  ()
  treenullptr
  :doc #{$TREE_NULLPTR_TYPE match an nullptr type tree $TR }#
  #{ /* tree_nullptr_type $TREENULLPTR ?*/ (($TR) && TREE_CODE($TR) == NULLPTR_TYPE) }#
  #{ /* tree_nullptr_type $TREENULLPTR !*/ }#
)


;; Pattern tree_type_declaration. 
(defcmatcher tree_type_declaration
  (:tree tr)
  (:tree name)
  titd
  :doc #{$TREE_TYPE_DECLARATION match a type decl tree $TR extracting the declared name tree $NAME}#
  #{ /* tree_type_declaration $TITD ? */
      (($TR) && TREE_CODE($TR) == TYPE_DECL)
  }#

  #{ /* tree_type_declaration $TITD ! */
      $NAME = DECL_NAME($TR);
  }#)

;;; pattern tree_real_type. It matches any real type.
;;; asked by Marie Krumpe.
(defcmatcher tree_real_type 
  (:tree tr)
  (					;output
   :tree name
   :tree size
  )
  tranyfloaty
  :doc #{$TREE_REAL_TYPE match any real type tree $TR extracting its $NAME & $SIZE trees }#

  #{ /*  tree_real_type $tranyfloaty ? */ 
      (($tr) && TREE_CODE($tr) == REAL_TYPE)
  }#

  #{ /*  tree_real_type $tranyfloaty ! */
      $NAME = TYPE_NAME($tr);
      $SIZE = TYPE_SIZE($tr);
  }#
)

;;; pattern tree_complex_type. It matches any complex type.
(defcmatcher tree_complex_type 
  (:tree tr)
  (					;output
   :tree name
   :tree size
  )
  tranycplxy
  :doc #{$TREE_COMPLEX_TYPE match any complex type tree $TR extracting its $NAME & $SIZE trees }#

  #{ /* tree_complex_type $TRANYCPLXY ? */ 
      (($tr) && TREE_CODE($tr) == COMPLEX_TYPE)
  }#

  #{ /* tree_complex_type $TRANYCPLXY ! */
      $NAME = TYPE_NAME($tr);
      $SIZE = TYPE_SIZE($tr);
  }#
)


;;;;;;;;;;;;;;;;
(defcmatcher tree_vector_type
  (:tree tr)
  (:tree trtyp :long lprec)
  treevectyp
  :doc #{ $TREE_VECTOR_TYPE match a vector type, extracting in $TRTYP
  the data type of vector elements and in $LPREC the precision,
  i.e. number of subparts}#
  ;; test
  #{ /* tree_vector_type $TREEVECTYP ? */ (($TR)
					   && TREE_CODE($TR)==VECTOR_TYPE)
  }#
  ;; fill
  #{ /* tree_vector_type $TREEVECTYP ! */
  $TRTYP = TREE_TYPE($TR);
  $LPREC = TYPE_PRECISION($TR);
  }#
  )

;;;;;;;;;;;;;;;;
;;; pattern tree_integer_cst
(defcmatcher tree_integer_cst
  (:tree tr)
  (					;output
   :long n )
  treeintk
  :doc #{ $TREE_INTEGER_CST match a constant integer tree $TR extracting the constant $N. Might behave strangely if the constant don't fit in a long.}#
  ;; test expander
  #{ /*tree_integer_cst $TREEINTK ?*/
  (($TR) && TREE_CODE($TR) == INTEGER_CST 
         && tree_fits_shwi_p ($TR))
  }#
  ;; fill expander
  #{ /*tree_integer_cst $TREEINTK !*/
    $N = tree_to_shwi(($TR)); 
  }#  )


;;; pattern tree_real_cst
(defcmatcher tree_real_cst
  (:tree tr)
  (:value v)
  treerealc
  :doc #{ $TREE_REAL_CST match a constant real tree $TR extracting the constant into a value $V}#
  ;; test expander 
  #{ /* tree_real_cst $treerealc ?*/ (($tr) && TREE_CODE($tr) == REAL_CST) }#
  ;; fill expander
  #{ /* tree_real_cst treerealc! */
  $v = meltgc_new_real ((meltobject_ptr_t) MELT_PREDEF (DISCR_REAL), 
                       TREE_REAL_CST(($tr))); }#
)

;;;;;;;
(defcmatcher tree_fixed_cst
  (:tree tr)
  ()
  treefixk
  :doc #{ $TREE_FIXED_CST match a fixed constant.}#
  ;; test expander
  #{ /* tree_fixed_cst $TREEFIXK ? */ (($TR) && TREE_CODE($TR) == FIXED_CST) }#
  ;; fill
  #{ /* tree_fixed_cst $TREEFIXK ! */ 
  }#)


;;;;;;;
(defcmatcher tree_complex_cst
  (:tree tr)
  (:tree trreal trimag)
  treecplxk
  :doc #{ $TREE_COMPELX_CST match a complex constant extracting real part in $TRREAL and imaginary part in $TRIMAG.}#
  ;; test expander
  #{ /* tree_complex_cst $TREECPLXK ? */ (($TR) && TREE_CODE($TR) == COMPLEX_CST) }#
  ;; fill
  #{ /* tree_complex_cst $TREECPLXK ! */
  $TRREAL = TREE_REALPART($TR);
  $TRIMAG = TREE_IMAGPART($TR);
  }#)

;;;;;;
(defcmatcher tree_vector_cst
  (:tree tr)
  (:long lcnt)
  treeveck
  :doc #{ $TREE_VECTOR_CST match a vector constant extractings its count in $LCNT }#
  ;; test
  #{ /* tree_vector_cst $TREEVECK ? */ (($TR) && TREE_CODE($TR) == VECTOR_CST) }#
  ;; fill
  #{  /* tree_vector_cst $TREEVECK ! */ $LCNT = VECTOR_CST_NELTS($TR);
  }#
  )

;;;;;;;
(defcmatcher tree_string_cst
  (:tree tr)
  (:value v)
  treestringc
  :doc #{ $TREE_STRING_CST match a constant string tree $TR extracting its string into value $V}#
  ;; test expander
  #{   /* tree_string_cst $treestringc ? */
       (($tr) && TREE_CODE ($tr) == STRING_CST)
  }#
  ;; fill expander
  #{   /* tree_string_cst $treestringc ! */
       $v = meltgc_new_string_raw_len ((meltobject_ptr_t) MELT_PREDEF (DISCR_STRING),
				       TREE_STRING_POINTER ($tr),
				       TREE_STRING_LENGTH ($tr));
  }#)

;;; pattern for  types
(defcmatcher tree_type_p
  (:tree tr)
  (:tree typetr)
  treetypet
  :doc #{$TREE_TYPE_P match a type tree $TR and extract the inside type $TYPETR}#
  ;; test
  #{ /*tree_type_p $TREETYPET ?*/ (($TR) && TYPE_P(($TR))) }#
  ;; fill
  #{ /*tree_type_p $TREETYPET !*/ $TYPETR = TREE_TYPE($TR); }#
)

(defcmatcher tree_type_canonical
  (:tree tr)
  (:tree trcan)
  treetypcanon
  :doc #{$TREE_TYPE_CANONICAL match a type tree $TR and extract its canonical type.}#
  ;; test expansion
  #{ /* tree_type_canonical $TREETYPCANON ? */ (($TR) && TYPE_P(($TR))) }#
  ;; fill expansion
  #{ /* tree_type_canonical $TREETYPCANON ! */
    $TRCAN = TYPE_CANONICAL($TR);
  }#)
  
  
;;; pattern for pointer types (or reference type)
(defcmatcher tree_pointer_type_p
  (:tree tr)
  (:tree typetr)
  treeisptrt
  :doc #{$TREE_POINTER_TYPE_P match a pointer type tree $TR and extract the pointed type $TYPETR}#
  ;; test
  #{ /*tree_pointer_type_p $treeisptrt ?*/ (($tr) && POINTER_TYPE_P(($tr))) }#
  ;; fill
  #{ /*tree_pointer_type_p $treeisptrt !*/ $typetr = TREE_TYPE($tr); }#
)

(defcmatcher tree_pointer_type
  (:tree tr)
  (:tree typetr)
  treeptrty
  :doc #{$TREE_POINTER_TYPE_P match or build a POINTER_TYPE tree $TR and extract the pointed type $TYPETR}#
  ;; test
  #{ /*  tree_pointer_type $TREEPTRTY ?*/ (($TR) && TREE_CODE($TR) == POINTER_TYPE) }#
  ;; fill
  #{ /* tree_pointer_type $TREEPTRTY !*/ $TYPETR = TREE_TYPE($TR); }#
  ;; operator
  #{ /* tree_pointer_type: */ build_pointer_type(($TYPETR)) }#
)

(defcmatcher tree_reference_type
  (:tree tr)
  (:tree typetr)
  treerefty
  :doc #{$TREE_REFERENCE_TYPE match a REFERENCE_TYPE tree $TR extracting the $TYPETR}#
  ;; test
  #{ /* tree_reference_type $TREEREFTY ?*/ (($TR) && TREE_CODE($TR) == REFERENCE_TYPE) }#
  ;; fill
  #{ /* tree_reference_type $TREEREFTY !*/ $TYPETR = TREE_TYPE($TR); }#
  ;; operator
  #{ /* tree_reference_type: */ build_reference_type(($TYPETR)) }#
)


;;; pattern for indirect references
(defcmatcher tree_indirect_reference
  (:tree tr)
  (:tree type
   :tree reference)
  treeir
  :doc #{$TREE_INDIRECT_REFERENCE match an indirect ref tree $TR extracting the $TYPE and $REFERENCE subtrees}#
  #{ /* tree_indirect_reference $TREEIR ? */
       (($tr) && INDIRECT_REF_P ($tr))
  }#

  #{ /* tree_indirect_reference $TREEIR ! */
       $type = TREE_TYPE ($tr);
       $reference = TREE_OPERAND ($tr, 0);
  }#)


;;;;;;;;;;;;;;;;
(defcmatcher tree_obj_type_ref
  (:tree tr)
  (:tree trefexp trefobj ttoken)
  trobjtyref
  :doc #{$TREE_OBJ_TYPE_REF match an @code{OBJ_TYPE_REF} tree $TR for
  vtable lookup. $TREFEXPR is the tree of the expression value,
  $TREFOBJ is the object on whose behalf the lookup is performed,
  $TTOKEN is a tree integerer token, index into the vtable.}#
  ;; test
  #{ /* tree_obj_type_ref $TROBJTYREF ? */ (($TR) && TREE_CODE($TR) == OBJ_TYPE_REF) }#
  ;; fill
  #{ /* tree_obj_type_ref $TROBJTYREF ! */
  $TREFEXP = OBJ_TYPE_REF_EXPR ($TR);
  $TREFOBJ = OBJ_TYPE_REF_OBJECT ($TR);
  $TTOKEN = OBJ_TYPE_REF_TOKEN ($TR);
  }#)
  

(defcmatcher tree_constructor
  (:tree tr)
  (:long nelts)
  trconstructor
  :doc #{$TREE_CONSTRUCTOR match an @code{CONSTRUCTOR} node for
  initialization of aggregates and gives into $NELTS the number of
  initialization elements.}#
  ;; test
  #{ /* tree_constructor $TRCONSTRUCTOR ? */ (($TR) && TREE_CODE($TR) == CONSTRUCTOR) }#
  ;; fill
  #{ /* tree_constructor $TRCONSTRUCTOR ! */
  $NELTS = CONSTRUCTOR_NELTS($TR);
  }#)



;;;;;;;;;;;;;;;;
(defciterator foreach_element_in_tree_constructor
  (:tree trcons)
  eachelcon
  (:tree tindex tvalue :long num)
  :doc #{$FOREACH_ELEMENT_IN_TREE_CONSTRUCTOR iterates using
  @code{FOR_EACH_CONSTRUCTOR_ELT} over the @code{CONSTRUCTOR} tree
  $TRCONS, binding the "index" or "field" to $TINDEX, the
  corresponding "value" to $TVALUE, and the current rank to $NUM.}#
  ;; before
  #{ /* foreach_element_in_tree_constructor $EACHELCON start */
  if ($TRCONS && TREE_CODE($TRCONS) == CONSTRUCTOR) {
    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS ($TRCONS), $NUM, $TINDEX, $TVALUE) {
  }#
  ;; after
  #{ /* foreach_element_in_tree_constructor $EACHELCON ending */
  } // end FOR_EACH_CONSTRUCTOR_ELT 
  } // end if $TRCONS
  }#
)



;;;;;;;;;;;;;;;;
(defcmatcher tree_compound_expr
  (:tree tr)
  (:tree tleft tright)
  trcompnd
  :doc #{$TREE_COMPOUND_EXPR match @code{COMPOUND_EXPR} tree $TR for comma operator extracting its $TLEFT and $TRIGHT operands.}#
  ;; test
  #{ /* tree_compound_expr $TRCOMPND ? */ (($TR)
					   && TREE_CODE($TR) == COMPOUND_EXPR)
  }#
  ;; fill
  #{ /* tree_compound_expr $TRCOMPND ! */
  $TLEFT = TREE_OPERAND ($TR, 0);
  $TRIGHT = TREE_OPERAND ($TR, 1);
  }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_modify_expr
  (:tree tr)
  (:tree tleft tright)
  trmodif
  :doc #{$TREE_MODIFY_EXPR match @code{MODIFY_EXPR} tree $TR for
  assignment extracting its $TLEFT and $TRIGHT operands.}#
  ;; test
  #{ /* tree_modify_expr $TRMODIF ? */ (($TR)
					   && TREE_CODE($TR) == COMPOUND_EXPR)
  }#
  ;; fill
  #{ /* tree_modify_expr $TRMODIF ! */
  $TLEFT = TREE_OPERAND ($TR, 0);
  $TRIGHT = TREE_OPERAND ($TR, 1);
  }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_init_expr
  (:tree tr)
  (:tree tleft tright)
  trinit
  :doc #{$TREE_INIT_EXPR match @code{INIT_EXPR} tree $TR for
  initialization extracting its $TLEFT and $TRIGHT operands.}#
  ;; test
  #{ /* tree_init_expr $TRINIT ? */ (($TR) && TREE_CODE($TR) == INIT_EXPR)
  }#
  ;; fill
  #{ /* tree_init_expr $TRINIT ! */
  $TLEFT = TREE_OPERAND ($TR, 0);
  $TRIGHT = TREE_OPERAND ($TR, 1);
  }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_target_expr
  (:tree tr)
  (:tree ttarget tinit tcleanup tsaved)
  trtarget
  :doc #{$TREE_TARGET_EXPR match @code{TARGET_EXPR} tree $TR for
  initialization extracting its $TTARGET, $TINIT, $TCLEANUP, $TSAVED operands.}#
  ;; test
  #{ /* tree_target_expr $TRTARGET ? */ (($TR) && TREE_CODE($TR) == TARGET_EXPR)
  }#
  ;; fill
  #{ /* tree_target_expr $TRTARGET ! */
  $TTARGET = TREE_OPERAND ($TR, 0);
  $TINIT = TREE_OPERAND ($TR, 1);
  $TCLEANUP = TREE_OPERAND ($TR, 2);
  $TSAVED = TREE_OPERAND ($TR, 3);
  }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_addr_expr
  (:tree tr)
  (:tree type
   :tree expr)
  treeae
  :doc #{$TREE_ADDR_EXPR match an @code{ADDR_EXPR} tree $TR extracting the $TYPE and $EXPR subtrees}#

  #{ /*  tree_addr_expr $TREEAE ?*/
       (($tr) && TREE_CODE ($tr) == ADDR_EXPR)
  }#

  #{ /*  tree_addr_expr $TREEAE !*/
       $TYPE = TREE_TYPE ($tr);
       $EXPR = TREE_OPERAND ($tr, 0);
  }#

  #{ /* tree_addr_expr: */ (($TYPE != NULL && $EXPR != NULL)
			    ? build_fold_addr_expr_with_type((tree)$EXPR, (tree)$TYPE)
			    : (tree)NULL) 
  }#
)

;;;;;;;;;;;;;;;;
(defcmatcher tree_cond_expr
  (:tree tr)
  (:tree ttest tthen telse)
  trcond
  :doc #{$TREE_COND_EXPR match @code{COND_EXPR} trees filling $TTEST $TTHEN $TELSE}#
  ;; test
  #{ /* tree_cond_expr $TRCOND ? */ (($TR) && TREE_CODE($TR)==COND_EXPR) }#
  ;; fill
  #{ /* tree_cond_expr $TRCOND ! */
  $TTEST = TREE_OPERAND($TR, 0);
  $TTHEN = TREE_OPERAND($TR, 1);
  $TELSE = TREE_OPERAND($TR, 2);
  }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_vec_cond_expr
  (:tree tr)
  (:tree ttest tthen telse)
  trvcond
  :doc #{$TREE_VEC_COND_EXPR match @code{VEC_COND_EXPR} trees filling $TTEST $TTHEN $TELSE}#
  ;; test
  #{ /* tree_vec_cond_expr $TRVCOND ? */ (($TR) && TREE_CODE($TR) == VEC_COND_EXPR) }#
  ;; fill
  #{ /* tree_vec_cond_expr $TRVCOND ! */
  $TTEST = TREE_OPERAND($TR, 0);
  $TTHEN = TREE_OPERAND($TR, 1);
  $TELSE = TREE_OPERAND($TR, 2);
  }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_vec_perm_expr
  (:tree tr)
  (:tree tv0 tv1 tmask)
  trvperm
  :doc #{$TREE_VEC_PERM_EXPR match @code{VEC_PERM_EXPR} trees filling $TV0, $TV1, $TMASK}#
  ;; test
  #{ /* tree_vec_perm_expr $TRVPERM ? */ (($TR) && TREE_CODE($TR) == VEC_PERM_EXPR) }#
  ;; fill
  #{ /* tree_vec_perm_expr $TRVPERM ! */
  $TV0 = TREE_OPERAND($TR, 0);
  $TV1 = TREE_OPERAND($TR, 1);
  $TMASK = TREE_OPERAND($TR, 2);
  }#)


;;;;;;;;;;;;;;;;
(defcmatcher tree_bind_expr
  (:tree tr)
  (:tree tbvars tbody tblock)
  trbind
  :doc #{$TREE_BIND_EXPR match @code{BIND_EXPR} trees filling $TBVARS, $TBODY, TBLOCK}#
  ;;test
  #{ /* tree_bind_expr $TRBIND ? */ (($TR) && TREE_CODE($TR) == BIND_EXPR) }#
  ;;fill
  #{ /* tree_bind_expr $TRBIND ! */
  $TBVARS = BIND_EXPR_VARS($TR);
  $TBODY = BIND_EXPR_BODY($TR);
  $TBLOCK = BIND_EXPR_BLOCK($TR);
  }#)


;;;;;;;;
(defcmatcher tree_with_cleanup_expr
  (:tree tr)
  (:tree texp)
  twclean
  :doc #{$TREE_WITH_CLEANUP_EXPR match tree of @code{WITH_CLEANUP_EXPR} extracting their $TEXP}#
  ;; test
  #{ /* tree_with_cleanup_expr $TWCLEAN ? */ (($TR) && TREE_CODE($TR) == WITH_CLEANUP_EXPR) }#
  ;; fill
  #{  /* tree_with_cleanup_expr $TWCLEAN ! */
  $TEXP = TREE_OPERAND($TR, 0);
  }#)

;;;;;;;;
(defcmatcher tree_cleanup_point_expr
  (:tree tr)
  (:tree texp)
  tpclean
  :doc #{$TREE_CLEANUP_POINT_EXPR match tree of @code{CLEANUP_POINT_EXPR} extracting their $TEXP}#
  ;; test
  #{ /* tree_cleanup_point_expr $TPCLEAN ? */ (($TR) && TREE_CODE($TR) == CLEANUP_POINT_EXPR) }#
  ;; fill
  #{  /* tree_cleanup_point_expr $TPCLEAN ! */
  $TEXP = TREE_OPERAND($TR, 0);
  }#)

;;;;;;;;
(defcmatcher tree_placeholder_expr
  (:tree tr)
  ()
  tplach
  :doc #{$TREE_PLACEHOLDER_EXPR is used to match @code{PLACEHOLDER_EXPR} trees.}#
  ;; test
  #{ /* tree_placeholder_expr $TPLACH ? */ (($TR) && TREE_CODE($TR) == PLACEHOLDER_EXPR) }#
  )

;;;;;;;;;;;;;;;;
(defcmatcher tree_va_arg_expr
  (:tree tr)
  (:tree trva trtype)
  treeva
  :doc #{$TREE_VA_ARG_EPXR is used for @code{va_arg} in variadic functions.}#
  #{ /* tree_va_arg_expr $TREEVA ?*/
  (($TR) && TREE_CODE ($TR) == VA_ARG_EXPR)
  }#
  #{ /* tree_va_arg_expr $TREEVA !*/
     $TRVA = TREE_OPERAND ($TR, 0);
     $TRTYPE = TREE_TYPE ($TR);
  }#
)
;;;;;;;;
(defcmatcher tree_record_type
  (:tree tr)
  (:tree name)
  treerectyp

  :doc #{$TREE_RECORD_TYPE match a record type tree $TR extracting its $NAME }#
  #{ /*  tree_record_type $TREERECTYP ? */
       (($TR) && TREE_CODE ($TR) == RECORD_TYPE)
  }#
  #{ /*  tree_record_type $TREERECTYP ! */
       $NAME = TYPE_NAME ($TR);
  }#)

(defcmatcher tree_record_type_with_fields
  (:tree tr)
  (:tree tname tfields)
  trectyfld
  :doc #{$TREE_RECORD_TYPE_WITH_FIELDS match a record type tree $TR extracting its $TNAME & $TFIELDS}#
  #{  /*  tree_record_type_with_fields $TRECTYFLD ? */
       (($TR) && TREE_CODE ($TR) == RECORD_TYPE)
  }#
  #{ /*  tree_record_type_with_fields $TRECTYFLD ! */
       $TNAME = TYPE_NAME ($TR);
       $TFIELDS = TYPE_FIELDS ($TR);
  }#)


;; qualified union
(defcmatcher tree_qual_union_type
  (:tree tr)
  (:tree type)
  treequunityp
  :doc #{$TREE_QUAL_UNION_TYPE match a qualified union type tree $TR extracting its $TYPE}#

  #{ /* tree_qual_union_type $TREEQUUNITYP ? */
       (($TR) && TREE_CODE ($TR) == QUAL_UNION_TYPE)
  }#
  #{ /* tree_qual_union_type  $TREEQUUNITYP ! */
       $TYPE = TYPE_NAME ($TR);
  }#)

(defcmatcher tree_qual_union_type_with_fields
  (:tree tr)
  (:tree type tfields)
  tquunityfld
  :doc #{$TREE_QUAL_UNION_TYPE_WITH_FIELDS match a qualified union type tree $TR extracting its $TYPE & $TFIELDS}#

  #{  /* tree_qual_union_type_with_fields $TQUUNITYFLD ? */
       (($TR) && TREE_CODE ($TR) == QUAL_UNION_TYPE)
  }#
  #{ /* tree_qual_union_type_with_fields $TQUUNITYFLD ! */
       $TYPE = TYPE_NAME ($TR);
       $TFIELDS = TYPE_FIELDS ($TR);
  }#)


(defcmatcher tree_union_type
  (:tree tr)
  (:tree type)
  treeplunityp
  :doc #{$TREE_UNION_TYPE match a plain union type tree $TR extracting its $TYPE}#

  #{ /* tree_union_type $TREEPLUNITYP ? */
       (($TR) && TREE_CODE ($TR) == UNION_TYPE)
  }#
  #{ /* tree_union_type  $TREEPLUNITYP ! */
       $TYPE = TYPE_NAME ($TR);
  }#)

(defcmatcher tree_union_type_with_fields
  (:tree tr)
  (:tree type tfields)
  tplunityfld
  :doc #{$TREE_UNION_TYPE_WITH_FIELDS match a plain union type tree $TR extracting its $TYPE & $TFIELDS}#

  #{  /* tree_union_type_with_fields $TPLUNITYFLD ? */
       (($TR) && TREE_CODE ($TR) == UNION_TYPE)
  }#
  #{ /* tree_union_type_with_fields $TPLUNITYFLD ! */
       $TYPE = TYPE_NAME ($TR);
       $TFIELDS = TYPE_FIELDS ($TR);
  }#)


(defcmatcher tree_array_type
  (:tree tr)
  (:tree telemtype tdomaintype)
  treearrtyp
  :doc #{$TREE_ARRAY_TYPE match an array type tree $TR extracting the elements tpe $TELEMTYPE and the domain type $TDOMAINTYPE}#
  #{ /* tree_array_type $TREEARRTYP ? */
  (($TR) && TREE_CODE ($TR) == ARRAY_TYPE)
  }#
  #{ /* tree_array_type $TREEARRTYP ! */
  $TELEMTYPE = TREE_TYPE ($TR);
  $TDOMAINTYPE = TYPE_DOMAIN ($TR);
  }#
  #{ /* tree_array_type: */
  build_array_type ($TELEMTYPE, $TDOMAINTYPE)
  }#
  )


(defcmatcher tree_field_decl
  (:tree tr)
  (:tree name type)
  treefield
  :doc #{$TREE_FIELD_DECL match a field declaration tree $TR extracting $NAME & $TYPE}#
  #{ /*  tree_field_decl $TREEFIELD ? */
       (($TR) && TREE_CODE ($TR) == FIELD_DECL)
  }#
  #{ /*  tree_field_decl $TREEFIELD ! */
       $NAME = DECL_NAME ($TR);
       $TYPE = TREE_TYPE ($TR);
  }#)

;;;; matcher for pattern ssa_name
(defcmatcher tree_ssa_name 
  (:tree tr)
  (:tree tvar tvalu :long vers :gimple defstmt)
  treessa
  :doc #{$TREE_SSA_NAME match an SSA name tree $TR extracting the $TVAR $TVALUE $VERS and $DEFSTMT}#
  ;; test expander
  #{ /*  tree_ssa_name $TREESSA ? */ (($tr) && TREE_CODE($tr) == SSA_NAME) }#
  ;; fill expander
  #{ /*  tree_ssa_name $TREESSA ! */
   $tvar = SSA_NAME_VAR($tr);
   $tvalu = SSA_NAME_VALUE($tr);
   $vers = SSA_NAME_VERSION($tr);
   $defstmt = SSA_NAME_DEF_STMT($tr);
  }# )

;;;; simpler matcher for pattern ssa_name
(defcmatcher tree_simple_ssa_name 
  (:tree tr)
  (:tree tvar :long vers)
  treesssa
  :doc #{$TREE_SIMPLE_SSA_NAME match an SSA name tree $TR extracting the $TVAR and $VERS}#
  ;; test expander
  #{ /* tree_simple_ssa_name  $TREESSSA ? */ (($TR) && TREE_CODE($TR) == SSA_NAME) }#
  ;; fill expander
  #{ /* tree_simple_ssa_name  $TREESSSA ! */
   $tvar = SSA_NAME_VAR($tr);
   $vers = SSA_NAME_VERSION($tr);
  }# )



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; we really should lazily generate the tree_call_expr....
;;;;;;;;
(defcmatcher tree_call0_expr 
  (:tree tr)
  (:tree trcalledfun trchain)
  tcal0
  :doc #{$TREE_CALL0_EXPR match tree of @code{CALL_EXPR} for call-arity 0 extracting their TRCALLEDFUN TRCHAIN}#
  ;; test
  #{ /* tree_call0_expr $TCAL0 ? */ (($TR) && TREE_CODE($TR) == CALL_EXPR && call_expr_nargs($TR)==0) }#
  ;; fill
  #{  /* tree_call0_expr $TCAL0 ! */
  $TRCALLEDFUN = CALL_EXPR_FN($TR);
  $TRCHAIN = CALL_EXPR_STATIC_CHAIN($TR);
  }#)

;;;;;;;;
(defcmatcher tree_call1_expr 
  (:tree tr)
  (:tree trcalledfun trchain trarg0)
  tcal1
  :doc #{$TREE_CALL1_EXPR match tree of @code{CALL_EXPR} for call-arity 1 extracting their TRCALLEDFUN TRCHAIN & TRARG0}#
  ;; test
  #{ /* tree_call1_expr $TCAL1 ? */ (($TR) && TREE_CODE($TR) == CALL_EXPR && call_expr_nargs($TR)==1) }#
  ;; fill
  #{  /* tree_call1_expr $TCAL1 ! */
  $TRCALLEDFUN = CALL_EXPR_FN($TR);
  $TRCHAIN = CALL_EXPR_STATIC_CHAIN($TR);
  $TRARG0 = CALL_EXPR_ARG ($TR, 0);
  }#)

;;;;;;;;;;;;;;;;
;; pseudoprimitive (TREE_CALL_EXPR fndecl args....)
;; expanded using build_call_expr GCC function
(defvar tree_call_primitive_cache_tuple)
(setq tree_call_primitive_cache_tuple (make_multiple discr_multiple 32))
(defun mexpand_tree_call_expr (sexpr env mexpander modctx)
  (debug "mexpand_tree_call_expr" "; sexpr=" sexpr "\n.. env=" env "\n.. modctx=" modctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(xargtup (expand_restlist_as_tuple cont env mexpander modctx))
	(nbargs (multiple_length xargtup))
	(nbcallargs (-i nbargs 1))
	)
    (debug "mexpand_tree_call_expr" "; loc=" loc "; cont=" cont
	   "\n.. xargtup=" xargtup)
    (when (<i nbargs 1)
      (error_at loc "pseudo-primitive (TREE_CALL_EXPR <funtree> <args>...) with too few $1 arguments" nbargs)
      (return))
    (let (
	  (cachelen (multiple_length tree_call_primitive_cache_tuple))
	  (cprim (if (<i nbcallargs cachelen)
		     (multiple_nth tree_call_primitive_cache_tuple nbcallargs)
		   ()))
	  )
      (unless cprim
	;; grow the cache if needed
	(if (>=i nbcallargs cachelen)
	    (let ( (newcachelen (+i 1 (ori 0xf (+i 5 (*i 3 (/iraw nbcallargs 2))))))
		   (newtup (make_multiple discr_multiple newcachelen))
		   )
	      (foreach_long_upto
	       (0 (-i cachelen 1))
	       (:long hix)
	       (multiple_put_nth newtup hix (multiple_nth tree_call_primitive_cache_tuple hix)))
	      (setq tree_call_primitive_cache_tuple newtup)))
	(let (
	      (primname (string4out discr_string "TREE_CALL_" nbcallargs))
	      (primsymb (create_symbolstr primname))
	      (tupformsymbs
	       (let ( (symlist (list 'tr_cfun))
		      )
		 (foreach_long_upto
		  (0 nbcallargs)
		  (:long fix)
		  (list_append symlist
			       (create_symbolstr  (string4out discr_string "TR_ARG_" fix))))
		 (list_to_multiple symlist discr_multiple)))
	      (primfortup (multiple_map
			   tupformsymbs
			   (lambda (tsymb)
			     (instance class_formal_binding
				       :binder tsymb :fbind_type ctype_tree))))
	      (primexptup
	       (let ( (pxl (make_list discr_list))
		      (tr_cfun 'tr_cfun)
		      )
		 (add2list pxl ##{/* tree_call_expr quasiprimitive $PRIMNAME */ build_call_expr }# "("
			   ##{$TR_CFUN, $NBCALLARGS}#)
		 (foreach_in_multiple
		  (tupformsymbs)
		  (curform :long fix)
		  (if fix (add2list pxl ##{, $CURFORM}#)))
		 (list_to_multiple pxl discr_multiple)
		 ))
	      (newprim (instance class_primitive
				 :named_name primsymb
				 :prim_formals primfortup
				 :prim_type ctype_tree
				 :prim_expansion primexptup))
	      )
	  (debug "mexpand_tree_call_expr" "; loc=" loc "; newprim= " newprim)
	  (setq cprim newprim)
	  ))
      (assert_msg "check cprim" (is_a cprim class_primitive))
      (let ( (res (instance class_source_primitive
			    :loca_location loc
			    :sprim_oper cprim
			    :sargop_args xargtup))
	     )
	(debug "mexpand_tree_call_expr" "; loc=" loc "; res=" res)
	(return res)
	)
      )
    )
  )

;;; function make_tree_call_expr
(defun make_tree_call_expr (fnv argv)
  :doc #{The function $MAKE_TREE_CALL_EXPR takes a boxed tree function
  declaration $FNV and a tuple or a list of boxes tree arguments $ARGV
  and build a boxed @code{CALL_EXPR} tree, or else nil. See alo $TREE_CALL_EXPR
  quasiprimitive.}#
  (let ( (t_fn (unbox :tree fnv))
	 )
    (if t_fn
	(let ( (args (make_list discr_list))
	       )
	  (cond
	   ( (is_list argv)
	     (each_component_in_list
	      argv
	      curargv
	      (let ( (t_arg (unbox :tree curargv))
		     )
		(if t_arg (list_append args curargv)))))
	   ( (is_multiple argv)
	     (foreach_in_multiple
	      (argv)
	      (curargv :long aix)
	      (let ( (t_arg (unbox :tree curargv))
		     )
		(if t_arg (list_append args curargv)))))
	   (:else
	    (return)))
	  (let ( (nbargs (list_length args))
		 (argtup (list_to_multiple  args discr_multiple))
		 (:tree t_curarg (null_tree))
		 (:tree t_res (null_tree))
		 )
	    (code_chunk maketreecall_chk #{ /* make_tree_call_expr $MAKETREECALL_CHK */
			auto_vec<tree> targsvec_$MAKETREECALL_CHK;
			targsvec_$MAKETREECALL_CHK.reserve($NBARGS);
			for (int ix_$MAKETREECALL_CHK=0;
				 ix_$MAKETREECALL_CHK<$NBARGS;
				 ix_$MAKETREECALL_CHK++)
			{
			   $T_CURARG = melt_tree_content(melt_multiple_nth($ARGTUP, ix_$MAKETREECALL_CHK));
			   targsvec_$MAKETREECALL_CHK.quick_push($T_CURARG);
			}
			$T_RES = build_call_expr_loc_array (UNKNOWN_LOCATION,
							    $T_FN,
							    $NBARGS,
							    &targsvec_$MAKETREECALL_CHK[0]);
			}#)
	    (return (constant_box t_res))
	    )
	  )
      )
    )
  (return)
  )
	      
;;;;;;;
(defvar tree_call_cmatcher_cache_tuple)
(setq tree_call_cmatcher_cache_tuple (make_multiple discr_multiple 32))
;;
(defun patexpand_tree_call_expr  (sexpr env pctx)
  (debug "patexpand_tree_call_expr" "; sexpr=" sexpr "\n.. env=" env "\n.. pctx=" pctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (assert_msg "check pctx" (is_a pctx class_pattern_expansion_context) pctx)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(nbargs (-i (list_length cont) 1))
	(nbcallargs (-i nbargs 2))
	)
    (debug "patexpand_tree_call_expr" "; loc=" loc "; cont=" cont)
    (when (<i nbargs 2)
      (error_at loc
		"(TREE_CALL_EXPR <calledfun> <chain> [<args>...]) needs at least two arguments but got only $1"
		nbargs)
      (return))
    (let (
	  (cachelen (multiple_length tree_call_cmatcher_cache_tuple))
	  (cmat (if (<i nbcallargs cachelen)
		    (multiple_nth tree_call_cmatcher_cache_tuple nbcallargs)
		  ()))
	  )
      (unless cmat
	;; grow the cache if needed
	(if (>=i nbcallargs cachelen)
	    (let ( (newcachelen (+i 1 (ori 0xf (+i 5 (*i 3 (/iraw nbcallargs 2))))))
		   (newtup (make_multiple discr_multiple newcachelen))
		   )
	      (foreach_long_upto
	       (0 (-i cachelen 1))
	       (:long hix)
	       (multiple_put_nth newtup hix (multiple_nth tree_call_cmatcher_cache_tuple hix)))
	      (setq tree_call_cmatcher_cache_tuple newtup)))
	(let (
	      (argsymblist (list 'tr_fun 'tr_chain))
	      )
	  (foreach_long_upto
	   (0 (-i nbcallargs 1))
	   (:long cix)
	   (let ( (curargname (string4out discr_string "TR_ARG_" cix))
		  (curargsymb (create_symbolstr curargname))
		  )
	     (debug "patexpand_tree_call_expr" "; curargsymb=" curargsymb)
	     (list_append argsymblist curargsymb)
	     )
	   )
	  (debug "patexpand_tree_call_expr" "; loc=" loc
		 " argssymblist=" argsymblist)
	  (let ( (tupargsymb (list_to_multiple argsymblist discr_multiple))
		 (cmatname (string4out discr_string "TREE_CALL_" nbcallargs))
		 (cmatsymb (create_symbolstr cmatname))
		 )
	    (debug "patexpand_tree_call_expr" "; loc=" loc
		   " tupargsymb=" tupargsymb
		   "\n.. cmatsymb=" cmatsymb)
	    (let (
		  (trbind (instance class_formal_binding
				    :binder 'tr
				    :fbind_type ctype_tree))
		  (tupargbind (multiple_map
			       tupargsymb
			       (lambda (tsymb)
				 (instance class_formal_binding
					   :binder tsymb
					   :fbind_type ctype_tree))))
		  (cmtest
		   (let
		       ( (cmt (make_list discr_list))
			 (treecallstate 'treecallstate)
			 (tr 'tr)
			 )
		     (add2list
		      cmt
		      ##{ /* $CMATNAME $TREECALLSTATE generated test for call_expr ? */
		        $TR && TREE_CODE($TR) == CALL_EXPR
		        && call_expr_nargs ($TR) == $NBCALLARGS
		      }#
		      )
		     (debug "patexpand_tree_call_expr" "; cmtest=" cmt)
		     cmt))
		  (cmfill
		   (let ( (cmf (make_list discr_list))
			  (treecallstate 'treecallstate)
			  (tr 'tr)
			  (tr_fun 'tr_fun)
			  (tr_chain 'tr_chain)
			  )
		     (add2list
		      cmf
                      ##{ /* $CMATNAME $TREECALLSTATE generated fill for call_expr ! */
                      $TR_FUN = CALL_EXPR_FN($TR) ;
                      $TR_CHAIN = CALL_EXPR_STATIC_CHAIN($TR) ;
                      }#)
		     (foreach_in_multiple
		      (tupargsymb)
		      (curargsymb :long aix)
		      (if (>=i aix 2)
			  (let ( (nix (-i aix 2))
				 )
			    (add2list cmf
				      ##{ $CURARGSYMB = CALL_EXPR_ARG ($TR, $NIX) ;
				      }#)))
		      )
		     (debug "patexpand_tree_call_expr" "; cmfill=" cmf)
		     cmf
		     ))
		  (newcmat
		   (instance class_cmatcher
			     :named_name cmatsymb
			     :amatch_matchbind trbind
			     :amatch_out tupargbind ;; tuple of formals
			     :cmatch_state 'treecallstate ;; symbol
			     :cmatch_exptest (list_to_multiple cmtest discr_multiple)
			     :cmatch_expfill (list_to_multiple cmfill discr_multiple)
			     ))
		  )
	      (debug "patexpand_tree_call_expr" "; loc=" loc "\n.. newcmat=" newcmat)
	      (multiple_put_nth  tree_call_cmatcher_cache_tuple nbcallargs newcmat)
	      (setq cmat newcmat)
	      (debug "patexpand_tree_call_expr" "; loc=" loc "; nbcallargs=" nbcallargs
		     "\n.. updated cachetuple=" tree_call_cmatcher_cache_tuple
		     "\n.. cmat=" cmat)
	      )
	    )
	  )
	)
      (debug "patexpand_tree_call_expr" "; loc=" loc "; cmat=" cmat)
      (assert_msg "check cmat" (is_a cmat class_cmatcher) cmat)
      (multicall
       (args pats)
       (patmacexpand_for_matcher curpair cmat env loc pctx)
       (debug "patexpand_tree_call_expr" "; loc=" loc " args=" args " pats=" pats)
       (multicall
	(subpatw :long imax imin isum)
	(pattern_weight_tuple pats)
	(debug "patexpand_tree_call_expr" "; loc=" loc " subpatw=" subpatw
	       "\n.. imax=" imax " imin=" imin " isum=" isum)
	(let (
	      (cmatsymb (get_field :named_name cmat))
	      ;;; notice that we are embedding the binding in the
	      ;;; result, but not putting the binding in the
	      ;;; environment. See comment about 'mv is not bound' in
	      ;;; file warmelt-normatch.melt function
	      ;;; normpat_anymatchpat...
	      (cmabind (instance class_cmatcher_binding
				 :binder cmatsymb
				 :cmbind_matcher cmat))
	      (res
	       (instance class_source_pattern_c_match
			 :loca_location loc
			 :pat_weight (constant_box (+i 1 isum))
			 :spac_operator cmat
			 :spac_operbind cmabind
			 :spac_inargs args
			 :spac_outargs pats)
	       )
	      )
	  (debug "patexpand_tree_call_expr" "; loc=" loc "\n.. cmabind=" cmabind
		 "\n.. res=" res)
	  (return res)
	  )
	)
       )
      )
    )
  )
;;
(export_patmacro tree_call_expr patexpand_tree_call_expr mexpand_tree_call_expr
		 :doc #{The $TREE_CALL_EXPR is for patterns or expressions
		 for treecode @code{CALL_EXPR}. Usage is @code{(TREE_CALL_EXPR
		 @var{<called-fun>} @var{<chaining>}
		 @var{<call-arguments> ...})}, where everything is a tree }#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;
(defvar tree_call_more_cmatcher_cache_tuple)
(setq tree_call_more_cmatcher_cache_tuple (make_multiple discr_multiple 32))
;;
(defun patexpand_tree_call_more_expr  (sexpr env pctx)
  (debug "patexpand_tree_call_more_expr" "; sexpr=" sexpr "\n.. env=" env "\n.. pctx=" pctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (assert_msg "check pctx" (is_a pctx class_pattern_expansion_context) pctx)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(argsp (patternexpand_pairlist_as_tuple curpair env pctx loc))
	(nbargs (multiple_length argsp))
	(nbcallargs (-i nbargs 2))
	)
    (debug "patexpand_tree_call_more_expr" "; loc=" loc "; cont=" cont
	   "\n.. argsp=" argsp)
    (when (<i nbargs 2)
      (error_at loc
		"(TREE_CALL_MORE_EXPR <calledfun> <chain> <callargs>...) needs at least two arguments but got only $1"
		nbargs)
      (return))
    (let (
	  (cachelen (multiple_length tree_call_more_cmatcher_cache_tuple))
	  (cmat (if (<i nbcallargs cachelen)
		    (multiple_nth tree_call_more_cmatcher_cache_tuple nbcallargs)
		  ()))
	  )
      (unless cmat
	;; grow the cache if needed
	(if (>=i nbcallargs cachelen)
	    (let ( (newcachelen (+i 1 (ori 0xf (+i 5 (*i 3 (/iraw nbcallargs 2))))))
		   (newtup (make_multiple discr_multiple newcachelen))
		   )
	      (foreach_long_upto
	       (0 (-i cachelen 1))
	       (:long hix)
	       (multiple_put_nth newtup hix (multiple_nth tree_call_more_cmatcher_cache_tuple hix)))
	      (setq tree_call_more_cmatcher_cache_tuple newtup)))
	(let (
	      (argsymblist (list 'tr_fun 'tr_chain))
	      )
	  (foreach_long_upto
	   (0 (-i nbcallargs 1))
	   (:long cix)
	   (let ( (curargname (string4out discr_string "TR_ARG_" cix))
		  (curargsymb (create_symbolstr curargname))
		  )
	     (debug "patexpand_tree_call_more_expr" "; curargsymb=" curargsymb)
	     (list_append argsymblist curargsymb)
	     )
	   )
	  (debug "patexpand_tree_call_more_expr" "; loc=" loc
		 " argssymblist=" argsymblist)
	  (let ( (tupargsymb (list_to_multiple argsymblist discr_multiple))
		 (cmatname (string4out discr_string "TREE_CALL_MORE_" nbcallargs))
		 (cmatsymb (create_symbolstr cmatname))
		 )
	    (debug "patexpand_tree_call_more_expr" "; loc=" loc
		   " tupargsymb=" tupargsymb
		   "\n.. cmatsymb=" cmatsymb)
	    (let (
		  (trbind (instance class_formal_binding
				    :binder 'tr
				    :fbind_type ctype_tree))
		  (tupargbind (multiple_map
			       tupargsymb
			       (lambda (tsymb)
				 (instance class_formal_binding
					   :binder tsymb
					   :fbind_type ctype_tree))))
		  (cmtest
		   (let
		       ( (cmt (make_list discr_list))
			 (treecallstate 'treecallstate)
			 (tr 'tr)
			 )
		     (add2list
		      cmt
		      ##{ /* $CMATNAME $TREECALLSTATE generated test for tree_call_more ? */
		      $TR && TREE_CODE($TR) == CALL_EXPR
		      && call_expr_nargs ($TR) >= $NBCALLARGS
		      }#
		      )
		     (debug "patexpand_tree_call_more_expr" "; cmtest=" cmt)
		     cmt))
		  (cmfill
		   (let ( (cmf (make_list discr_list))
			  (treecallstate 'treecallstate)
			  (tr 'tr)
			  (tr_fun 'tr_fun)
			  (tr_chain 'tr_chain)
			  )
		     (add2list
		      cmf
		      ##{ /* $CMATNAME $TREECALLSTATE generated fill for tree_call_more_expr ! */
		      $TR_FUN = CALL_EXPR_FN($TR)	      ;
		      $TR_CHAIN = CALL_EXPR_STATIC_CHAIN($TR) ;
		      }#)
		     (foreach_in_multiple
		      (tupargsymb)
		      (curargsymb :long aix)
		      (if (>=i aix 2)
			  (let ( (nix (-i aix 2))
				 )
			    (add2list cmf
				      ##{ $CURARGSYMB = CALL_EXPR_ARG ($TR, $NIX) ;
				      }#)))
		      )
		     (debug "patexpand_tree_call_more_expr" "; cmfill=" cmf)
		     cmf
		     ))
		  (newcmat
		   (instance class_cmatcher
			     :named_name cmatsymb
			     :amatch_matchbind trbind
			     :amatch_out tupargbind ;; tuple of formals
			     :cmatch_state 'treecallstate ;; symbol
			     :cmatch_exptest (list_to_multiple cmtest discr_multiple)
			     :cmatch_expfill (list_to_multiple cmfill discr_multiple)
			     ))
		  )
	      (debug "patexpand_tree_call_more_expr" "; loc=" loc "\n.. newcmat=" newcmat)
	      (multiple_put_nth  tree_call_more_cmatcher_cache_tuple nbcallargs newcmat)
	      (setq cmat newcmat)
	      (debug "patexpand_tree_call_more_expr" "; loc=" loc "; nbcallargs=" nbcallargs
		     "\n.. updated cachetuple=" tree_call_more_cmatcher_cache_tuple
		     "\n.. cmat=" cmat)
	      )
	    )
	  )
	)
      (debug "patexpand_tree_call_more_expr" "; loc=" loc "; cmat=" cmat)
      (assert_msg "check cmat" (is_a cmat class_cmatcher) cmat)
      (multicall
       (args pats)
       (patmacexpand_for_matcher curpair cmat env loc pctx)
       (debug "patexpand_tree_call_more_expr" "; loc=" loc " args=" args " pats=" pats)
       (multicall
	(subpatw :long imax imin isum)
	(pattern_weight_tuple pats)
	(debug "patexpand_tree_call_more_expr" "; loc=" loc " subpatw=" subpatw
	       "\n.. imax=" imax " imin=" imin " isum=" isum)
	(let (
	      (cmatsymb (get_field :named_name cmat))
	      ;;; notice that we are embedding the binding in the
	      ;;; result, but not putting the binding in the
	      ;;; environment. See comment about 'mv is not bound' in
	      ;;; file warmelt-normatch.melt function
	      ;;; normpat_anymatchpat...
	      (cmabind (instance class_cmatcher_binding
				 :binder cmatsymb
				 :cmbind_matcher cmat))
	      (res
	       (instance class_source_pattern_c_match
			 :loca_location loc
			 :pat_weight (constant_box (+i 1 isum))
			 :spac_operator cmat
			 :spac_operbind cmabind
			 :spac_inargs args
			 :spac_outargs pats)
	       )
	      )
	  (debug "patexpand_tree_call_more_expr" "; loc=" loc "\n.. cmabind=" cmabind
		 "\n.. res=" res)
	  (return res)
	  )
	)
       )
      
      )
    )
  )
;;
;;;;;;;;;;;;;;;;
(defun mexpand_tree_call_more_expr (sexpr env mexpander modctx)
  (debug "mexpand_tree_call_more_expr" "; sexpr=" sexpr "\n.. env=" env "\n.. modctx=" modctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	)
    (error_at loc "TREE_CALL_MORE_EXPR cannot be used as expression")
    (return)
    )
  )

(export_patmacro tree_call_more_expr patexpand_tree_call_more_expr mexpand_tree_call_more_expr
		 :doc #{The $TREE_CALL_MORE_EXPR is for patterns or
		 expressions for treecode @code{CALL_EXPR} with more
		 arguments than given. Usage is
		 @code{(TREE_CALL_MORE_EXPR @var{<called-fun>}
		 @var{<chaining>} @var{<call-arguments> ...})}, where
		 everything is a tree. So
		 @code{?(tree_call_more_expr ?tfun ?tchain ?ta0 ?ta1)}
		 will match call trees with two or more arguments. See also
		 $FOREACH_ARGUMENT_IN_CALL_EXPR_TREE, $ARITY_TREE_CALL_EXPR and $NTH_ARG_TREE_CALL_EXPR}#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; iterator on call arguments
(defciterator foreach_argument_in_call_expr_tree
  (:tree tr_call :long firstix)
  eachtrcall
  (:tree tr_arg :long argix)
  :doc #{Iterates within a @code{CALL_EXPR} tree $TR_CALL from index
  $FIRSTIX on each argument tree $TR_ARG at index $ARGIX. See also
  $ARITY_TREE_CALL_EXPR and $NTH_ARG_TREE_CALL_EXPR.}#
  ;; before
  #{ /* foreach_argument_in_call_expr_tree $EACHTRCALL start */
  $TR_ARG = NULL_TREE;
  if ($TR_CALL && TREE_CODE($TR_CALL) == CALL_EXPR) {
    int arity_$EACHTRCALL = call_expr_nargs ($TR_CALL);
    int startix_$EACHTRCALL = $FIRSTIX;
    if (startix_$EACHTRCALL < 0)
      startix_$EACHTRCALL += arity_$EACHTRCALL;
    for ($ARGIX = startix_$EACHTRCALL;
	 $ARGIX < arity_$EACHTRCALL;
	 $ARGIX++) {
      $TR_ARG = CALL_EXPR_ARG ($TR_CALL, $ARGIX);
  }#
  ;; after
  #{ /* foreach_argument_in_call_expr_tree $EACHTRCALL ending */
    $TR_ARG = NULL_TREE;
    } /* end for   $EACHTRCALL */
  } /* end if CALL_EXPR  $EACHTRCALL */
  /* foreach_argument_in_call_expr_tree $EACHTRCALL ended */
  }#)

;;;;
(defprimitive arity_tree_call_expr (:tree tr_call) :long
  :doc #{Gives the arity i.e. number of arguments of a
  @code{CALL_EXPR} tree or else -1. See also $NTH_ARG_TREE_CALL_EXPR
  and $ARITY_TREE_CALL_EXPR}#
  #{(($TR_CALL && TREE_CODE($TR_CALL) == CALL_EXPR)
     ? ((long)call_expr_nargs($TR_CALL)) : -1L)}#)

;;;;
(defprimitive nth_arg_tree_call_expr (:tree tr_call :long n) :tree
  :doc #{Gives in a @code{CALL_EXPR} tree $TR_CALL the $N-th call
  argument (when $N >= 0 and small enough) or else the null tree. See also $ARITY_TREE_CALL_EXPR.}#
  #{(($TR_CALL && $N >= 0 && TREE_CODE($TR_CALL) == CALL_EXPR && $N<call_expr_nargs($TR_CALL))
     ? CALL_EXPR_ARG($TR_CALL, $N) : NULL_TREE)}#)

;; Iterator on function argument 
(defciterator foreach_argument_in_function_tree
  (:tree tr_fun)
  eachtrfun
  (:tree trarg)
  :doc #{The $FOREACH_ARGUMENT_IN_FUNCTION_TREE iterator iterates,
  using @code{FOREACH_FUNCTION_ARGS} on the argument of the tree
  $TR_FUN of @code{FUNCTION_TYPE}, binding $TRARG.}#
  ;; before
  #{
      /* foreach_argument_in_function_tree $EACHTRFUN start */
      tree $EACHTRFUN#_tr = NULL;

      $TRARG = (tree) NULL;
      if ($TR_FUN && TREE_CODE($TR_FUN) == FUNCTION_TYPE)
      {
          function_args_iterator $EACHTRFUN#_args_iter;
          FOREACH_FUNCTION_ARGS($TR_FUN, $EACHTRFUN#_tr, $EACHTRFUN#_args_iter)
          {
              $TRARG = $EACHTRFUN#_tr;
   }#
   ;;
   ;; after
   #{ /* ending  foreach_argument_in_function_tree $EACHTRFUN */
              $TRARG = (tree) NULL;
          } 
      }
      /* end foreach_argument_in_function_tree $EACHTRFUN */
   }#)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ********* BINARY TREE OPERATORS *********
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; we have so many tcc_binary tree codes in tree.def that it is worth
;; expanding them thru a macro.
(defmacro define_gcc_binary_tree (sexp env mexpander modctx)
  :doc #{The macro $DEFINE_GCC_BINARY_TREE takes one or many treecode names and
  expands to exported cmatchers.}#
  (debug "define_gcc_binary_tree sexp=" sexp)
  (let (
	(sloc (get_field :loca_location sexp))
	(sexcont (get_field :sexp_contents sexp))
	(xargs (expand_restlist_as_tuple sexcont env mexpander modctx))
	(reslist (make_list discr_list))
	)
    (debug "define_gcc_binary_tree xargs=" xargs)
    (foreach_in_multiple
     (xargs)
     (curarg :long ix)
     (debug "define_gcc_binary_tree ix#" ix "; curarg=" curarg)
     (unless (is_a curarg class_symbol)
       (error_at sloc "DEFINE_GCC_BINARY_TREE bad argument #$1 : $2" ix curarg)
       (return))
     (let (
	   (curname (get_field :named_name curarg))
	   (treename (create_symbolstr (string4out discr_string "TREE_" curname)))
	   (xcmatcher
	    `(defcmatcher ,treename (:tree tr) (:tree tleft tright) treebin
	       :doc #{$(comma treename) match a binary operation @code{$(comma curname)} extracting its $TLEFT and $TRIGHT}#
	       #{ /* $(comma treename) $TREEBIN ? */  (($tr) && TREE_CODE($tr) == $(comma curname)) }#
	       #{  /* $(comma treename) $TREEBIN ! */
	       $TLEFT =  TREE_OPERAND ($TR, 0) ;
	       $TRIGHT = TREE_OPERAND ($TR, 1) ;
	       }#
	       ))
	   (xexport `(export_values ,treename))
	   )
       (debug "define_gcc_binary_tree treename=" treename " xcmatcher=" xcmatcher
	      "\n.. xexport=" xexport)
       (let ( (resultx (tuple (mexpander xcmatcher env mexpander modctx)
			      (mexpander xexport env mexpander modctx))
		       )
	      )
	 (debug "define_gcc_binary_tree resultx=" resultx)
	 (return resultx)
	 )
       ))
    ))
(export_macro define_gcc_binary_tree)

;; the following sed command on tree.def produces a useful MELT file
;; sed -n 's/DEFTREECODE *(\([A-Z_]*\),.*tcc_binary.*/(define_gcc_binary_tree \1)/p' tree.def


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; constant c-matchers for predefined tree nodes

;;; "char"
(defcmatcher tree_char_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_CHAR_TYPE_NODE matches or gives the constant char integer 
type node.}#
 #{ /* tree_char_type_node $NODETR ? */ $TR == char_type_node }#
 ()
 #{ /* tree_char_type_node : */ char_type_node }#)

;;; "signed char"
(defcmatcher tree_signed_char_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SIGNED_CHAR_TYPE_NODE matches or gives the constant signed 
char integer type node.}#
 #{ /* tree_signed_char_type_node $NODETR ? */ $TR == signed_char_type_node }#
 ()
 #{ /* tree_signed_char_type_node : */ signed_char_type_node }#)

;;; "unsigned char"
(defcmatcher tree_unsigned_char_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_UNSIGNED_CHAR_TYPE_NODE matches or gives the constant unsigned 
char integer type node.}#
 #{ /* tree_unsigned_char_type_node $NODETR ? */ $TR == unsigned_char_type_node }#
 ()
 #{ /* tree_unsigned_char_type_node : */ unsigned_char_type_node }#)

;;; "short"
(defcmatcher tree_short_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SHORT_INTEGER_TYPE_NODE matches or gives the constant short integer 
type node.}#
 #{ /* tree_short_integer_type_node $NODETR ? */ $TR == short_integer_type_node }#
 ()
 #{ /* tree_short_integer_type_node : */ short_integer_type_node }#)

;;; "unsigned short"
(defcmatcher tree_short_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SHORT_UNSIGNED_TYPE_NODE matches or gives the constant short integer 
type node.}#
 #{ /* tree_short_unsigned_type_node $NODETR ? */ $TR == short_unsigned_type_node }#
 ()
 #{ /* tree_short_unsigned_type_node : */ short_unsigned_type_node }#)

;;; "bool"
(defcmatcher tree_boolean_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_BOOLEAN_TYPE_NODE matches or gives the constant bool integer 
type node.}#
 #{ /* tree_boolean_type_node $NODETR ? */ $TR == boolean_type_node }#
 ()
 #{ /* tree_boolean_type_node : */ boolean_type_node }#)

;;; "int"
(defcmatcher tree_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INTEGER_TYPE_NODE matches or gives the constant  integer 
type node.}#
 #{ /* tree_integer_type_node $NODETR ? */ $TR == integer_type_node }#
 ()
 #{ /* tree_integer_type_node : */ integer_type_node }#)

;;; "unsigned"
(defcmatcher tree_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_UNSIGNED_TYPE_NODE matches or gives the constant unsigned integer 
type node.}#
 #{ /* tree_unsigned_type_node $NODETR ? */ $TR == unsigned_type_node }#
 ()
 #{ /* tree_unsigned_type_node : */ unsigned_type_node }#)

;;; "long"
(defcmatcher tree_long_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_INTEGER_TYPE_NODE matches or gives the constant long integer 
type node.}#
 #{ /* tree_long_integer_type_node $NODETR ? */ $TR == long_integer_type_node }#
 ()
 #{ /* tree_long_integer_type_node : */ long_integer_type_node }#)

;;; "size_t"
(defcmatcher tree_size_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SIZE_TYPE_NODE matches or gives the constant size_t integer 
type node.}#
 #{ /* tree_size_type_node $NODETR ? */ $TR == size_type_node }#
 ()
 #{ /* tree_size_type_node : */ size_type_node }#)

;;; "ssize_t"
(defcmatcher tree_signed_size_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SIGNED_SIZE_TYPE_NODE matches or gives the constant ssize_t integer 
type node.}#
 #{ /* tree_signed_size_type_node $NODETR ? */ $TR == signed_size_type_node }#
 ()
 #{ /* tree_signed_size_type_node : */ signed_size_type_node }#)

;;; "unsigned long"
(defcmatcher tree_long_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_UNSIGNED_TYPE_NODE matches or gives the constant unsigned long integer 
type node.}#
 #{ /* tree_long_unsigned_type_node $NODETR ? */ $TR == long_unsigned_type_node }#
 ()
 #{ /* tree_long_unsigned_type_node : */ long_unsigned_type_node }#)

;;; "uint16_t"
(defcmatcher tree_uint16_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_UINT16_TYPE_NODE matches or gives the constant uint16_t integer 
type node.}#
 #{ /* tree_uint16_type_node $NODETR ? */ $TR == uint16_type_node }#
 ()
 #{ /* tree_uint16_type_node : */ uint16_type_node }#)

;;; "uint32_t"
(defcmatcher tree_uint32_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_UINT16_TYPE_NODE matches or gives the constant uint32_t integer 
type node.}#
 #{ /* tree_uint32_type_node $NODETR ? */ $TR == uint32_type_node }#
 ()
 #{ /* tree_uint32_type_node : */ uint32_type_node }#)

;;; "uint64_t"
(defcmatcher tree_uint64_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_UINT16_TYPE_NODE matches or gives the constant uint64_t integer 
type node.}#
 #{ /* tree_uint64_type_node $NODETR ? */ $TR == uint64_type_node }#
 ()
 #{ /* tree_uint64_type_node : */ uint64_type_node }#)

;;; "long long"
(defcmatcher tree_long_long_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_LONG_INTEGER_TYPE_NODE matches or gives the constant long long integer 
type node.}#
 #{ /* tree_long_long_integer_type_node $NODETR ? */ $TR == long_long_integer_type_node }#
 ()
 #{ /* tree_long_long_integer_type_node : */ long_long_integer_type_node }#)

;;; "unsigned long long"
(defcmatcher tree_long_long_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_LONG_UNSIGNED_TYPE_NODE matches or gives the constant unsigned long long integer 
type node.}#
 #{ /* tree_long_long_unsigned_type_node $NODETR ? */ $TR == long_long_unsigned_type_node }#
 ()
 #{ /* tree_long_long_unsigned_type_node : */ long_long_unsigned_type_node }#)


   

;;; "float"
(defcmatcher tree_float_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_FLOAT_TYPE_NODE matches or gives the constant float
type node.}#
 #{ /* tree_float_type_node $NODETR ? */ $TR == float_type_node }#
 ()
 #{ /* tree_float_type_node : */ float_type_node }#)

;;; "double"
(defcmatcher tree_double_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_DOUBLE_TYPE_NODE matches or gives the constant double
type node.}#
 #{ /* tree_double_type_node $NODETR ? */ $TR == double_type_node }#
 ()
 #{ /* tree_double_type_node : */ double_type_node }#)

;;; "long double"
(defcmatcher tree_long_double_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_DOUBLE_TYPE_NODE matches or gives the constant long double
type node.}#
 #{ /* tree_long_double_type_node $NODETR ? */ $TR == long_double_type_node }#
 ()
 #{ /* tree_long_double_type_node : */ long_double_type_node }#)

;;; "void"
(defcmatcher tree_void_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_VOID_TYPE_NODE matches or gives the constant void
type node.}#
 #{ /* tree_void_type_node $NODETR ? */ $TR == void_type_node }#
 ()
 #{ /* tree_void_type_node : */ void_type_node }#)

;;; "void*"
(defcmatcher tree_ptr_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_PTR_TYPE_NODE matches or gives the constant void*
pointer type node.}#
 #{ /* tree_ptr_type_node $NODETR ? */ $TR == ptr_type_node }#
 ()
 #{ /* tree_ptr_type_node : */ ptr_type_node }#)

;;; "const void*"
(defcmatcher tree_const_ptr_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_CONST_PTR_TYPE_NODE matches or gives the constant const void*
pointer type node.}#
 #{ /* tree_const_ptr_type_node $NODETR ? */ $TR == const_ptr_type_node }#
 ()
 #{ /* tree_const_ptr_type_node : */ const_ptr_type_node }#)

;;; "va_list"
(defcmatcher tree_va_list_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_VA_LIST_TYPE_NODE matches or gives the constant va_list node.}#
 #{ /* tree_va_list_type_node $NODETR ? */ $TR == va_list_type_node }#
 ()
 #{ /* tree_va_list_type_node : */ va_list_type_node }#)

;;; "true"
(defcmatcher tree_boolean_true_node (:tree tr) ()
 nodetr
 :doc #{$TREE_BOOLEAN_TRUE_NODE matches or gives the constant true node.}#
 #{ /* tree_boolean_true_node $NODETR ? */ $TR == boolean_true_node }#
 ()
 #{ /* tree_boolean_true_node : */ boolean_true_node }#)

;;; "false"
(defcmatcher tree_boolean_false_node (:tree tr) ()
 nodetr
 :doc #{$TREE_BOOLEAN_FALSE_NODE matches or gives the constant false node.}#
 #{ /* tree_boolean_false_node $NODETR ? */ $TR == boolean_false_node }#
 ()
 #{ /* tree_boolean_false_node : */ boolean_false_node }#)


;;; "0"
(defcmatcher tree_integer_zero_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INTEGER_ZERO_NODE matches or gives the constant integer 0 node.}#
 #{ /* tree_integer_zero_node $NODETR ? */ $TR == integer_zero_node }#
 ()
 #{ /* tree_integer_zero_node : */ integer_zero_node }#)

;;; "NULL"
(defcmatcher tree_null_pointer_node (:tree tr) ()
 nodetr
 :doc #{$TREE_NULL_POINTER_NODE matches or gives the constant NULL pointer node.}#
 #{ /* tree_null_pointer_node $NODETR ? */ $TR == null_pointer_node }#
 ()
 #{ /* tree_null_pointer_node : */ null_pointer_node }#)


;;; "1"
(defcmatcher tree_integer_one_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INTEGER_ONE_NODE matches or gives the constant integer 1 node.}#
 #{ /* tree_integer_one_node $NODETR ? */ $TR == integer_one_node }#
 ()
 #{ /* tree_integer_one_node : */ integer_one_node }#)

;;; "-1"
(defcmatcher tree_integer_minus_one_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INTEGER_MINUS_ONE_NODE matches or gives the constant integer -1 node.}#
 #{ /* tree_integer_minus_one_node $NODETR ? */ $TR == integer_minus_one_node }#
 ()
 #{ /* tree_integer_minus_one_node : */ integer_minus_one_node }#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;; map keyed by raw trees
(defprimitive is_maptree (map) :long
  :doc #{Test if $MAP is a map of trees.}#
  #{ (melt_magic_discr((melt_ptr_t)($map)) == MELTOBMAG_MAPTREES) }#)
(defprimitive maptree_size (map) :long
  :doc #{Safely retrieve allocated size of map of trees $MAP.}#
 #{ (melt_size_maptrees((struct meltmaptrees_st*)($map))) }#)
;; primitive to get the attribute count of a maptree
(defprimitive maptree_count (map) :long
  :doc #{Safely retrieve used count of map of trees $MAP.}#
  #{ (melt_count_maptrees((struct meltmaptrees_st*)($map))) }# )
;; get an entry in a maptree from a C tree
(defprimitive maptree_get (map :tree tr) :value
  :doc #{Safely get in map of trees $MAP value associated to tree $TR.}#
  #{(melt_get_maptrees((melt_ptr_t) ($MAP), ($TR)))}#)
;; primitive for making a new map of trees
(defprimitive make_maptree (discr :long len) :value
  :doc #{Make a map of trees with discriminant $DISCR and initial size $LEN.}#
 #{(meltgc_new_maptrees((meltobject_ptr_t) ($DISCR), ($LEN)))}#)
;; primitive for putting into a map of trees
(defprimitive maptree_put (map :tree trkey :value val) :void
  :doc #{Safely put in map of trees $MAP associated to tree $TRKEY the non-nil value $VAL.}#
  #{melt_put_maptrees((melt_ptr_t) ($MAP),  ($TRKEY), 
		      (melt_ptr_t) ($VAL))}#)
;; primitive for removing from a map of trees
(defprimitive maptree_remove (map :tree trkey) :void
  :doc #{Safely remove in map of trees $MAP entry for tree $TRKEY.}#
  #{melt_remove_maptrees((melt_ptr_t) ($MAP), ($TRKEY))}#)
;; primitive to retrieve the auxiliary data of a map of trees
(defprimitive maptree_aux (map) :value
  :doc #{Safely retrieve in map of trees $MAP the auxiliary data.}#
  #{melt_auxdata_maptrees ((melt_ptr_t)$MAP)}#)
;; primitive to put the auxiliary data of a map of trees
(defprimitive maptree_auxput (map aux) :void
  :doc #{Safely put in map of trees $MAP the auxiliary data to $AUX.}#
  #{melt_auxput_maptrees ((melt_ptr_t)$MAP, (melt_ptr_t)$AUX)}#)

;; primitive to get the nth tree of a maptree
(defprimitive maptree_nth_attr (map :long n) :tree
  #{(melt_nthattr_maptrees((struct meltmaptrees_st*)($map), (int)($n)))}#)
;; primitive to get the nth value of a mapobject
(defprimitive maptree_nth_val (map :long n) :value
  #{(melt_nthval_maptrees((struct meltmaptrees_st*)($map), (int)($n)))}# )
;; iterator inside maptree
(defciterator foreach_maptree 
  (trmap)				; startformals
  eachmaptr 				;state symbol
  (:tree tratt :value trval)	;local formals
  :doc #{$FOREACH_MAPTREE iterates on entries of a maptree value
  $TRMAP, binding the tree attribute to $TRATT and its value to
  $TRVAL.}#
  ;; before expansion
  #{
   /*$EACHMAPTR*/ int $EACHMAPTR#_rk=0;
   for ($EACHMAPTR#_rk=0;
        $EACHMAPTR#_rk < (int) melt_size_maptrees((struct meltmaptrees_st*)($TRMAP));
	$EACHMAPTR#_rk++) {
   tree $EACHMAPTR#_tr = ((struct meltmaptrees_st*)($TRMAP))->entab[$EACHMAPTR#_rk].e_at;
   $TRATT = (tree) NULL;
   $TRVAL = (melt_ptr_t) NULL;
   if (!$EACHMAPTR#_tr 
       || (void*) $EACHMAPTR#_tr == (void*) HTAB_DELETED_ENTRY) 
     continue;
   $TRATT = $EACHMAPTR#_tr;
   $TRVAL = ((struct meltmaptrees_st*)($TRMAP))->entab[$EACHMAPTR#_rk].e_va;
   }#
  ;;after expansion
   #{
   } /*end $EACHMAPTR*/
   $TRATT = (tree) NULL;
   $TRVAL = (melt_ptr_t) NULL;
   }#
  )



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TREE DEBUG OUTPUT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; boxed tree debug
(defun dbgout_boxtree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/{")
    (output_tree_briefly out (tree_content self))
    (add2out_strconst out "}/")
    (add2out_indentnl out depth)
    )
  )
(install_method discr_tree dbg_output dbgout_boxtree_method)


;;;; treemap debug
(defun dbgout_maptree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (assert_msg "check self" (is_maptree self))
  (let ( (dis (discrim self)) 
	 (:long mapcount (maptree_count self))
	 (aux (maptree_aux self))
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " !treemap.")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/")
    (add2out_longdec out mapcount)
    (add2out_strconst out "!{ ")
    (if (and (<=i depth 1)
	     aux)
	(progn
	  (add2out out " aux:")
	  (dbg_out aux dbgi (+i depth 3))
	  ))
    (foreach_maptree
     (self)
     (:tree tratt :value trval)
     (add2out_indentnl out (+i depth 1))
     (add2out_strconst out "*")
     (output_tree_briefly out tratt)
     (add2out_strconst out " == ")
     (dbg_out trval dbgi (+i depth 2))
     )
    (add2out_strconst out " }!")
    (add2out_indentnl out depth)
    ))
(install_method discr_map_trees dbg_output dbgout_maptree_method)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;           P R A G M A S
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(cheader
 #{ /* cheader for pragmas in libmelt-ana-tree.melt */
 #include "cpplib.h"
 #include "c-family/c-pragma.h"
/*** 
     We declare weak functions because they cannot be linked when we
     use lto (it loses langage specific informations).  If you use one
     of those functions you must check them to be not NULL.
***/
#if GCCPLUGIN_VERSION <= 5009 /* GCC 5.x */
// Function pragma_lex is declared in c-family/c-pragma.h
extern enum cpp_ttype pragma_lex (tree *) MELT_WEAK_ON_HOST;
#else /* GCC 6 */
// Function pragma_lex has an additional argument
extern enum cpp_ttype pragma_lex (tree *, location_t *loc)
   MELT_WEAK_ON_HOST;
#endif /* GCC 6 */


// Function c_register_pragma_with_expansion_and_data from c-family/c-pragma.h
extern void
c_register_pragma_with_expansion_and_data (const char *space,
					   const char *name,
					   pragma_handler_2arg handler,
					   void *data) MELT_WEAK_ON_HOST;
// Function c_register_pragma_with_data from c-family/c-pragma.h
extern void
c_register_pragma_with_data (const char *space, const char *name,
			     pragma_handler_2arg handler,
			     void *data) MELT_WEAK_ON_HOST;

 static void
 melt_register_pragmas_callback (void* gccdata ATTRIBUTE_UNUSED,
			        void* userdata ATTRIBUTE_UNUSED)
 {
   static long countregpragma;
   countregpragma++;
   debugeprintf ("melt_register_pragmas_callback calling MELT hook_register_pragmas #%ld", 
		 countregpragma++);
   gcc_assert (countregpragma > 0);
   melthookproc_HOOK_REGISTER_PRAGMAS ();
   } /* end of melt_register_pragmas_callback */

static void
melt_pragma_process_callback (struct cpp_reader* ATTRIBUTE_UNUSED, void* data)
{
   long ix = (long) data;
   debugeprintf ("melt_pragma_process_callback ix=%ld calling MELT hook_process_pragma", ix);
   melthookproc_HOOK_PROCESS_PRAGMA(ix);
}

 }#)


(defprimitive inside_c_frontend () :long
  :doc #{utility boolean primitive testing if we are indeed within a C or
  C++ compiler, outside of @code{lto1} but inside @code{cc1} or
  @code{cc1plus}.  }#
     #{ /* start inside_c_frontend */
#ifdef MELT_WEAK_ON_HOST
        (pragma_lex != NULL
           && c_register_pragma_with_expansion_and_data != NULL
           && c_register_pragma_with_data != NULL)
#else
#error inside_c_frontend need MELT_WEAK_ON_HOST
#endif
     /* end inside_c_frontend  */
     }#)

(defun check_c_frontend (nam :cstring msg)
  :doc #{utility function to check that we are indeed within a C or
  C++ compiler, outside of @code{lto1} but inside @code{cc1} or
  @code{cc1plus}.}#
  (assert_msg "check nam" (is_a nam class_named))
  (let ( (:long good 0)
	 )
    (code_chunk
     checkc_havepragmas_chk
     #{ /* start check_c_frontend $CHECKC_HAVEPRAGMAS_CHK */
#ifdef MELT_WEAK_ON_HOST
     $GOOD = pragma_lex
           && c_register_pragma_with_expansion_and_data
           && c_register_pragma_with_data;
#else
#error check_c_frontend need MELT_WEAK_ON_HOST
#endif
     /* end check_c_frontend $CHECKC_HAVEPRAGMAS_CHK */
     }#)
    (debug "check_c_frontend good=" good " nam=" nam " msg=" msg)
    (unless good
      (error_at () "Can't use $1 ($2) outside of a C [cc1] or C++ [cc1plus] compiler -e.g. inside [lto1]"
		nam msg)
      (let ( (namstr (get_field :named_name nam))
	     )
	(assert_msg "check namstr" (is_string namstr) namstr nam)
	(code_chunk
	 checkc_fatalerror_chk
	 #{ /* check_c_frontend $CHECKC_FATALERROR_CHK */
	 melt_fatal_error("C or C++ frontend expected in %s (%s)",
			  melt_string_str($NAMSTR),
			  $MSG);
	 }#)))
    (return :true)
    ))


;; a variable to hold lazily the tuple of symbols for our pragma_lexer
(defvar cpp_ttype_tuple)

(defhook register_cpp_ttype (:long ix :cstring name) () :void
  (assert_msg "check cpp_ttype_tuple" (is_multiple cpp_ttype_tuple) cpp_ttype_tuple)
  (multiple_put_nth cpp_ttype_tuple ix
		    (hook_named_symbol
		     name
		     (expr_chunk chk_meltcreate :long
				 #{/*register_cpp_ttype*/ (long)MELT_CREATE}#)))
  )

(defun ensure_cpp_ttype_tuple ()
  (if cpp_ttype_tuple (return))
  (let ( (:long nbttype (expr_chunk chk_nbttype :long
				    #{/*ensure_cpp_ttype_tuple*/ (long) N_TTYPES}#))
	 (newcpptytuple (make_multiple discr_multiple nbttype))
	 )
    (setq cpp_ttype_tuple newcpptytuple)
    (code_chunk
     cpptypetuple_chk
     #{ /* ensure_cpp_ttype_tuple $CPPTYPETUPLE_CHK */
#define MELT_DO_REGISTER_CPP_TTYPE(CppNam) \
   melthook_REGISTER_CPP_TTYPE($REGISTER_CPP_TTYPE, \
			       CppNam, #CppNam);
// macros used by TTYPE_TABLE from cpplib.h
#ifndef TTYPE_TABLE
#error TTYPE_TABLE not defined but expected
#endif
#define OP(Nam,Str) /*oper*/  MELT_DO_REGISTER_CPP_TTYPE(CPP_##Nam)
#define TK(Nam,Typ) /*token*/ MELT_DO_REGISTER_CPP_TTYPE(CPP_##Nam)
// the TTYPE_TABLE below is a long macro
     TTYPE_TABLE
#undef MELT_DO_REGISTER_CPP_TTYPE
     }#)
    )
  )

(defun pragma_lex ()
  :doc #{Thin wrapper around @code{pragma_lex} from
  @code{c-family/c-pragma.h}, to be called from pragma handling to get
  some lexemes @b{inside pragmas}. Returns the type, as a symbol, and
  secondarily the tree. See also $REGISTER_PLAIN_PRAGMA and
  $REGISTER_EXPANDED_PRAGMA, since you should call this $PRAGMA_LEX
  only within your functions registered that way.}#
  (let ( (:long trtyperank -1)
	 (:tree tr (null_tree))
	 )
    (code_chunk
     pragmalex_chk
     #{ /* pragma_lex $PRAGMALEX_CHK */
     if (!pragma_lex)
       melt_fatal_error ("pragma_lex @%p called outside of C [cc1] or C++ compiler [cc1plus] e.g. from [lto1]",
			 (void*) pragma_lex);
#if GCCPLUGIN_VERSION <= 5009 /* GCC 5.x */
        $TRTYPERANK = (long) pragma_lex (& ($TR));
#else /* GCC 6*/
	$TRTYPERANK = (long) pragma_lex (& ($TR), NULL);
#endif /* GCC 6*/
     }#)
    (if trtyperank
	(let ( (trtype (multiple_nth cpp_ttype_tuple trtyperank))
	       )
	  (debug "pragma_lex trtype=" trtype " tr=" tr)
	  (return trtype tr)
	  )
      (return () tr)
      )
  ))


(defclass class_gcc_expanded_pragma
  :doc #{The $CLASS_GCC_EXPANDED_PRAGMA is for registered pragma
  handlers with expansion, see
  @code{c_register_pragma_with_expansion_and_data} in
  @file{c-family/c-pragma.h} and also $CLASS_GCC_PLAIN_PRAGMA.}#
  :super class_gcc_pragma
  :fields ())


(defclass class_gcc_plain_pragma
  :doc #{The $CLASS_GCC_PLAIN_PRAGMA is for registered pragma handlers
  without expansion, see @code{c_register_pragma_with_data} in
  @file{c-family/c-pragma.h} and also $CLASS_GCC_EXPANDED_PRAGMA.}#
  :super class_gcc_pragma
  :fields ())


(defun register_expanded_pragma (space name fun data)
  :doc #{Register an expanded pragma using
  @code{c_register_pragma_with_expansion_and_data} in given
  $SPACE (default is :melt) with a given $NAME and closure $FUN and
  $DATA. Return a newly added instance of
  $CLASS_GCC_EXPANDED_PRAGMA. See also $REGISTER_PLAIN_PRAGMA and use
  $PRAGMA_LEX to get lexemes inside the pragma from $FUN. Use with parcimony, 
  some versions of GCC accept only two dozens of plugin pragmas.}#
  ;; the two dozens is related to the gcc_assert (id < 64) of
  ;; function c_register_pragma_1 in gcc/c-family/c-pragma.c of GCC4.9
  (debug "register_expanded_pragma start space=" space " name=" name " fun=" fun " data=" data)
  (check_c_frontend 'register_expanded_pragma "start")
  (ensure_cpp_ttype_tuple)
  (unless (is_a space class_symbol)
    (setq space :melt))
  (when (is_not_a space class_named)
    (error_at () "register_expanded_pragma bad space for name $1"
	      name)
    (return))
  (let ( (namestr
	  (cond 
	   ((is_string name) name)
	   ((is_a name class_named) (get_field :named_name name))
	   (:else
	    (error_at () "register_expanded_pragma invalid name $1 for space $2" name space)
	    (return))))
	 )
    (unless (is_closure fun)
      (error_at () "register_expanded_pragma fail in space $1 name $2 - non closure fun"
		space name)
      (return))
    (let ( (ph (instance class_gcc_expanded_pragma
			 :named_name namestr
			 :gccpragma_handler fun
			 :gccpragma_space space
			 :gccpragma_data data))
	   )
      (debug "register_expanded_pragma ph=" ph "; name=" name)
      (add_pragma_handler ph)
      (debug "register_expanded_pragma added ph=" ph "; name=" name)
      )
    )
  )

(defun register_plain_pragma (space name fun data)
  :doc #{Register a plain (unexpanded) pragma using
  @code{c_register_pragma_with_expansion_and_data} in given
  $SPACE (default is :melt) with a given $NAME and closure $FUN and
  $DATA. Return a newly added instance of $CLASS_GCC_PLAIN_PRAGMA. See
  also $REGISTER_EXPANDED_PRAGMA and use $PRAGMA_LEX to get lexemes
  inside the pragma from $FUN. Use with parcimony, 
  some versions of GCC accept only two dozens of plugin pragmas.}#
  ;; the two dozens is related to the gcc_assert (id < 64) of
  ;; function c_register_pragma_1 in gcc/c-family/c-pragma.c
  (debug "register_plain_pragma start space=" space " name=" name " fun=" fun " data=" data)
  (check_c_frontend 'register_plain_pragma "start")
  (ensure_cpp_ttype_tuple)
  (unless (is_a space class_symbol)
    (setq space 'meltpragma))
  (when (is_not_a space class_named)
    (error_at () "register_plain_pragma bad space for name $1"
	      name)
    (return))
  (let ( (namestr
	  (cond 
	   ((is_string name) name)
	   ((is_a name class_named) (get_field :named_name name))
	   (:else
	    (error_at () "register_plain_pragma invalid name $1 for space $2" name space)
	    (return))))
	 )
    (unless (is_closure fun)
      (error_at () "register_plain_pragma fail in space $1 name $2 - non closure fun"
		space name)
      (return))
    (let ( (ph (instance class_gcc_plain_pragma
			 :named_name namestr
			 :gccpragma_handler fun
			 :gccpragma_space space
			 :gccpragma_data data))
	   )
      (add_pragma_handler ph)
      )
    )
  )

(defun real_pragma_processor (pragmatup)
  (debug "real_pragma_processor start pragmatup=" pragmatup)
  (shortbacktrace_dbg "real_pragma_processor" 15)
  (assert_msg "real_pragma_processor check pragmatup" (is_multiple_or_null pragmatup) pragmatup)
  (foreach_in_multiple
   (pragmatup)
   (curpragma :long ix)
   (debug "real_pragma_processor curpragma=" curpragma "\n.. ix=" ix "\n")
   (cond
    ( (null curpragma)
      (void))
    ( (is_a curpragma class_gcc_plain_pragma)
      (debug "real_pragma_processor plain curpragma=" curpragma)
      (let ( (:long lix (get_int curpragma) )
	     (namestr (get_field :named_name curpragma))
	     (space (get_field :gccpragma_space curpragma))
	     (spacestr (if space (get_field :named_name space)))
	     )
	(debug "real_pragma_processor plainpragma lix=" lix 
	       "; spacestr=" spacestr " namestr=" namestr)
	(assert_msg "check lix" (==i lix ix) lix ix curpragma)
	(assert_msg "check spacestr" (or (null spacestr)
					 (>i (string_length spacestr) 0))
		    space curpragma)
	(assert_msg "check namestr" (>i (string_length namestr) 0) namestr curpragma)
	(code_chunk plainpragma_chk
	 #{ /* real_pragma_processor $PLAINPRAGMA_CHK */
	 debugeprintf ("real_pragma_processor $PLAINPRAGMA_CHK lix=%ld", $LIX);
	 // we internize the space and name strings
	 const char*internedspace = 
            ($SPACESTR)?(melt_intern_cstring (melt_string_str ($SPACESTR))):NULL;
	 const char*internedname = 
            melt_intern_cstring (melt_string_str ($NAMESTR));
	 debugeprintf ("real_pragma_processor $PLAINPRAGMA_CHK internedspace=%s internedname=%s", 
		       internedspace, internedname);
	 c_register_pragma_with_data
	    (internedspace, internedname, melt_pragma_process_callback,
	     (void*) $LIX);
	 debugeprintf ("real_pragma_processor $PLAINPRAGMA_CHK registered pragma space %s name %s lix#%ld",
		      internedspace, internedname, $LIX);
	 }#)
	)
      )
    ( (is_a curpragma class_gcc_expanded_pragma)
      (debug "real_pragma_processor expanded curpragma=" curpragma)
      (let ( (:long lix (get_int curpragma))
	     (namestr (get_field :named_name curpragma))
	     (space (get_field :gccpragma_space curpragma))
	     (spacestr (if space (get_field :named_name space)))
	     )
	(debug "real_pragma_processor expandedpragma lix=" lix 
	       "; spacestr=" spacestr " namestr=" namestr)
	(assert_msg "check lix" (==i lix ix) lix ix curpragma)
	(assert_msg "check spacestr" (or (null spacestr)
					 (>i (string_length spacestr) 0)) 
		    space curpragma)
	(assert_msg "check namestr" (>i (string_length namestr) 0) namestr curpragma)
	(code_chunk expandedpragma_chk
	 #{ /* real_pragma_processor $EXPANDEDPRAGMA_CHK */
	 debugeprintf ("real_pragma_processor $EXPANDEDPRAGMA_CHK lix=%ld", $LIX);
	 // we internize the space and name strings
	 const char*internedspace
	    = ($SPACESTR)?(melt_intern_cstring (melt_string_str ($SPACESTR))):NULL;
	 const char*internedname
            =  melt_intern_cstring (melt_string_str ($NAMESTR));
	 debugeprintf ("real_pragma_processor $EXPANDEDPRAGMA_CHK internedspace=%s internedname=%s", 
		       internedspace, internedname);
	 c_register_pragma_with_expansion_and_data
           (internedspace, internedname,
            melt_pragma_process_callback,
            (void*) $LIX) ;
	 debugeprintf ("real_pragma_processor $EXPANDEDPRAGMA_CHK registered pragma space %s name %s lix#%ld",
		       internedspace, internedname, $LIX);
	 }#)
	)
      )
    (:else
     (assert_msg "bad curpragma" curpragma curpragma))
    )
   )
  (debug "real_pragma_processor done pragmatup=" pragmatup)
  (return pragmatup)
  )

;; see warmelt-hooks.melt and its hook_register_pragmas
(register_pragma_processor real_pragma_processor)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TREE DIAGNOSTIC OUTPUT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun diag_tree (diagstate :tree tr)
  (debug "diag_tree start diagstate=" diagstate " tr=" tr)
  (assert_msg "check diagstate" (is_a diagstate class_diagnostic_state))
  (let ( (outbuf (make_strbuf discr_strbuf))
	 )
    (output_tree_briefly outbuf tr)
    (strbuf2string discr_string outbuf)))
(register_diag_tree diag_tree)

;;;;;;;;;;;;;;;;
;;; primitive to push the cfun asociated with a function declaration
;;; this is required otherwise dump of gimple crashes
(defprimitive push_cfun_decl (:tree fundecl) :void
#{ push_cfun(DECL_STRUCT_FUNCTION($fundecl)) }#) 
(defprimitive pop_cfun () :void
"pop_cfun()")


(export_class class_gcc_expanded_pragma)
(export_class class_gcc_plain_pragma)

(export_values
 ;;in alphanumerical order
 ==t
 arity_tree_call_expr
 build_case_label
 build_identifier_tree
 build_int_tree
 build_string_tree
 check_c_frontend
 foreach_argument_in_function_tree
 foreach_argument_in_call_expr_tree
 foreach_chain_value_purpose_in_tree_list 
 foreach_element_in_tree_constructor
 foreach_maptree
 inform_at_tree
 inside_c_frontend
 is_maptree
 is_tree
 isnull_tree
 make_maptree
 make_tree
 make_tree_call_expr
 maptree_aux
 maptree_auxput
 maptree_count
 maptree_get
 maptree_nth_attr
 maptree_nth_val
 maptree_put
 maptree_remove
 maptree_size
 nth_arg_tree_call_expr
 null_tree
 pop_cfun
 pragma_lex
 push_cfun_decl
 register_expanded_pragma
 register_plain_pragma
 tree_addr_expr
 tree_any_abstract_decl
 tree_any_artificial_decl
 tree_any_decl_of_context
 tree_any_decl_of_initial
 tree_any_decl_of_origin
 tree_any_decl_of_type_align_size
 tree_any_external_decl
 tree_any_ignored_decl
 tree_any_local_decl
 tree_any_nonabstract_decl
 tree_any_nonartificial_decl
 tree_any_nonexternal_decl
 tree_any_nonignored_decl
 tree_any_nonlocal_decl
 tree_any_nonvirtual_decl
 tree_any_type
 tree_any_type_of_chain
 tree_any_type_of_context
 tree_any_type_of_pointer_to
 tree_any_type_of_size
 tree_any_type_of_variant
 tree_any_virtual_decl
 tree_array_range_ref_full
 tree_array_ref
 tree_array_ref_full
 tree_array_type
 tree_bit_field_ref
 tree_bind_expr
 tree_block
 tree_boolean_false_node 
 tree_boolean_true_node 
 tree_boolean_type
 tree_boolean_type_node
 tree_case_label_expr
 tree_chain_append
 tree_chain_join
 tree_chain_prepend
 tree_chain_to_tuple
 tree_char_type_node
 tree_cleanup_point_expr
 tree_complex_cst
 tree_complex_type
 tree_component_ref
 tree_component_ref_full
 tree_component_ref_typed
 tree_compound_expr
 tree_cond_expr
 tree_const_decl
 tree_const_decl_named
 tree_const_decl_of_name
 tree_const_ptr_type_node
 tree_constructor
 tree_content 
 tree_create_artificial_label
 tree_debug_expr_decl
 tree_decl
 tree_decl_at_source_location
 tree_double_type_node 
 tree_enumeral_type
 tree_error_mark
 tree_expr_at_source_location
 tree_field_decl
 tree_fixed_cst
 tree_fixed_point_type
 tree_float_type_node 
 tree_function_decl 
 tree_function_decl_full 
 tree_function_decl_named
 tree_function_decl_named_of_type
 tree_function_decl_of_name
 tree_function_decl_of_type_and_result
 tree_function_type
 tree_identifier
 tree_imagpart_expr
 tree_imported_decl
 tree_indirect_reference
 tree_init_expr
 tree_integer_cst
 tree_integer_minus_one_node 
 tree_integer_one_node 
 tree_integer_type
 tree_integer_type_bounded
 tree_integer_type_node 
 tree_integer_zero_node 
 tree_label_decl
 tree_lang_type
 tree_list
 tree_long_double_type_node 
 tree_long_integer_type_node 
 tree_long_long_integer_type_node 
 tree_long_long_unsigned_type_node 
 tree_long_unsigned_type_node 
 tree_mem_ref
 tree_modify_expr
 tree_namelist_decl
 tree_namespace_decl
 tree_null_pointer_node 
 tree_nullptr_type
 tree_obj_type_ref
 tree_of_type
 tree_offset_type
 tree_parm_decl
 tree_parm_decl_named
 tree_parm_decl_of_name
 tree_pointer_type
 tree_pointer_type_p
 tree_placeholder_expr
 tree_ptr_type_node 
 tree_qual_union_type
 tree_qual_union_type_with_fields
 tree_realpart_expr
 tree_real_cst
 tree_real_type
 tree_record_type
 tree_record_type_with_fields
 tree_reference_type
 tree_result_decl
 tree_result_decl_named
 tree_result_decl_of_name
 tree_short_integer_type_node 
 tree_short_unsigned_type_node 
 tree_signed_char_type_node 
 tree_signed_size_type_node 
 tree_simple_ssa_name 
 tree_size_type_node 
 tree_ssa_name 
 tree_string_cst
 tree_target_expr
 tree_translation_unit_decl
 tree_type   
 tree_type_addr_space
 tree_type_canonical
 tree_type_decl
 tree_type_decl_named
 tree_type_decl_with_name
 tree_type_declaration
 tree_type_p
 tree_types_compatible_p
 tree_uid
 tree_uint16_type_node
 tree_uint32_type_node
 tree_uint64_type_node
 tree_union_type
 tree_union_type_with_fields
 tree_unsigned_char_type_node 
 tree_unsigned_type_node
 tree_useless_type_conversion_p 
 tree_va_arg_expr
 tree_va_list_type_node
 tree_var_decl
 tree_var_decl_named
 tree_var_decl_of_name
 tree_vec
 tree_vec_cond_expr
 tree_vec_perm_expr
 tree_vector_cst
 tree_vector_type
 tree_view_convert_expr
 tree_void_type
 tree_void_type_node
 tree_with_cleanup_expr
 warning_at_tree
 warning_at_tree_decl_with_number
)


;;; second and last load of _libmelt-treecode.melt should go here
(let (      
      (:macro gcc_tree_code (sexp env mexpander modctx)
	      (debug "gcc_tree_code:macro2" ": sexp=" sexp)
	      (let (
		    (sloc (get_field :loca_location sexp))
		    (sexcont (get_field :sexp_contents sexp))
		    (xargs (expand_restlist_as_tuple sexcont env mexpander modctx))
		    (namecod (multiple_nth xargs 0))
		    (strcod (multiple_nth xargs 1))
		    (typcod (multiple_nth xargs 2))
		    (nargcod (multiple_nth xargs 3))
		    (nbargs (multiple_length xargs))
		    (namev (get_field :named_name namecod))
		    (treenamev (string4out discr_string "tree_" namev))
		    (treesymb (create_symbolstr treenamev))
		    (statesymb (create_symbolstr (string4out discr_string "treestate_" namev)))
		    )
		(when (!=i 4 nbargs)
		  (error_at sloc "GCC_TREE_CODE need four arguments, got $1" xargs)
		  (return))
		(debug "gcc_tree_code:macro2"
		       "; namecod=" namecod
		       " strcod=" strcod
		       " typcod=" typcod
		       " nargcod=" nargcod
		       "\n.. treesymb=" treesymb
		       "\n.. bind:" (find_env env treesymb))
		(assert_msg "check namev" (is_string namev) namev namecod sexp)
		(unless (find_env env treesymb)
		  (debug "gcc_tree_code:macro2" " treesymb=" treesymb)
		  (cond
		   ;; tcc_exceptional, no automatic sub-trees
		   (  (== typcod 'tcc_exceptional)
		      (debug "gcc_tree_code:macro2" "; exceptional namev=" namev)
		      (let
			  (
			   (xcmatchdoc
			    (let
				(
				 (d
				  (substitute_sexpr
				   '#{Generated tcc_exceptional $TREESYMB cmatcher.}#
				   (lambda (symb)
				     (debug "gcc_tree_code:macro2-lambdasubstdoc symb=" symb)
				     (if (== symb 'treesymb)
					 (get_field :named_name treesymb)
				       symb))))
				 )
			      (debug "gcc_tree_code:macro2" "; sloc=" sloc " exceptional xcmatchdoc=" d)
			      d))
			   (xmatexp
			    (let
				(
				 (e
				  (substitute_sexpr
				   '#{ /* generated exceptional $TREESYMB tester ? */
				   $TR && TREE_CODE($TR) == $NAMECOD }#
				   (lambda (symb)
				     (debug "gcc_tree_code:macro2-lambdasubstexp symb=" symb)
				     (cond
				      ( (== symb 'treesymb)
					(clone_with_discriminant (get_field :named_name treesymb) discr_verbatim_string)
					)
				      ( (== symb 'namecod)
					(clone_with_discriminant (get_field :named_name namecod) discr_verbatim_string)
					)
				      (:else
				       symb)))
				   ))
				 )
			      (debug "gcc_tree_code:macro2" "; sloc=" sloc " exceptional xmatexp=" e)
			      e))
			   (xcmatcher
			    `(defcmatcher ,treesymb
			       (:tree tr)
			       ()
			       ,statesymb
			       :doc ,xcmatchdoc
			       ;; match-expander
			       ,xmatexp
			       ))
			   (xexport `(export_values ,treesymb))
			   )
			(put_fields xcmatcher :loca_location sloc)
			(put_fields xexport :loca_location sloc)
			(debug "gcc_tree_code:macro2" "; sloc=" sloc " exceptional xcmatcher=" debug_more xcmatcher
			       "\n.. xexport=" xexport)
			(let (
			      (rmatch (macroexpand_1 xcmatcher env mexpander modctx))
			      (rexport (macroexpand_1 xexport env mexpander modctx))
			      )
			  (debug "gcc_tree_code:macro2" "; sloc=" sloc " exceptional rmatch=" rmatch
				 "\n.. rexport=" rexport)
			  (return rmatch (tuple rexport))
			  ))
		      )
		   ;; tcc_constant & tcc_declaration, without sub-trees
		   (
		    (or (== typcod 'tcc_constant)
			(== typcod 'tcc_declaration)
			(== typcod 'tcc_type)
			)
		    (debug "gcc_tree_code:macro2" "; simple namev=" namev)
		    (if (>i (get_int nargcod) 0)
			(error_at sloc "GCC_TREE_CODE $1 of tcc_constant or tcc_declaration type with non-zero arity $2"
				  treesymb nargcod
				  ))
		    (let
			(
			 (xcmatchdoc
			  (let
			      (
			       (d
				(substitute_sexpr
				 '#{Generated simple $TYPCOD $TREESYMB cmatcher.}#
				 (lambda (symb)
				   (debug "gcc_tree_code:macro2-lambdasubsttypcod symb=" symb)
				   (if (== symb 'typcod)
				       (get_field :named_name typcod)
				     symb))))
			       )
			    (debug "gcc_tree_code:macro2" "; sloc=" sloc "; constdecl xcmatchdoc=" d)
			    d))
			 (xmatexp
			  (let
			      (
			       (e
				(substitute_sexpr
				 '#{ /* generated simple $TREESYMB tester ? */
				 $TR && TREE_CODE($TR) == $NAMECOD }#
				 (lambda (symb)
				   (debug "gcc_tree_code:macro2-lambdasubsttypcod symb=" symb)
				   (cond
				    ( (== symb 'treesymb)
				      (clone_with_discriminant (get_field :named_name treesymb) discr_verbatim_string)
				      )
				    ( (== symb 'namecod)
				      (clone_with_discriminant (get_field :named_name namecod) discr_verbatim_string)
				      )
				    (:else
				     symb)))
				 ))
			       )
			    (debug "gcc_tree_code:macro2" "; sloc=" sloc "; constdecl xmatexp=" e)
			    e))
			 (xcmatcher
			  `(defcmatcher ,treesymb
			     (:tree tr)
			     ()
			     ,statesymb
			     :doc ,xcmatchdoc
			     ;; match-expander
			     ,xmatexp
			     ))
			 (xexport `(export_values ,treesymb))
			 )
		      (put_fields xcmatcher :loca_location sloc)
		      (put_fields xexport :loca_location sloc)
		      (debug "gcc_tree_code:macro2" "; sloc=" sloc "; constdecl xcmatcher=" debug_more xcmatcher
			     "\n.. xexport=" xexport)
		      (let (
			    (rmatch (macroexpand_1 xcmatcher env mexpander modctx))
			    (rexport (macroexpand_1 xexport env mexpander modctx))
			    )
			(debug "gcc_tree_code:macro2" "; sloc=" sloc "; rmatch=" rmatch
			       "\n.. rexport=" rexport)
			(return rmatch (tuple rexport))
			))
		    )
		   ;; For fixed tcc_reference, tcc_expression,
		   ;; tcc_comparison, tcc_unary, tcc_binary,
		   ;; tcc_statement.  They use the arity fourth
		   ;; argument, and we extract sub-tree operands.
		   (
		    (or (== typcod 'tcc_reference)
			(== typcod 'tcc_expression)
			(== typcod 'tcc_unary)
			(== typcod 'tcc_binary)
			(== typcod 'tcc_comparison)
			(== typcod 'tcc_statement)
			)
		    (debug "gcc_tree_code:macro2" "; fixed namev=" namev)
		    (let
			(
			 (xcmatchdoc
			  (let
			      (
			       (d
				(substitute_sexpr
				 '#{Generated fixed $TYPCOD $TREESYMB cmatcher of arity $NARGCOD.}#
				 (lambda (symb)
				   (debug "gcc_tree_code:macro2-lambdasubstfixed symb=" symb)
				   (cond
				    ( (== symb 'typcod)
				      typcod)
				    ( (== symb 'nargcod)
				      nargcod)
				    (:else symb))
				   )))
			       )
			    (debug "gcc_tree_code:macro2" "; sloc=" sloc "; fixed xcmatchdoc=" d)
			    d))
			 (xmatexp
			  (let
			      (
			       (e
				(substitute_sexpr
				 '#{ /* generated fixed $TREESYMB tester ? */
				 $TR && TREE_CODE($TR) == $NAMECOD }#
				 (lambda (symb)
				   (debug "gcc_tree_code:macro2-lambdasubstfixed symb=" symb)
				   (cond
				    ( (== symb 'treesymb)
				      (clone_with_discriminant (get_field :named_name treesymb) discr_verbatim_string)
				      )
				    ( (== symb 'namecod)
				      (clone_with_discriminant (get_field :named_name namecod) discr_verbatim_string)
				      )
				    ( (== symb 'nargcod)
				      nargcod)
				    (:else
				     symb)))
				 ))
			       )
			    (debug "gcc_tree_code:macro2" " sloc=" sloc "; fixed xmatexp=" e)
			    e))
			 (xlistfill (make_list discr_list))
			 (tupopervar
			  (let ( (:long narity (get_int nargcod))
				 ( tv (make_multiple discr_multiple narity))
				 )
			    (foreach_long_upto
			     (1 narity)
			     (:long ix)
			     (let ( (:long previx (-i ix 1))
				    (opnamstr (string4out discr_string "TROPERAND" previx))
				    (opnamsymb (create_symbolstr opnamstr))
				    )
			       (multiple_put_nth tv previx opnamsymb)
			       (let ( (tr 'tr)
				      )
				 (add2list xlistfill ##{ $OPNAMSYMB = TREE_OPERAND($TR, $PREVIX)}#
					   ";\n")
				 )
			       )
			     )
			    (debug "gcc_tree_code:macro2" "; sloc=" sloc "; fixed tupopervar=" tv
				   "\n.. updated xlistfill=" xlistfill)
			    tv
			    ))
			 (xmatfill
			  (let ( (e (substitute_sexpr
				     '#{ /* generated fixed $TREESYMB filler ! */
				     $XLISTFILL
				     /* end of generated fixed $TREESYMB filler */}#
				     (lambda (symb)
				       (debug "gcc_tree_code:macro2-lambdasubstfixfiller symb=" symb)
				       (cond
					( (== symb 'treesymb)
					  (clone_with_discriminant (get_field :named_name treesymb) discr_verbatim_string)
					  )
					( (== symb 'xlistfill)
					  xlistfill)
					(:else symb))
				       )))
				 )
			    (debug "gcc_tree_code:macro2" " sloc=" sloc "; fixed xmatfill=" e)
			    e
			    )
			  )
			 (xcmatcher
			  (let ( (m
				  `(defcmatcher ,treesymb
				     (:tree tr)
				     (:tree ,tupopervar)
				     ,statesymb
				     :doc ,xcmatchdoc
				     ;; match-expander
				     ,xmatexp
				     ;; match-filler
				     ,xmatfill
				     ))
				 )
			    (debug "gcc_tree_code:macro2" " sloc=" sloc "; fixed xcmatcher=" m)
			    m))
			 (xexport `(export_values ,treesymb))
			 )
		      (put_fields xcmatcher :loca_location sloc)
		      (put_fields xexport :loca_location sloc)
		      (debug "gcc_tree_code:macro2" " sloc=" sloc "; " "@fixed xcmatcher=" debug_more xcmatcher
			     "\n.. xexport=" xexport)
		      (let (
			    (rmatch (macroexpand_1 xcmatcher env mexpander modctx))
			    (rexport (macroexpand_1 xexport env mexpander modctx))
			    )
			(debug "gcc_tree_code:macro2" " rmatch=" rmatch
			       "\n.. rexport=" rexport)
			(return rmatch (tuple rexport))
			))
		    )
		   ( (and (== typcod 'tcc_vl_exp)
			  (== namecod 'call_expr))
		     ;; CALL_EXPR is handled specially
		     (inform_at sloc "GCC_TREE_CODE wont handle CALL_EXPR")
		     (return))
		   ;; otherwise
		   ( :else
		     (debug "gcc_tree_code:macro2 bad namev=" namev)
		     (warning_at sloc "MELT should define $1 for tree code of type $2 arity $3"
				 treesymb typcod nargcod)
		     )
		   )
		  (error_at sloc "unexpected GCC_TREE_CODE for $1 of $2" namev typcod)
		  )
		(return ()) ;;  temporarily, happens for non-handled cases
		)
	      )
      )
  ;;
  (debug "before loading2 libmelt-treecode")
  (skip_nil (load "_libmelt-treecode.melt"))
  (debug "after loading2 libmelt-treecode")
  )



;; keep this code chunk at the end of libmelt-ana-tree.melt
(when (inside_c_frontend)
  (code_chunk 
   finalanatree_chk 
   #{ /* libmelt-ana-tree.melt: start $FINALANATREE_CHK */
   static long count_$FINALANATREE_CHK ;
   debugeprintf("count_$FINALANATREE_CHK  = %ld", count_$FINALANATREE_CHK) ;
   if (!count_$FINALANATREE_CHK) 
     {
       debugeprintf ("$FINALANATREE_CHK #%ld registering pragmas", count_$FINALANATREE_CHK) ;
       register_callback (melt_plugin_name, PLUGIN_PRAGMAS,
			  melt_register_pragmas_callback, NULL)	;
     };
     count_$FINALANATREE_CHK++	;
     /* libmelt-ana-tree.melt: end $FINALANATREE_CHK */
     }#)
  (debug "libmelt-ana-tree final registered PLUGIN_PRAGMAS")
  )
;; eof libmelt-ana-tree.melt
