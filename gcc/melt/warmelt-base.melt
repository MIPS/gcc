;; -*- Lisp -*-
;; file warmelt-base.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008 - 2014  Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
               and Pierre Vittet  <piervit@pvittet.com>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-base.melt and 
;; to the generated file  warmelt-base*.c

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;    This file is part of a bootstrapping compiler for the MELT lisp
;;    dialect, compiler which should be able to compile itself (into
;;    generated C file[s])
;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; This MELT module is GPL compatible since it is GPLv3+ licensed.
(module_is_gpl_compatible "GPLv3+")

;; CAVEAT: We cannot have defmacro or backquote in this warmelt-base
;; file, because make_sexpr is not yet available, so diagnostic
;; support has to be in warmelt-macro.melt file...


;; Our multiple_sort needs std::sort used with hook_sort_compare_less
(cheader #{
/* C++ standard headers for multiple_sort */
#include <vector>
#include <algorithm>
}#)

;; internal primitive to make a fresh environment reference; call the
;; hook_fresh_environment_reference_maker from warmelt-hooks.melt
(defprimitive melt_make_fresh_environment_reference
  (:value prevenv :cstring modulname) :value
  :doc #{Internal primitive $MELT_MAKE_FRESH_ENVIRONMENT to call the $HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER, 
used to create new environments in modules. Only for gurus and MELT itself.}#
  #{ /* melt_make_fresh_environment_reference */ 
  melthookproc_HOOK_FRESH_ENVIRONMENT_REFERENCE_MAKER ((melt_ptr_t) ($PREVENV), $MODULNAME)
  }#)

(defprimitive melt_call_depth () :long
  :doc #{The primitive $MELT_CALL_DEPTH returns the call depth of the current MELT frame stack.}#
  #{ /*melt_call_depth*/ Melt_CallProtoFrame::top_call_depth() }#)

(defprimitive melt_call_deeper_than (:long d) :long
  :doc #{The primitive $MELT_CALL_DEEPER_THAN returns non-zero if the current MELT frame stack is deeper than $D.}#
  #{ /*melt_call_deeper_than*/ Melt_CallProtoFrame::top_call_deeper_than((int) $D) }#)

;; negation of is_object
(defprimitive is_not_object (obj) :long
  :doc #{Test if $OBJ is not an object. Negation of $IS_OBJECT.}#
  #{(melt_magic_discr((melt_ptr_t)($obj)) != MELTOBMAG_OBJECT)}#)


;; primitive to safely return a global predef by its index
(defprimitive get_globpredef (:long ix) :value
  :doc #{Safely gives the predefined of index $IX or null.}#
  #{/*get_globpredef*/ ((melt_ptr_t) melt_globpredef($ix))}#)

;; primitive to get the hashcode of an object (or 0)
(defprimitive obj_hash (v) :long
  :doc #{Safely gives the hashcode of object $V or else 0.}#
  #{(melt_obj_hash((melt_ptr_t)($v)))}#)

;; primitive to get the length of an object (or 0)
(defprimitive obj_len (v) :long
  :doc #{Safely gives the length of object $V or else 0.}#
  #{(melt_obj_len((melt_ptr_t)($v)))}#)


;; primitive to get the number of an object (or 0)
(defprimitive obj_num (v) :long
  :doc #{Safely gives the number of object $V or else 0.}#
  #{(melt_obj_num((melt_ptr_t)($v)))}#)

;; primitive to compute a nonzero hash
(defprimitive nonzero_hash () :long
  :doc #{Gives a pseudo-random non-zero number suitable as an hash code.}# 
  "(melt_nonzerohash())")


;; primitives to force garbage collection
(defprimitive minor_garbcoll (:long siz) :void 
  :doc #{Force a minor MELT garbage collection. The $SIZ is the amount
  of memory to reserve.}#
  #{melt_garbcoll(($siz), MELT_MINOR_OR_FULL)}#)

(defprimitive full_garbcoll (:long siz) :void
  :doc #{Force a full MELT garbage collection. The $SIZ is the amount
  of memory to reserve.}#
  #{melt_garbcoll(($siz), MELT_NEED_FULL)}#)


;; check explicitly the call stack  
(defprimitive checkcallstack_msg (:cstring msg) :void
  :doc #{Low level costly primitive to check the entire call stack to
help hunt memory or GC bugs. Displays the given $MSG if the check went
wrong. Use it when desperate.}#
  #{melt_check_call_frames(MELT_ANYWHERE, $msg);}#)

;; internal primitive useful to increment the debug counter, used to
;; expand (DEBUG ...) macro
(defprimitive melt_increment_dbgcounter () :void
  #{/*melt_increment_dbgcounter*/ 
#if MELT_HAVE_DEBUG
melt_dbgcounter++;
#endif
}#)

;; for breakpoint
(defprimitive cbreak_msg (:cstring msg) :void
  :doc #{Low level primitive for GDB breakpoints. Use it temporarily,
given a string $MSG, with gdb when desperate.}#
  #{melt_cbreak($msg)}#)


(defprimitive c_time () :long
  :doc #{Get the current time(2) since Unix epoch in seconds.}#
  #{((long)time((time_t*)0))}#)

(defprimitive c_clock () :long
  :doc #{Get the current cpu clock(3) in microseconds.}#
  #{((long)clock())}#)

(defprimitive relative_time_millisec () :long
  :doc #{Get the real time, relative to MELT start, in milliseconds.}#
  #{melt_relative_time_millisec()}#)

(defprimitive set_real_timer_millisec (:long millisec) :void
  :doc #{Set the real time alarm in millisecond (or clear alarm if $MILLISEC is non-positive)}#
  #{melt_set_real_timer_millisec($MILLISEC)}#)

;; compare of longs [some primitives remain in warmelt-first.melt
;; because they are needed there]

(defprimitive <=i (:long a b) :long :doc #{Integer test that $A less or equal to $B.}#
  #{(($a) <= ($b))}#)

(defprimitive ==i (:long a b) :long  :doc #{Integer test that $A is equal to $B.}#
  #{(($a) == ($b))}#)


(defprimitive !=i (:long a b) :long  :doc #{Integer test that $A is unequal to $B.}#
  #{(($a) != ($b))}#)

;;; maximal & minimal of two longs
(defprimitive maxi (:long a b) :long 
  :doc #{$MAXI gives the maximum of two integers $A and $B}# 
#{MAX(($a),($b))}#)

(defprimitive mini (:long a b) :long 
  :doc #{$MINI gives the maximum of two integers $A and $B}# 
#{MIN(($a),($b))}#)


;;; long integer arithmetics; some primitives stay in warmelt-first.melt
(defprimitive -i (:long a b) :long  :doc #{Integer binary substraction of $a and $b.}#
  #{(($a) - ($b))}#)

(defprimitive *i (:long a b) :long  :doc #{Integer binary product of $a and $b.}#
  #{(($a) * ($b))}#)
(defprimitive andi (:long a b) :long   :doc #{Integer binary bitwise and of $a and $b.}#
  #{(($a) & ($b))}#)
(defprimitive ori (:long a b) :long  :doc #{Integer binary bitwise or of $a and $b.}#
  #{(($a) | ($b))}#)
(defprimitive xori (:long a b) :long :doc #{Integer binary bitwise exclusive-or of $a and $b.}#  
  #{(($a) ^ ($b))}#)

(defprimitive negi (:long i) :long  :doc #{Integer unary negation of $i.}#
  #{(-($i))}#)
(defprimitive noti (:long i) :long :doc #{Integer unary bitwise complement of $i.}# 
  #{(~($i))}#)


;;; functions for boxed arithmetic are costly, but you might find them useful.
(defun +iv (a b) 
  :doc #{Boxed integer addition of two boxed integers. 
  It is slow, since it is boxing.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (make_integerbox discr_constant_integer 
			   (+i (get_int a) (get_int b))))))

(defun -iv (a b) 
  :doc #{Boxed integer substraction of two boxed integers. 
  It is slow, since it is boxing.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (make_integerbox discr_constant_integer 
			   (-i (get_int a) (get_int b))))))


(defun *iv (a b) 
  :doc #{Boxed integer multiplication of two boxed integers. 
  It is slow, since it is boxing.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (make_integerbox discr_constant_integer 
			   (*i (get_int a) (get_int b))))))

(defun /iv (a b) 
  :doc #{Boxed integer division of two boxed integers. 
  It is slow, since it is boxing. Return null when undefined.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (if (get_int b)
	      (make_integerbox discr_constant_integer 
			       (/i (get_int a) (get_int b)))))))


(defun %iv (a b) 
  :doc #{Boxed integer remainder of two boxed integers. 
  It is slow, since it is boxing. Return null when undefined.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (let ( (:long ib (get_int b)) )
	    (if ib
		(make_integerbox discr_constant_integer 
				 (%i (get_int a) ib)))))))


(defprimitive +ivi (a :long lb) :value
  :doc #{Add boxed integer $A to constant raw long $LB. Return null if $A is not a boxed integer.}#
  #{/*+ivi*/ ((melt_magic_discr((melt_ptr_t) $A)==MELTOBMAG_INT)?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value((melt_ptr_t) $A) + ($LB))))
         :(melt_ptr_t)NULL)}#)



(defprimitive -ivi (a :long lb) :value
  :doc #{substract from boxed integer $A the constant raw long $LB. Return null if $A is not a boxed integer.}#
  #{/* -ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT)?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value($A) - ($LB))))
         :(melt_ptr_t)NULL)}#)


(defprimitive *ivi (a :long lb) :value
  :doc #{multiply boxed integer $A by constant raw long $LB. Return null if $A is not a boxed integer.}#
  #{/* *ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT)?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value($A) * ($LB))))
         :(melt_ptr_t)NULL)}#)


(defprimitive /ivi (a :long lb) :value
  :doc #{divide boxed integer $A by constant raw long $LB. Return null if $A is not a boxed integer or $LB is zero.}#
  #{/* /ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT && ($LB != 0L))?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value($A) / ($LB))))
         :(melt_ptr_t)NULL)}#)


(defprimitive %ivi (a :long lb) :value
  :doc #{modulus boxed integer $A by constant raw long $LB. Return null if $A is not a boxed integer or $LB is zero.}#
  #{/* %ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT && ($LB != 0L))?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value($A) % ($LB))))
         :(melt_ptr_t)NULL)}#)


(defprimitive <iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for less than. 
Return 0 for non-boxed integer values.}#
  #{/* <iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               < (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive <=iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for less or equal. 
Return 0 for non-boxed integer values.}#
  #{/* <=iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               <= (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive =iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for numeric equality. 
Return 0 for non-boxed integer values.}#
  #{/* =iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               == (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive !=iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for numeric inequality. 
Return 0 for non-boxed integer values.}#
  #{/* !=iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               != (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive >iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for greater than. 
Return 0 for non-boxed integer values.}#
  #{/* >iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               > (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive >=iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for greater or equal. 
Return 0 for non-boxed integer values.}#
  #{/* >=iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               >= (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive <ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for less than. Return 0 if $A is not a boxed integer.}#
  #{/* <ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) < ($LB)))}#)

(defprimitive <=ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for less or equal. Return 0 if $A is not a boxed integer.}#
  #{/* <=ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) <= ($LB)))}#)

(defprimitive >ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for greater than. Return 0 if $A is not a boxed integer.}#
  #{/* >ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) > ($LB)))}#)

(defprimitive >=ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for greater or equal. Return 0 if $A is not a boxed integer.}#
  #{/* >=ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) >= ($LB)))}#)

(defprimitive =ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for numeric equality. Return 0 if $A is not a boxed integer.}#
  #{/* >=ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) == ($LB)))}#)

(defprimitive !=ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for numeric inequality. Return 0 if $A is not a boxed integer.}#
  #{/* >=ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) != ($LB)))}#)

;;; various tests

(defprimitive notnull (v) :long :doc #{Test that $V is not the null value.}#
  #{(($v) != NULL)}#)

;;; zero test (for numbers)
(defprimitive zerop (:long i)  :long :doc #{Test that $I is zero.}# 
  #{/*zerop:*/ (($I) == 0L)}#)

;;; debug on dumpfile
(defprimitive outcstring_dbg (:cstring s) :void :doc #{output a debug string $S.}#
  #{melt_puts(dump_file,($s))}#)
(defprimitive outnum_dbg (:cstring pref :long l :cstring suf) :void
  :doc #{debug output an integer $L with prefix $PREF and suffix $SUF.}#
  #{melt_putnum(dump_file,($pref), ($l), ($suf))}#)
(defprimitive outstr_dbg (str) :void :doc #{output a debug string value $STR.}#
  #{melt_putstr(dump_file,(melt_ptr_t)($str))}#)

(defprimitive outstrbuf_dbg (sbuf) :void :doc #{output a debug stringbuffer value $SBUF.}#
  #{melt_putstrbuf(dump_file,(melt_ptr_t)($sbuf))}#)
(defprimitive outnewline_dbg () :void :doc #{output a debug newline.}#
  #{melt_newlineflush(dump_file)}#)
;;; output on stderr
(defprimitive outnum_err (:cstring pref :long l :cstring suf) :void
  :doc #{output on stderr the number $L with prefix $PREF and suffix $SUF.}#
  #{melt_putnum(stderr,($pref), ($l), ($suf))}#)
(defprimitive outcstring_err (:cstring s) :void
  :doc #{Output on stderr the string $s.}#
  #{melt_puts(stderr,($s))}#)
(defprimitive outstrbuf_err (sbuf) :void
  :doc #{Output on stderr the stringbuffer value $sbuf.}#
  #{melt_putstrbuf(stderr,(melt_ptr_t)($sbuf))}#)


;; various primitives

;; change the head of a pair
(defprimitive pair_set_head (pa hd) :void
  :doc #{Safely set in pair $PA its head to $HD. 
Please avoid using that to introduce circularities in lists.}#
 #{meltgc_pair_set_head((melt_ptr_t)($pa), ($hd))}#)
;; length of a pair list
(defprimitive pair_listlength (pa) :long
  :doc #{Compute the linked length of given pair value $PA or else 0.}#
  #{(melt_pair_listlength((melt_ptr_t)($pa)))}#)

;; make a pair
(defprimitive make_pair (discr hd tl) :value
  :doc #{Create a new pair of given discrimiant $DISCR head $HD and
tail $TL or else null.}#
  #{(meltgc_new_pair((meltobject_ptr_t)($discr), (melt_ptr_t)($hd), (melt_ptr_t)($tl)))}#)

;;;;;; MIXINT primitives (use get_int to get the integer)
(defprimitive is_mixint (mi) :long
  :doc #{Test if value $MI is a mixedint value.}#
  #{(melt_magic_discr((melt_ptr_t)($mi)) == MELTOBMAG_MIXINT)}#)
;; get the value
(defprimitive mixint_val (mi) :value
  :doc #{Get the value inside a mixedint value $MI. The integer can be retrieved using $GET_INT.}#
  #{(melt_val_mixint((melt_ptr_t)($mi)))}#)
;; make a mixint
(defprimitive make_mixint (dis val :long num) :value
  :doc #{Make a mixint value of given discriminant $DIS value $VAL and number $NUM or else null.}#
  #{(meltgc_new_mixint((meltobject_ptr_t)($dis), (melt_ptr_t)($val), ($num)))}#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; the quoting mechanism needs to make mixint thu a hook
(defhook hook_melt_make_location (:cstring filename :long lineno) () :value
  :predef HOOK_MELT_MAKE_LOCATION
  :doc #{Hook to make a mixed integer representing the location at given $FILENAME and $LINENO,
  useful for quoting s-expressions etc...}#
  (return (make_mixint discr_mixed_integer (make_stringconst discr_string filename) lineno)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MIXLOC primitives (use get_int to get the integer)
;; test
(defprimitive is_mixloc (mi) :long
  :doc #{Test if value $MI is a mixed location value.}#
  #{(melt_magic_discr((melt_ptr_t)($mi)) == MELTOBMAG_MIXLOC)}#)
;; get the value
(defprimitive mixloc_val (mi) :value
  :doc #{Safely retrieve the value inside a mixed location value $MI.}#
  #{(melt_val_mixloc((melt_ptr_t)($mi)))}#)
(defprimitive mixloc_location (mi) :long
  :doc #{Safely retrieve as an opaque long the location of a mixed location value $MI.}#
  #{((long) melt_location_mixloc((melt_ptr_t)($mi)))}#)
(defprimitive mixloc_locline (mi) :long
  :doc #{Retrieve the line of the location of a mixed location value $MI.}#
  #{(LOCATION_LINE(melt_location_mixloc((melt_ptr_t)$mi)))}#)
(defprimitive mixloc_locfile (mi) :cstring
  :doc #{Retrieve the filename as a raw cstring of a mixed location value $MI.}#
  #{(LOCATION_FILE(melt_location_mixloc((melt_ptr_t)$mi)))}#)
(defprimitive mixloc_locbasefile (mi) :cstring
  :doc #{Retrieve the base filename as a raw cstring of a mixed location value $MI.}#
  #{(lbasename(LOCATION_FILE(melt_location_mixloc((melt_ptr_t)$mi))))}#)

(defprimitive make_string_mixloc_file (mi dis) :value
  :doc #{Retrieve the filename as a boxed string of a mixed location value $MI.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($DIS), 
			  (LOCATION_FILE(melt_location_mixloc((melt_ptr_t)$MI)))))}#)

;; make a mixloc
(defprimitive make_mixloc (dis val :long num loc) :value
  :doc #{Make a mixed location value of given discriminant $DIS value $VAL
number $NUM opaque location number $LOC.}#
  #{(meltgc_new_mixloc((meltobject_ptr_t)($dis), (melt_ptr_t)($val), 
		       ($num), (location_t)($loc)))}#)



;; test for mixbigint
(defprimitive is_mixbigint (mb) :long
  :doc #{Test if value $MB is a mixed bigint.}#
  #{(melt_magic_discr((melt_ptr_t)($MB)) == MELTOBMAG_MIXBIGINT)}#)
(defprimitive mixbigint_val (mb) :value
  :doc #{Retrieve the value inside a mixed bigint $MB.}#
  #{melt_val_mixbigint((melt_ptr_t) $MB)}#)

(defprimitive ppstrbuf_mixbigint (:value sbuf :long indent :value mb) :void
 :doc #{Pretty prints into string buffer $SBUF at indentation $INDENT the mixed bigint $MB.}#
 #{meltgc_ppstrbuf_mixbigint((melt_ptr_t) $SBUF,$INDENT,(melt_ptr_t) $MB);}#
)


;;; READ FILE primitive
(defprimitive read_file (filnam) :value
  :doc #{Read from file named by the $FILNAM string balue a list of MELT s-expressions.}#
  #{(meltgc_read_file (melt_string_str((melt_ptr_t)($FILNAM)), (char*)0))}#)

(defprimitive read_strv (strv) :value
  :doc #{Return the list of s-exprs contained in in parsed string
  $STRV. $STRV can be a boxed string or a strbuf value.}#
  #{(meltgc_read_from_val ((melt_ptr_t) ($STRV), NULL))}# )

(defprimitive read_strv_loc (strv locv) :value
  :doc #{Return the list of s-exprs contained in in parsed string
  $STRV. $STRV can be a boxed string or a strbuf value. $LOCV is the
  string value used as the location file name.}#
  #{(meltgc_read_from_val ((melt_ptr_t) ($STRV), (melt_ptr_t) ($LOCV)))}#)



;; function to get the nth element of some list
(defun list_nth_element (lis :long rk)
  :doc #{The $LIST_NTH_ELEMENT function finds in list $LIS the
  component of rank $RK, counting from last element if $RK is
  negative. This function scans linearly the list till the component
  is found.}#
  (if (is_list lis)
      (let ( (:long ix 0)
	     )
	(cond
	 ( (>=i rk 0)
	   (foreach_pair_component_in_list
	    (lis)
	    (curpair curcomp)
	    (if (==i ix rk) 
		(return curcomp))
	    (setq ix (+i ix 1)))
	   (void))
	 (:else 
	  (let ( (:long ln (list_length lis))
		 (:long nrk (+i ln rk))
		 )
	    (if (and (>=i nrk 0) 
		     (<i nrk ln))
		(foreach_pair_component_in_list
		 (lis)
		 (curpair curcomp)
		 (if (==i ix nrk) 
		     (return curcomp))
		 (setq ix (+i ix 1))))))
	 )))
  (return ())
  )


;; to signal an error in a  source with some additional string value
(defprimitive error_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show an error at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_error_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)


;; signal a plain error in a  source
(defprimitive error_plain (loc :cstring cmsg) :void
  :doc #{Show a plain error at boxed location $LOC with raw message string $CMSG.}#
  #{/* error_plain */ melt_error_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; to signal an warning in a  source with some additional string value
(defprimitive warning_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show a warning at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_warning_str(0, (melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)

;; signal a plain warning in a  source
(defprimitive warning_plain (loc :cstring cmsg) :void
  :doc #{Show a plain warning at boxed location $LOC with raw message string $CMSG.}#
  #{melt_warning_str(0, (melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)

;; signal a plain warning 
(defprimitive warningmsg_plain (:cstring cmsg) :void
  :doc #{Show a plain warning with raw message string $CMSG.}#
  #{warning(0, "MELT WARNING MSG [#%ld]::: %s", melt_dbgcounter, ($cmsg))}#  )

;; signal a plain error 
(defprimitive errormsg_plain (:cstring cmsg) :void
  :doc #{Show a plain error with raw message string $CMSG.}#
  #{error ("MELT ERROR MSG [#%ld]::: %s", melt_dbgcounter, ($cmsg))}#
  )




;; signal a plain warning with string
(defprimitive warningmsg_strv (:cstring cmsg :value strv) :void
  :doc #{Show a plain warning with raw message string $CMSG and string value $STRV.}#
  #{warning (0, "MELT WARNING MSG [#%ld]::: %s - %s", melt_dbgcounter, ($cmsg),
	  melt_string_str((melt_ptr_t)($STRV)))}#
  )

;; signal a plain error with string
(defprimitive errormsg_strv (:cstring cmsg :value strv) :void
  :doc #{Show a plain error with raw message string $CMSG and string value $STRV.}#
  #{error ("MELT ERROR MSG [#%ld]::: %s - %s", melt_dbgcounter, ($cmsg),
	  melt_string_str((melt_ptr_t)($STRV)))}#
  )

;; to signal an inform in a  source with some additional string value
(defprimitive inform_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show a notice at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_inform_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)
;; signal a plain inform in a  source
(defprimitive inform_plain (loc :cstring cmsg) :void
  :doc #{Show a plain warning at boxed location $LOC with raw message string $CMSG.}#
  #{melt_inform_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)


(defprimitive informsg_plain (:cstring cmsg) :void
  :doc #{Show a plain notice with raw message string $CMSG.}#
  #{inform(UNKNOWN_LOCATION, "MELT INFORM [#%ld]: %s",  melt_dbgcounter, ($cmsg))}#
  )


;;; citerator on integers
(defciterator foreach_long_upto
  (:long imin imax)			;start formals
  eachlong				;state
  (:long ix)				;local formals
  :doc #{The $FOREACH_LONG_UPTO c-iterator provides the usual
ascending integer iterator. Start formals are $IMIN, the minimum start
integer, and $IMAX, le maximal ending integer. Local formal is $IX,
the current index. The body is executed for each integer value $IX
from $IMIN to $IMAX included.}#
  					;before expansion
#{/* foreach_long_upto start $EACHLONG */
    long $EACHLONG#_min =  $imin;
    long $EACHLONG#_max = $imax;
    long $EACHLONG#_cur = 0;
    for ($EACHLONG#_cur = $EACHLONG#_min;
         $EACHLONG#_cur <= $EACHLONG#_max;
	 $EACHLONG#_cur ++) {
	    $IX = $EACHLONG#_cur;	    
}#
 					;after expansion
   #{ } /*end foreach_long_upto $eachlong */}#
)
   
;;; match an integer i mutiple of a given number n and submatch the quotient
(defcmatcher some_integer_multiple
  (:long i n)				;match & ins
  (:long q)					;outs
  intmult				;statesymb
  :doc #{The $SOME_INTEGER_MULTIPLE matcher with input number $N matches an
integer $I if $N is positive and $I is multiple of $N and the quotient
matches the subpattern $Q.}#
  ;; test expansion
  #{ /*some_integer_multiple $INTMULT ?*/ ($N>0 && (($I) % ($N))==0) }#
  ;; fill expansion
  #{ /*some_integer_multiple $INTMULT !*/ $Q = ($I) / ($N); }#
  )


;;; match an integer i inside a given interval i.e. between limits lo
;;; and hi inclusive

(defcmatcher some_integer_between 
  (:long i lo hi)
  ()
  intbetween
  :doc #{The $SOME_INTEGER_BETWEEN matcher matches integers $I between a given $LO and $HI interval inclusively.}#
  ;; test expansion
  #{ /*some_integer_between $INTBETWEEN ?*/ (($I) >= ($LO) && (($I) <= ($HI))) }#
  ;; no fill
  )


;;; match an integer i different from a given number n
(defcmatcher some_integer_different_from
  (:long i n)
  ()
  intdiffrom
  :doc #{The $SOME_INTEGER_DIFFRERENT_FROM or @code{some_integer_!=} matcher with input number $N matches
an integer $I if $I is different from $N.}#
  ;; test expansion
  #{ /* some_integer_different_from $INTDIFFROM ?*/ ($I != $N) }#
  ;; no fill expansion
)

;;; match an integer i equal to a given number n
(defcmatcher some_integer_equal_to
  (:long i n)
  ()
  intequalto
  :doc #{The $SOME_INTEGER_EQUAL_TO  -or @code{some_integer_=} matcher with input number $N matches
an integer $I if $I is or equal to $N.}#
  ;; test expansion
  #{ /*$INTEQUALTO ?*/ ($I == $N) }#
  ;; no fill expansion
)

;;; match an integer i greater or equal to a given number n
(defcmatcher some_integer_greater_or_equal_to
  (:long i n)
  ()
  intgreatorequal
  :doc #{The $SOME_INTEGER_GREATER_OR_EQUAL_TO matcher or @code{some_integer_>=} with input number $N matches
an integer $I if $I is greater or equal to $N.}#
  ;; test expansion
  #{ /*$INTGREATOREQUAL ?*/ ($I >= $N) }#
  ;; no fill expansion
)

;;; match an integer i greater than a given number n
(defcmatcher some_integer_greater_than
  (:long i n)
  ()
  intgreathan
  :doc #{The $SOME_INTEGER_GREATER_THAN matcher  or @code{some_integer_>} with input number $N matches
an integer $I if $I is greater than $N.}#
  ;; test expansion
  #{ /*$INTGREATHAN ?*/ ($I > $N) }#
  ;; no fill expansion
)

;;; match an integer i lower or equal to a given number n
(defcmatcher some_integer_lower_or_equal_to
  (:long i n)
  ()
  intloworequal
  :doc #{The $SOME_INTEGER_LOWER_OR_EQUAL_TO or @code{some_integer_<=} matcher with input number $N matches
an integer $I if $I is lower or equal to $N.}#
  ;; test expansion
  #{ /*$INTLOWOREQUAL ?*/ ($I <= $N) }#
  ;; no fill expansion
)

;;; match an integer i lower than a given number n
(defcmatcher some_integer_lower_than
  (:long i n)
  ()
  intlowthan
  :doc #{The $SOME_INTEGER_LOWER_THAN  or @code{some_integer_<} matcher with input number $N matches
an integer $I if $I is lower than $N.}#
  ;; test expansion
  #{ /*$INTLOWTHAN ?*/ ($I < $N) }#
  ;; no fill expansion
)

;;; match a boxed string, and set strval component
(defcmatcher some_string_value 
  (:value v)
  (:value sv)
  somestrval
  :doc #{The $SOME_STRING_VALUE matches a string value $V and passes it to the output $SV.}#
  ;; test
  #{ /*some_string_value $SOMESTRVAL? */ (($V) && melt_magic_discr((melt_ptr_t)($V)) == MELTOBMAG_STRING) }#
  ;; fill
  #{ /*some_string_value $SOMESTRVAL! */ $SV = $V; }#
)
;;;;;;;;;;;;;;;;

;;; match a boxed string containing some given cstring
(defcmatcher some_string_value_containing
  (:value v :cstring s)
  ()
  somestrcont
  :doc #{The $SOME_STRING_VALUE_CONTAINING matched a string value $V
  containing the constant substring $S}#
  ;; test
  #{ /* some_string_value_containing $SOMESTRCONT ? */
(($V) && ($S != NULL) && melt_magic_discr((melt_ptr_t)($V)) == MELTOBMAG_STRING
 && strstr(melt_string_str ((melt_ptr_t)($V)), ($S)))
  }#
  ;; no fill
)

(defprimitive outnewline_err () :void
  :doc #{Output on stderr a newline and flush.}#
  "melt_newlineflush(stderr)")

(defprimitive outstr_err (str) :void
  :doc #{Output on stderr a MELT string.}#
  #{melt_putstr(stderr, (melt_ptr_t)($str))}#)


(defprimitive message_dbg (:cstring msg) :void :doc #{Debug message $msg}#
  #{debugeputs(($msg))}#)
(defprimitive messagenum_dbg (:cstring msg :long i) :void 
  :doc #{Debug output with message $msg number $i}#
  #{debugnum(($msg), ($i))}#)


(defprimitive longbacktrace_dbg (:cstring msg :long maxdepth) :void
  :doc #{Detailed debug backtrace with message $MSG up to $MAXDEPTH.}#
  #{debugbacktrace(($MSG), (int)($MAXDEPTH))}#)


(defprimitive checkval_dbg (val :cstring msg) :void
  :doc #{Low-level costly check of value $VAL with message $MSG. Mostly useful for gurus.}#
  #{/*checkval_dbg*/ {if ($VAL) 
       melt_checked_assignmsg ((melt_ptr_t) ($VAL), ($MSG));
     else (void)$MSG;}}#)

(defprimitive debugcstring (:cstring msg str) :void
  :doc #{Debug cstring $MSG $STR.}#
  #{debugeprintf("debugcstring %s '%s'", $msg, $str)}#)

(defprimitive debuglong (:cstring msg :long num) :void
  :doc #{Debug long stuff with $MSG and number $NUM.}#
  #{debugeprintf("debuglong %s %ld", $msg, $num)}#)

;;;;;; STRBUF primitives
;; primitive to make a strbuf
(defprimitive make_strbuf (discr) :value
  :doc #{Make a new stringbuffer value of given $DISCR - or null if bad $DISCR.}#
  #{(melt_ptr_t) meltgc_new_strbuf((meltobject_ptr_t)($DISCR), (const char*)0)}#)

;; reserve space for optimization purposes
(defprimitive strbuf_reserve (sbuf :long siz) :void
  :doc #{Reserve extra space in stringbuffer $SBUF for $SIZ bytes.}#
  #{ if ($SIZ > 0) meltgc_strbuf_reserve ((melt_ptr_t)$SBUF, (unsigned)$SIZ); }#
)

(defprimitive strbuf_usedlength (sbuf) :long
  :doc #{Give the used length of given $SBUF string buffer or else 0.}#
  #{melt_strbuf_usedlength((melt_ptr_t)($SBUF))}#)

(defprimitive strbuf_peek (sbuf :long off) :long
  :doc #{Peek without consuming it in stringbuffer $SBUF the character at offset $OFF or else -1}#
  #{/*strbuf_peek*/ melt_strbuf_peek ((melt_ptr_t)($SBUF), (int)($OFF)) }#)

(defprimitive strbuf_consume  (sbuf :long count) :void
:doc #{Consume in stringbuffer $SBUF uto to $COUNT bytes.}#
#{/*strbuf_consume*/ melt_strbuf_consume((melt_ptr_t)($SBUF), (int)($COUNT))}#)

(defprimitive output_length (out) :long
  :doc #{Return the length of a given output $OUT (i.e. the used length if it is a string buffer, the file position if it is a file) or else 0.}#
  #{melt_output_length ((melt_ptr_t)$OUT)}#)

(defprimitive is_strbuf (v) :long
  :doc #{Test if value $V is a stringbuffer.}# 
  #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_STRBUF)}#)

;;; make a string
(defprimitive make_string (dis str) :value
  :doc #{Make a new string of discriminant $DIS from string value $STR.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($DIS), 
			  melt_string_str((melt_ptr_t)($STR))))}#)

(defprimitive is_stringconst (str :cstring cs) :long
  :doc #{Test that value string $STR is the raw string constant $CS.}#
  #{(melt_is_string_const((melt_ptr_t)($str), ($cs)))}#)

(defprimitive string_length (str) :long
  :doc #{Give the length of string value $STR.}#
  #{melt_string_length((melt_ptr_t)($str))}#)

(defprimitive string_nth (str :long rk) :long
  :doc #{Give the bytecode in string $STR of byte at rank $RK or else
  0. If $RK is negative, consider it as an offset from the end, so -1
  is the last byte.}#
  #{melt_string_nth((melt_ptr_t)($STR),(int)$RK)}#)

(defprimitive string_suffixed (sv :cstring cs) :long
  :doc #{Test that the string value $SV ends with the suffix $CS.}#
  #{/*string_suffixed:*/(melt_string_is_ending ((melt_ptr_t)$SV, $CS))}#)

(defprimitive string_dynloaded_suffixed (sv) :long
  :doc #{Test that the string value $SV ends with the MELT_DYNLOADED_SUFFIX.}#
  #{/*string_dynloaded_suffixed:*/ (melt_string_is_ending ((melt_ptr_t)$SV, 
							   MELT_DYNLOADED_SUFFIX))}#)


(defprimitive string_prefixed (sv :cstring cs) :long
  :doc #{Test that the string value $SV starts with the suffix $CS.}#
  #{(melt_string_is_starting ((melt_ptr_t)$SV, $CS))}#)

(defprimitive string_starts (sv1 sv2) :long
  :doc #{Test that the string value $SV1 starts with the string value $SV2.}#
  #{(melt_string_is_starting ((melt_ptr_t)$SV1, melt_string_str ((melt_ptr_t)$SV2)))}#)

(defprimitive string_ends (sv1 sv2) :long
  :doc #{Test that the string value $SV1 ends with the string value $SV2.}#
  #{(melt_string_is_ending ((melt_ptr_t)$SV1, melt_string_str ((melt_ptr_t)$SV2)))}#)

(defprimitive string_hex_md5sum_constpath (:cstring path) :value
  :doc #{Return a boxed string contained the hexadecimal md5sum of raw $PATH, or null.}#
  #{(meltgc_string_hex_md5sum_file($PATH))}#)

(defprimitive string_hex_md5sum_pathstrv (pathv) :value
  :doc #{Return a boxed string contained the hexadecimal md5sum of the string value  $PATHV, or null.}#
  #{(meltgc_string_hex_md5sum_file (melt_string_str((melt_ptr_t)$PATHV)))}#)

(defprimitive string_hex_md5sum_path_sequence (pathseq) :value
  :doc #{Return a boxed string contained the cumulated hexadecimal
  md5sum on paths inside tuple $PATHSEQ, or null.}#
  #{(meltgc_string_hex_md5sum_file_sequence ((melt_ptr_t) $PATHSEQ))}#)


(defprimitive split_string_space (dis s) :value
  :doc #{Split a string value $S into a list of space separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string (melt_string_str ((melt_ptr_t) $S), ' ', (melt_ptr_t) $DIS)}#)

(defprimitive split_string_comma (dis s) :value
  :doc #{Split a string value $S into a list of comma separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string (melt_string_str ((melt_ptr_t) $S), ',', (melt_ptr_t) $DIS)}#)

(defprimitive split_string_colon (dis s) :value
  :doc #{Split a string value $S into a list of colon separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string (melt_string_str ((melt_ptr_t) $S), ':', (melt_ptr_t) $DIS)}#)

(defprimitive split_string_equal (dis s) :value
  :doc #{Split a string value $S into a list of equal separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string (melt_string_str ((melt_ptr_t) $S), '=', (melt_ptr_t) $DIS)}#)


;; iterate on a string
(defciterator foreach_in_string 
  (:value vstr)
  eachstr
  (:long curch ix)
  :doc #{The $FOREACH_IN_STRING c-iterator iterates on the given string
  value $VSTR. $CURCH is the current char, and $IX its index, starting
  from 0.  Don't change $VSTR in the body!}#
  ;; before expansion
  #{ /* foreach_in_string $EACHSTR start */ int $EACHSTR#_len 
         =  melt_string_length ((melt_ptr_t) $VSTR);
     for ($IX = 0L; 
	  $IX >= 0 && $IX < (long) $EACHSTR#_len;
	  $IX++) {
          $CURCH = 0;
	  { const char* $EACHSTR#_str = melt_string_str ((melt_ptr_t) $VSTR);
	    if (!$EACHSTR#_str) break;
	    $CURCH = (long) ($EACHSTR#_str[$IX]);
	  }
          if (!$CURCH) break;
 }#
 ;; after expansion
 #{ $CURCH = 0L; } /* foreach_in_string $EACHSTR end */ 
 }#
)

;;; convert a strbuf into a string
(defprimitive strbuf2string (dis sbuf) :value
  :doc #{make a string value of discriminant $DIS from the stringbuffer $SBUF.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($DIS), melt_strbuf_str((melt_ptr_t)($SBUF))))}#)

;;; compute the naked basename
(defprimitive make_string_nakedbasename (dis str) :value
  :doc #{make a string value of discriminant $DIS from the naked basename from file path $STR.}#
  #{(meltgc_new_string_nakedbasename((meltobject_ptr_t)($DIS), 
				     melt_string_str((melt_ptr_t)($STR))))}#)

;;; compute the naked temporary path for a basename with a suffix
(defprimitive make_string_tempname_suffixed (dis str :cstring suff) :value
  :doc #{make a naked temporary path of discriminant $DIS for a
  basename $STR with suffix $SUFF.}#
  #{(meltgc_new_string_tempname_suffixed((meltobject_ptr_t)($DIS),
					 melt_string_str((melt_ptr_t)($STR)),
					 ($SUFF)))}#)


;; remove a suffix from a string or else copy it
(defprimitive make_string_without_suffix (dis str :cstring suffix) :value
  :doc #{Make a fresh copy with discriminant $DIS of string $STR 
removing the given $SUFFIX if it ends with it, or else a copy of $STR.}#
  #{/*make_string_without_suffix*/
  (meltgc_new_string_without_suffix ((meltobject_ptr_t)($DIS),
				     melt_string_str ((melt_ptr_t)($STR)),
				     ($SUFFIX))) }#
)

;; remove the MELT_DYNLOADED_SUFFIX from a string or else copy it
(defprimitive make_string_without_dynloaded_suffix (dis str) :value
  :doc #{Make a fresh copy with discriminant $DIS of string $STR 
removing the MELT_DYNLOADED_SUFFIX if it ends with it, or else a copy of $STR.}#
  #{/*make_string_without_dynloaded_suffix*/
  (meltgc_new_string_without_suffix ((meltobject_ptr_t)($DIS),
				     melt_string_str ((melt_ptr_t)($STR)),
				     MELT_DYNLOADED_SUFFIX))}#
)

;; compute a generated C++ source file
(defprimitive make_string_generated_cc_filename (dis basestr dirstr) :value
  :doc #{make a generated C++ file path of discriminant $DIS with base $BASESTR and directory $DIRSTR adding a .c suffix.}#
  #{(meltgc_new_string_generated_cc_filename((meltobject_ptr_t)($DIS),
					    melt_string_str ((melt_ptr_t)($BASESTR)),
					    melt_string_str ((melt_ptr_t)($DIRSTR)),
					    0))}#)


;; real path string, if accessible
(defprimitive make_string_real_access_path (dis :cstring filepath) :value
  :doc #{Make a string value of discriminant $DIS for the canonical real file
  path of $FILEPATH if it is accessible, or else NULL.}# 
 #{/*make_string_real_access_path*/ (meltgc_new_real_accessible_path_string 
				     ((meltobject_ptr_t) $DIS, 
				      $FILEPATH))}#)

;; likewise, for a string value filepathv
(defprimitive make_string_real_access_path_value (dis filev) :value
  :doc #{Make a string value of discriminant $DIS for the canonical real file
  path of string value $FILEV if it is accessible, or else NULL.}#
  #{/*make_string_real_access_path_value*/ (meltgc_new_real_accessible_path_string 
					    ((meltobject_ptr_t) $DIS,
					     melt_string_str ($FILEV)))}#)


;; generate a loadable module from a MELT generated C source file; the
;;  out is the dynloaded module without any MELT_DYNLOADED_SUFFIX. 
(defprimitive generate_flavored_melt_module (src outnam flavor) :void
  :doc #{Generate and load a module of given $FLAVOR whose source is named after $SRC 
and whose binary is named after $OUTNAM without any MELT_DYNLOADED_SUFFIX.}#
  #{ /*generate_flavored_melt_module*/ melt_compile_source (melt_string_str ((melt_ptr_t)$SRC),
			 melt_string_str ((melt_ptr_t)$OUTNAM),
			 NULL,
			 melt_string_str ((melt_ptr_t)$FLAVOR)); /*generate_flavored_melt_module*/
  }#)



;; primitive to load and initialize a module with a flavor in a given environement 
(defprimitive start_melt_module_of_flavor (env modname flavor) :value
  :doc #{start in environment $ENV  and load module of basename $MODNAME and $FLAVOR. Gives the new environment.}#
  #{meltgc_start_flavored_module ((melt_ptr_t)$ENV,
				  melt_string_str ((melt_ptr_t) $MODNAME),
				  melt_string_str ((melt_ptr_t) $FLAVOR));
  }#)


;;;;;;;;;;;;;;;; the melt version string
(defprimitive melt_version_str () :cstring
  :doc #{Gives the MELT version string.}#
  #{(melt_version_str())}#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; OBJECT primitives
;; primitive to get an object length
(defprimitive object_length (ob) :long 
  :doc #{Gives the length of object $OB.}#
  #{((long)melt_object_length((melt_ptr_t)($ob)))}#)
;; primitive to get the nth field of an object
(defprimitive object_nth_field (ob :long n) :value
  :doc #{Safely retrieve from object $OB its $N-th field or else null.}#
  #{(melt_field_object((melt_ptr_t)($ob), ($n)))}#)

(defprimitive subclass_of (cl1 cl2) :long
  :doc #{Safely test if class $CL1 is a sub-class of class $CL2.}#
  #{melt_is_subclass_of((meltobject_ptr_t)($cl1), (meltobject_ptr_t)($cl2))}#)
(defprimitive subclass_or_eq (cl1 cl2) :long
  :doc #{Safely test if class $CL1 is the same or a sub-class of class $CL2.}#
  #{(($cl1 == $cl2) || melt_is_subclass_of((meltobject_ptr_t)($cl1), (meltobject_ptr_t)($cl2)))}#)

(defprimitive is_multiple_or_null (mul) :long
  :doc #{Safely test if $MUL is a tuple or null.}#
  #{(($mul) == NULL || (melt_unsafe_magic_discr((melt_ptr_t)($mul)) == MELTOBMAG_MULTIPLE))}#)
;; primitive to build the subsequence of a multiple
(defprimitive subseq_multiple (mul :long startix endix) :value
  :doc #{Make a tuple from as subsequence of $MUL from indexes $STARTIX to $ENDIX.}#
 #{ meltgc_new_subseq_multiple((melt_ptr_t)($mul),
				  (int)($startix), (int)($endix)) }#)

;; is_multiple, make_multiple, multiple_nth, multiple_put_nth are in
;; warmelt-first

;; cmatcher for the tuple nth argument
(defcmatcher tuple_nth 
  (matchedtup :long matchedrk)				;match & ins
  (outcomp)				;out
  tupnth				;statesymb
  :doc #{The $TUPLE_NTH matcher with input number $MATCHEDRK matches a
tuple of length greater than $MATCHEDRK and retrieve the component
of that index, and matches it against the sub-pattern.}#
  ;;test expansion
   #{/*$TUPNTH ?*/ (melt_is_multiple_at_least(((melt_ptr_t)$matchedtup), 1+ (int)($matchedrk)))}#
   ;;fill expansion
  #{/*$TUPNTH !*/ $outcomp = melt_multiple_nth((melt_ptr_t)($matchedtup),(int)($matchedrk));
   }#
  ;; no operator expansion 
)


;; cmatcher for a tuple of a given exact size
(defcmatcher tuple_sized
  (tup :long ln)			;match & ins
  () 					;outs
  tupsiz				;statesymb
  :doc #{Match a tuple of given exact size.}#
  ;;test expansion
   #{(melt_is_multiple_of_length((melt_ptr_t)($tup), (int) ($ln)))}#
  ;; no fill expansion
  ;; no operator expansion
)


;; public comparator for named instances
(defun compare_named_alpha (n1 n2)
  :doc #{Alphanumerical compare of named instances $N1 and $N2. 
Returns a boxed integer.}#
  (cond 
   ( (== n1 n2) 
     (return '0 ()))
   ( (is_not_a n1 class_named) 
     (return '1 ()))
   ( (is_not_a n2 class_named)
     (return '-1 ()))
   (:else
    (let ( (sn1 (unsafe_get_field :named_name n1))
	   (sn2 (unsafe_get_field :named_name n2)) )
      (cond
       ( (string< sn1 sn2) 
	 (return '-1 ()))
       ( (string> sn1 sn2)
	 (return '1 ()))
       (:else
	(return '0 ())))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; test if MELT is bootstrapping
(defprimitive melt_is_bootstrapping () :long
  :doc #{Test if MELT is bootstrapping. Only for MELT implementation gurus.}#
  #{(melt_flag_bootstrapping)}#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; actually all the sbuf routines now take an outbuf argument, which can be either a string buffer of a file
(defprimitive is_out (v) :long
  :doc #{Test if value $V is a output value (a stringbuffer or a file).}# 
  #{ (melt_is_out ((melt_ptr_t) $v)) }#)

(defprimitive is_file (v) :long
  :doc #{Test if value $V is a file.}#
  #{ (melt_is_file ((melt_ptr_t) $V)) }#)

;; primitive to add a string const into a strbuf
(defprimitive add2sbuf_strconst (sbuf :cstring str) :void 
  :doc #{Add into stringbuffer $SBUF the constant string $STR.}#
  #{/*add2sbuf_strconst*/ meltgc_add_strbuf((melt_ptr_t)($SBUF), ($STR))}#)

;; primitive to add the MELT_DYNLOADED_SUFFIX into a strbuf
(defprimitive add2sbuf_dynloaded_suffix (sbuf) :void
  :doc #{Add into stringbuffer $SBUF the MELT_DYNLOADED_SUFFIX constant string.}#
  #{/*add2sbuf_dynloaded_suffix: */ meltgc_add_strbuf((melt_ptr_t)($SBUF), 
						      MELT_DYNLOADED_SUFFIX)}#)

;; primitive to add a string value into a strbuf
(defprimitive add2sbuf_string (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the string value $STR.}#
  #{/*add2sbuf_string*/ meltgc_add_strbuf((melt_ptr_t)($SBUF), 
                      melt_string_str((melt_ptr_t)($STR)))}#)
;; primitive to add the location info of a mixedloc into a strbuf we
;; copy the location file name into a buffer, to avoid crashing if a
;; GC is called...
(defprimitive add2sbuf_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL.}#
  #{/*add2sbufmixloc*/ if (melt_magic_discr((melt_ptr_t)($MIXL)) == MELTOBMAG_MIXLOC) {
    char smallcbuf[128];
    location_t loc = melt_location_mixloc ((melt_ptr_t)$MIXL);
    memset (smallcbuf, 0, sizeof(smallcbuf));
    snprintf (smallcbuf, sizeof (smallcbuf)-1, 
			"{%.120s:%d:%d}",
			LOCATION_FILE (loc), LOCATION_LINE (loc), LOCATION_COLUMN (loc));
    meltgc_add_strbuf_raw((melt_ptr_t)($SBUF), smallcbuf);
 } /*end add2sbufmixloc*/  }#)
;; primitive to add the short location info of a mixedloc into a strbuf
(defprimitive add2sbuf_short_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL in short form.}#
  #{/*add2sbufshortmixloc*/  if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  location_t loc = melt_location_mixloc((melt_ptr_t)$mixl);
  meltgc_strbuf_printf((melt_ptr_t)($sbuf), "{%s:%d:%d}", 
		       lbasename(LOCATION_FILE (loc)), 
		       LOCATION_LINE (loc), LOCATION_COLUMN (loc));
  } /*end add2sbufshortmixloc*/}#)
;; primitive to add the texi location info of a mixedloc into a strbuf
(defprimitive add2sbuf_texi_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL in texinfo form.}#
  #{/*add2sbufteximixloc*/ if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  location_t loc = melt_location_mixloc((melt_ptr_t)$mixl);
  meltgc_strbuf_printf((melt_ptr_t)($sbuf), "file @file{%s}, line %d", 
		       lbasename (LOCATION_FILE (loc)), 
		       LOCATION_LINE (loc)); 
  } /*end add2sbufteximixloc*/}#)

;; primitive to add an indentation or space into a strbuf
(defprimitive add2sbuf_indent (sbuf :long depth) :void
  :doc #{Add into stringbuffer $SBUF an indentation of given $DEPTH or a space.}#
  #{meltgc_strbuf_add_indent((melt_ptr_t)($sbuf), ($depth), 64)}#)


;; primitive to add an indented newline into a strbuf
(defprimitive add2sbuf_indentnl (sbuf :long depth) :void
  :doc #{Add into stringbuffer $SBUF an indented newline of given $DEPTH.}#
  #{meltgc_strbuf_add_indent((melt_ptr_t)($sbuf), ($depth), 0)}#)


;; primitive to add a strbuf into a strbuf
(defprimitive add2sbuf_sbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF.}#
  #{/*add2sbuf_sbuf*/ meltgc_add_strbuf((melt_ptr_t)($SBUF), 
					melt_strbuf_str((melt_ptr_t)$ASBUF))}#)


;; primitive to add a string value, C encoded, into a strbuf
(defprimitive add2sbuf_cencstring (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the content of string $STR with C encoding.}#
  #{meltgc_add_strbuf_cstr ((melt_ptr_t)($SBUF), 
                            melt_string_str ((melt_ptr_t)($STR)))}#)

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_cencstrbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF with C encoding.}#
  #{meltgc_add_strbuf_cstr ((melt_ptr_t)($SBUF), melt_strbuf_str((melt_ptr_t)($ASBUF)))}#)


;; primitive to add a string value, Ccomment encoded, into a strbuf
(defprimitive add2sbuf_ccomstring (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the content of string $STR with C-comment encoding, i.e. avoiding */.}#
  #{meltgc_add_strbuf_ccomment((melt_ptr_t)($SBUF), 
                               melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_ccomstrbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF with C-comment encoding, i.e. avoiding */.}#
  #{meltgc_add_strbuf_ccomment((melt_ptr_t)($SBUF), 
			       melt_strbuf_str((melt_ptr_t)($ASBUF)))}#)

;; primitive to add a cstring const, Ccomment encoded, into a strbuf
(defprimitive add2sbuf_ccomconst (sbuf :cstring cstr) :void 
  :doc #{Add into stringbuffer $SBUF the constant string $CSTR with
 C-comment encoding so no */.}# 
 #{/*add2sbuf_ccomconst*/ meltgc_add_strbuf_ccomment((melt_ptr_t) ($SBUF), $CSTR)}#)

;; primitive to add into a strbuf a string as C ident (nonalphanum
;; replaced by _)
(defprimitive add2sbuf_cident (sbuf str) :void
  :doc #{Add into stringbuffer $SBUF the string $STR as a C identifier
  so nonalphanum replaced by _.}#
  #{meltgc_add_strbuf_cident((melt_ptr_t)($SBUF),
  melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add into a strbuf the prefix of a string as C ident (nonalphanum
;; replaced by _) limited by a small length 
(defprimitive add2sbuf_cidentprefix  (sbuf str :long preflen) :void
  :doc #{Add into stringbuffer $SBUF the prefix string $STR as a C identifier
  so nonalphanum replaced by _ limited by $PREFLEN.}#
  #{meltgc_add_strbuf_cidentprefix((melt_ptr_t)($SBUF), 
                                   melt_string_str((melt_ptr_t)($STR)), ($PREFLEN))}#)

;; primitive to add a long in decimal into a strbuf
(defprimitive add2sbuf_longdec (sbuf :long num) :void
  :doc #{Add into stringbuffer $SBUF the number $NUM in decimal.}#
  #{meltgc_add_strbuf_dec((melt_ptr_t)($sbuf), ($num))}#)

;; primitive to add a long in hex into a strbuf
(defprimitive add2sbuf_longhex (sbuf :long num) :void
  :doc #{Add into stringbuffer $SBUF the number $NUM in hexa.}#
  #{meltgc_add_strbuf_hex((melt_ptr_t)($sbuf), ($num))}#)

;; primitive to add a routine descr into a strbuf
(defprimitive add2sbuf_routinedescr (sbuf rout) :void
  :doc #{Add into stringbuffer $SBUF the routine descriptor $ROUT.}#
  #{meltgc_add_strbuf((melt_ptr_t)($sbuf), melt_routine_descrstr((melt_ptr_t)($rout)))}#)

;;;;;;;;;;;;;;;;
;;; primitive to output a strbuf into a file named by a cstring
(defprimitive output_sbuf_strconst (sbuf :cstring nam) :void
  :doc #{Output into file named $NAM the content of strinbuffer $SBUF.}#
#{ /*output_sbuf_strconst*/ melt_output_strbuf_to_file((melt_ptr_t) ($SBUF), ($nam)) }#)
;;; primitive to output a strbuf into a file named by a stringval
(defprimitive output_sbuf_strval (sbuf vnam) :void
  :doc #{Output into file named by string value $VNAM the content of strinbuffer $SBUF.}#
#{ /*output_sbuf_strval*/ melt_output_strbuf_to_file((melt_ptr_t) ($SBUF), melt_string_str((melt_ptr_t) $VNAM)) }#)

;;; primitive to output a strbuf into a file named by a cstring
(defprimitive output_sbuf_no_overwrite_strconst (sbuf :cstring nam) :void
  :doc #{Output into file named $NAM the content of strinbuffer $SBUF, take care to not overwrite an file named $VNAM if it was the same.}#
#{ /*output_sbuf_no_overwrite_strconst*/ melt_output_strbuf_to_file_no_overwrite((melt_ptr_t)($SBUF), ($NAM)) }#)
;;; primitive to output a strbuf into a file named by a stringval
(defprimitive output_sbuf_no_overwrite_strval (sbuf vnam) :void
  :doc #{Output into file named by string value $VNAM the content of 
strinbuffer $SBUF, take care to not overwrite an old file named $VNAM if it was the same.}#
#{ /*output_sbuf_no_overwrite_strval*/ melt_output_strbuf_to_file_no_overwrite((melt_ptr_t)($SBUF), 
					   melt_string_str((melt_ptr_t) $VNAM)) }#)


;;;;;;;;;;;;;;;; variant for outbuf

;; primitive to add a string const into a outbuf
(defprimitive add2out_strconst (out :cstring str) :void 
  :doc #{Add to output $OUT the cstring $STR.}#
  #{meltgc_add_out((melt_ptr_t)($out), ($str))}#)
;; primitive to add a string value into a outbuf
(defprimitive add2out_string (out str) :void 
  :doc #{Add to output $OUT the string value $STR.}#
  #{meltgc_add_out((melt_ptr_t)($OUT), melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add the location info of a mixedloc into a outbuf
(defprimitive add2out_mixloc (out mixl) :void
  :doc #{Add to output $OUT the mixed location $MIXL.}#
  #{/*add2outmixloc*/ if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  char locbuf[256];
  location_t tloc = melt_location_mixloc((melt_ptr_t)$MIXL);
  memset (locbuf, 0, sizeof(locbuf));
  snprintf (locbuf, sizeof(locbuf)-1,
		    "{%.200s:%d}",
		    LOCATION_FILE (tloc),
		    LOCATION_LINE (tloc));
   meltgc_add_out_raw ((melt_ptr_t) $OUT, locbuf);
  } /*end add2outmixloc*/
}#)

;; primitive to add an indentation or space into a outbuf
(defprimitive add2out_indent (out :long depth) :void
  :doc #{Add to output $OUT the indentation $DEPTH or a space.}#
  #{meltgc_out_add_indent((melt_ptr_t)($OUT), ($depth), 64);}#
)


;; primitive to add an indented newline into a outbuf
(defprimitive add2out_indentnl (out :long depth) :void
  :doc #{Add to output $OUT the indented newline of given $DEPTH.}#
  #{meltgc_out_add_indent((melt_ptr_t)($OUT), ($depth), 0);}#
)


;; primitive to add a strbuf into a outbuf
(defprimitive add2out_sbuf (out asbuf) :void 
  :doc #{Add to output $OUT the stringbuffer $ASBUF.}#
  #{meltgc_add_out ((melt_ptr_t)($OUT), melt_strbuf_str ((melt_ptr_t) $ASBUF))}#)

;; primitive to add a string value, C encoded, into a outbuf
(defprimitive add2out_cencstring (out str) :void 
  :doc #{Add to output $OUT the C-encoded string value $STR.}#
  #{meltgc_add_out_cstr((melt_ptr_t)($OUT), 
			melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add a substring value, C encoded, into a outbuf
(defprimitive add2out_cencsubstring (out str :long off slen) :void 
  :doc #{Add to output $OUT the C-encoded substring value $STR at offset $OFF of length $SLEN.}#
  #{meltgc_add_out_csubstr_len((melt_ptr_t)($OUT),
			       melt_string_str((melt_ptr_t)($STR)),
			       ($OFF), ($SLEN))}#)

;; primitive to add a C encoded constant string to a strbuf
(defprimitive add2out_cenconst (sbuf :cstring cstr) :void
  :doc #{Add into stringbuffer $SBUF the C-encoded constant string $CSTR}#
  #{meltgc_add_strbuf_cstr ((melt_ptr_t)($SBUF), $CSTR)}#)
;; primitive to add a strbuf, C encoded, into a outbuf
(defprimitive add2out_cencstrbuf (out asbuf) :void 
  :doc #{Add to output $OUT the C-encoded stringbuffer $ASBUF.}#
  #{meltgc_add_out_cstr((melt_ptr_t)($out), melt_strbuf_str((melt_ptr_t)($ASBUF)))}#)

;; primitive to add a string value, Ccomment encoded, into a outbuf
(defprimitive add2out_ccomstring (out str) :void 
  :doc #{Add to output $OUT the C-comment encoded string value $STR.}#
  #{meltgc_add_out_ccomment((melt_ptr_t)($OUT), 
                            melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add a strbuf, C encoded, into a outbuf
(defprimitive add2out_ccomstrbuf (out asbuf) :void 
  :doc #{Add to $OUT the C-comment encoded stringbuffer $ASBUF.}#
  #{meltgc_add_out_ccomment((melt_ptr_t)($OUT), 
                            melt_strbuf_str((melt_ptr_t)($ASBUF)))}#)

;; primitive to add a cstring const, Ccomment encoded, into a outbuf
(defprimitive add2out_ccomconst (out :cstring cstr) :void 
  :doc #{Add to $OUT the constant C-comment encoded raw $CSTR.}#
  #{meltgc_add_out_ccomment(($out), $cstr)}#)

;; primitive to add into a outbuf a string as C ident (nonalphanum
;; replaced by _)
(defprimitive add2out_cident (out str) :void
  :doc #{Add to $OUT the MELT string $STR encocded as a C identifier, so
with every non-alnum character replaced with an underscore.}#
  #{meltgc_add_out_cident((melt_ptr_t)($OUT), 
			  melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add into a outbuf the prefix of a string as C ident (nonalphanum
;; replaced by _) limited by a small length 
(defprimitive add2out_cidentprefix  (out str :long preflen) :void
  :doc #{Add to $OUT the prefix of a string encoded as a C identifier,
limited by a small length $PREFLEN.}#
  #{meltgc_add_out_cidentprefix((melt_ptr_t)($out), 
				melt_string_str((melt_ptr_t)($STR)), 
				($preflen))}#)

;; primitive to add a long in decimal into a outbuf
(defprimitive add2out_longdec (out :long num) :void
  :doc #{Add to $OUT the number $NUM in decimal.}#
  #{meltgc_add_out_dec((melt_ptr_t)($out), ($num))}#)

;; primitive to add a long in hex into a outbuf
(defprimitive add2out_longhex (out :long num) :void
  :doc #{Add to $OUT the number $NUM in hex.}#
  #{meltgc_add_out_hex((melt_ptr_t)($out), ($num))}#)

;; primitive to add a routine descr into a outbuf
(defprimitive add2out_routinedescr (out rout) :void
  :doc #{Add to $OUT the routine desscriptor $ROUT.}#
  #{meltgc_add_out((melt_ptr_t)($out), 
		   melt_routine_descrstr((melt_ptr_t)($rout)))}#)


(defselector add_to_out class_selector
  :doc #{The selector $ADD_TO_OUT add the reciever $RECV into the
output $OUT. It is called by the $ADD2OUT variadic function.}#
  :formals (recv out)
)

(defun add2out (out :rest)
  :doc #{Variadic function to add to an output $OUT (a file, a string buffer) 
  various things. Return the given $OUT. Use $ADD_TO_OUT selector for values. 
  Closure values are handled as manipulators for next thing.}#
  (if (not (is_out out))
      (return))
  (forever 
   argloop
   (variadic 
    ( ()
      (exit argloop))
    ( (:value v)
      (if (is_closure v)
	  (variadic
	   ((:value vv)
	    (v out vv))
	   ((:long ll)
	    (v out ll))
	   ((:cstring ss)
	    (v out ss))
	   ((:tree tt)
	    (v out tt))
	   ((:gimple gg)
	    (v out gg))
	   ((:gimple_seq gs)
	    (v out gs))
	   ((:edge ee)
	    (v out ee))
	   ((:loop lo)
	    (v out lo))
	   (:else
	    (let ( (vcty (variadic_ctype 0))
		   )
	      (errormsg_strv "ADD2OUT with manipulator for unsupported ctype"
			     (get_field :named_name vcty))
	      (assert_msg "invalid variadic argument after closure to ADD2OUT" () vcty)
	      (return)
	      )))
	(add_to_out v out)))
    ( (:long n)
      (add2out_longdec out n))
    ( (:cstring s)
      (add2out_strconst out s))
    ( :else
      (let ( (vcty (variadic_ctype 0))
	     )
	(errormsg_strv "ADD2OUT for unsupported ctype; use a manipulator like OUTPUT_TREE "
		       (get_field :named_name vcty))
      (assert_msg "invalid variadic argument to ADD2OUT" () vcty)
      )
      )))
  (return out)
  )

;;;;;;;;;;;;;;;;
(defun string4out (dis :rest)
  :doc #{Variadic function to make a string for output, 
  using $DIS as the string discriminant and the rest for filling it. See also $ADD2OUT.}#
  (unless dis (setq dis discr_string))
  (unless (is_a dis class_discriminant)
    (return))
  (let ( (:long goodmag 0)
	 )
    (code_chunk getmagidischk #{/* string4out $GETMAGIDISCHK */ $GOODMAG = 
		((meltobject_ptr_t)$DIS)->meltobj_magic == MELTOBMAG_STRING ;}#
		)
    (unless goodmag (return)))
  (let ( (out (make_strbuf discr_strbuf))
	 )
    (forever 
     argloop
     (variadic 
      ( ()
	(exit argloop))
      ( (:value v)
	(if (is_closure v)
	    (variadic
	     ((:value vv)
	      (v out vv))
	     ((:long ll)
	      (v out ll))
	     ((:cstring ss)
	      (v out ss))
	     ((:tree tt)
	      (v out tt))
	     ((:gimple gg)
	      (v out gg))
	     ((:gimple_seq gs)
	      (v out gs))
	     ((:edge ee)
	      (v out ee))
	     ((:loop lo)
	      (v out lo))
	     (:else
	      (let ( (vcty (variadic_ctype 0))
		     )
		(errormsg_strv "STRING4OUT with manipulator for unsupported ctype"
			       (get_field :named_name vcty))
		(assert_msg "invalid variadic argument after closure to STRING4OUT" () vcty)
		(return)
		)))
	  (add_to_out v out)))
      ( (:long n)
	(add2out_longdec out n))
      ( (:cstring s)
	(add2out_strconst out s))
      ( :else
	(let ( (vcty (variadic_ctype 0))
	       )
	  (errormsg_strv "STRING4OUT for unsupported ctype; use a manipulator like OUTPUT_TREE "
			 (get_field :named_name vcty))
	  (assert_msg "invalid variadic argument to STRING4OUT" () vcty)
	)
	)))
    (let ( (str (strbuf2string dis out))
	   )
      (return str)
      )))

;;;;;;;;;;;;;;;

;; read add2out4null as "add to out for null"
(defun add2out4null (v out)
  (assert_msg "check null v" (null v) v)
  (add2out_strconst out "*nil*"))
(install_method discr_null_receiver add_to_out add2out4null)

(defun add2out4integer (vn out)
  (assert_msg "check boxed number vn" (is_integerbox vn) vn)
  (add2out_longdec out (get_int vn)))
(install_method discr_integer add_to_out add2out4integer)

(defun add2out4string (vs out)
  (assert_msg "check boxed string vs" (is_string vs) vs)
  (add2out_string out vs))
(install_method discr_string add_to_out add2out4string)

(defun add2out4strbuf (vsbuf out)
  (assert_msg "check strbuf vsbuf" (is_strbuf vsbuf) vsbuf)
  (add2out_sbuf out vsbuf))
(install_method discr_strbuf add_to_out add2out4strbuf)


(defselector output_as_json class_selector
  :doc #{The selector $OUTPUT_AS_JSON is outputting in JSON format the reciever $RECV on the output $OUT.
  See http://json.org for more about JSON.}#
  :formals (recv out))



(defun output_json (out v)
  :doc #{Output in JSON format to output channel $OUT the value $V}#
  (cond ( (is_integerbox v)
	  (add2out out (get_int v)))
	( (== v :true)
	  (add2out out "true")
	  )
	( (== v :json_false)
	  (add2out out "false")
	  )
	( (null v)
	  (add2out out "null")
	  )
	( (is_multiple v)
	  (add2out out "[")
	  (foreach_in_multiple
	   (v)
	   (curcomp :long ix)
	   (if ix (add2out out ","))
	   (output_json out curcomp))
	  (add2out out "]"))
	(:else
	 (output_as_json v out)))
  )


(defun add2out4clonedsymb (vc out)
  (match vc
	 (?(instance class_cloned_symbol
		     :named_name ?nvarnam
		     :csym_urank ?(integerbox_of ?nvarurank))
	   (assert_msg "check nvarnam" (is_string nvarnam) nvarnam)
	   (add2out_cident out nvarnam)
	   (add2out_strconst out "__")
	   (add2out_longdec out nvarurank))
	 (?_
	  (assert_msg "bad cloned symbol" () vc))))
(install_method class_cloned_symbol add_to_out add2out4clonedsymb)

(defun add2out4named (vn out)
  (add2out_cident out (get_field :named_name vn)))
(install_method class_named add_to_out add2out4named)

(defun add2out4rootobject (vo out)
  (add2out_strconst out "*")
  (add2out_string out (get_field :named_name (discrim vo)))
  (add2out_strconst out "/")
  (add2out_longhex out (obj_hash vo))
  (add2out_strconst out "."))
(install_method class_root add_to_out add2out4rootobject)

(defun add2out4any (va out)
  (add2out_strconst out "*")
  (add2out_string out (get_field :named_name (discrim va))))
(install_method discr_any_receiver add_to_out add2out4any)



;;; cmatcher for a cstring of a given content
(defcmatcher cstring_same 
  (:cstring str cstr)
  ()
  strsam
  :doc #{The $CSTRING_SAME c-matcher matches a string $STR and test if
  it equals to the constant string $CSTR. The match fails if $STR is a
  null string or different from $CSTR.}# 

#{/*$strsam test*/ ($STR && $CSTR && !strcmp($STR, $CSTR)) }#
  ;; no fill or operator
)
;; cmatcher for a cstring starting with a given prefix
(defcmatcher cstring_prefixed 
  (:cstring str cstr)
  ()
  strprefixed
  :doc #{The $CSTRING_PREFIX c-matcher matches a string $STR and test if
  it starts with the constant string $CSTR. The match fails if $STR is a
  null string or not prefixed by $CSTR.}# 

#{/* cstring_prefixed $STRPREFIXED test*/ ($STR && $CSTR && !strncmp($STR, $CSTR, strlen ($CSTR))) }#
  ;; no fill or operator
)

;; cmatcher for a cstring starting with a given prefix
(defcmatcher cstring_containing 
  (:cstring str cstr)
  ()
  strcontain
  :doc #{The $CSTRING_CONTAINING c-matcher matches a string $STR and test if
  it contains the constant string $CSTR. The match fails if $STR is a
  null string or not prefixed by $CSTR.}# 

#{/* cstring_containing $STRCONTAIN test*/ ($STR && $CSTR && strstr($STR, $CSTR)) }#
  ;; no fill or operator
)


;;; comatcher for a hook with some data
(defcmatcher some_hook_with_data
  (:value hookv)					;no match
  (:value hkdata)
  somehook
  :doc #{The $SOME_HOOK_WITH_DATA matcher matches a hook value, 
and extracts its data in $HKDATA}#
  ;; test expansion
  #{ /* some_hook_with_data $SOMEHOOK ? */ (($HOOKV) 
    && melt_magic_discr ((melt_ptr_t)($HOOKV)) == MELTOBMAG_HOOK) }#
  ;; fill expansion
  #{ /* some_hook_with_data $SOMEHOOK ! */
     $HKDATA = melt_hook_data ((melt_ptr_t) ($HOOKV)); 
  }#
  ;; no operator
  )

;; primitive to compute the length of a cstring
(defprimitive cstring_length
  (:cstring cstr) :long
  :doc #{Compute safely the length a C-string $cstr. Gives 0 if null argument. }#
  #{(($cstr)?strlen($cstr):0)}#)

;;;;;;;;;;;;;;;;



;;; iterate fully in a map of strings
(defun mapstring_every (map f)
  :doc #{For a given hash-map of strings $MAP and a function $F,
apply $F to every attribute object and [perhaps allocated] string value. Returns
nil.}#
  (if (is_mapstring map)
      (if (is_closure f)
	  (foreach_in_mapstring
	   (map)
	   (curat curval)
	   (f curat curval)))))

;;; iterate & test over a map of strings - if the called f returns nil the
;;; iteration is stopped
(defun mapstring_iterate_test (map f)
  :doc #{For a given hash-map of strings $MAP and a function $F, apply
$F to every attribute object and string value. If it returns a null
value, with an other secundary value, gives the failing attribute, its
value, and the other.}#
  (if (is_mapstring map)
      (if (is_closure f)
	  (foreach_in_mapstring
	   (map)
	   (curat curval)
	   (multicall 
	    (test other)
	    (f curat curval)
	    (if (null test)
		(return curat curval other)
	   ))))))


;;;;;; MAPSTRINGs primitive

;; primitive to get the allocated size of a mapstring
(defprimitive mapstring_size (map) :long 
  :doc #{Safely return the current allocated size of a string-map $MAP or else 0.}#
  #{(melt_size_mapstrings((struct meltmapstrings_st*)($map)))}#)

;; primitive to get the attribute count of a mapstring
(defprimitive mapstring_count (map) :long
  :doc #{Safely return the current count of a string-map $MAP or else 0.}#
  #{(melt_count_mapstrings((struct meltmapstrings_st*)($map)))}#)


;; get an entry in a mapstring from a C string
(defprimitive mapstring_rawget (map :cstring cstr) :value
  :doc #{Safely get in a string-map $MAP the value associated with raw c-string $CSTR or else null.}#
  #{(melt_get_mapstrings((struct meltmapstrings_st*)($map), ($cstr)))}#)

;; primitive for putting into a map of strings
(defprimitive mapstring_rawput (map :cstring key :value val) :void
  :doc #{Safely put into a string-map $MAP the raw c-string $KEY associated to value $VAL.}#
  #{meltgc_put_mapstrings( (struct meltmapstrings_st *) ($map), ($key), (melt_ptr_t) ($val))}#)

;; primitives for removing from a map of strings
(defprimitive mapstring_rawremove (map :cstring key) :void
  :doc #{Safely remove from a string-map $MAP the value associated with raw c-string $KEY.}#
  #{meltgc_remove_mapstrings((struct meltmapstrings_st*) ($map), ($key))}#)


;;; full iterator on tuple - 
;;; the function is called with the component and its index
(defun multiple_every (tup f)
  :doc #{Apply to every component of tuple $TUP and its index the given
function $F. Return nil.}#
  (if (is_multiple tup)
      (if (is_closure f)
	  (foreach_in_multiple
	   (tup)
	   (comp :long ix)
	   (f comp ix)))))

;; full iterator backward
(defun multiple_backward_every (tup f)
  :doc #{Apply to every component (from last to first) of tuple $TUP
backwards, and its index the given function $F. Return nil.}#
  (if (is_multiple tup)
      (if (is_closure f)
	  (foreach_in_multiple_backward
	   (tup)
	   (comp :long ix)
	   (f comp ix)))))


;; iterator on two tuples
(defun multiple_every_both (tup1 tup2 f)
  :doc #{Given two tuples $TUP1 and $TUP2, apply function $F to every component of $TUP1 
with component of $TUP2 and index. Stop when either end is reached. Return nil.}#
  (if (is_multiple tup1)
      (if (is_multiple tup2)
	  (if (is_closure f)
	      (let ( (:long ln1 (multiple_length tup1))
		     (:long ln2 (multiple_length tup2))
		     (:long ix 0) )
		(forever tuploop
			 (if (>=i ix ln1) (exit tuploop))
			 (if (>=i ix ln2) (exit tuploop))
			 (f (multiple_nth tup1 ix) (multiple_nth tup2 ix) ix)
			 (setq ix (+i ix 1))))))))


;;;; MELT application depth & counter significant only when checking is enabled
(defprimitive melt_application_depth () :long 
  :doc #{Depth of MELT closures application - significant iff ENABLE_CHECKING.}#
  #{melt_application_depth()}#)

(defprimitive melt_application_shallower (:long maxdepth) :long
  :doc #{Test that the MELT application depth is less that $MAXDEPTH -
significant iff ENABLE_CHECKING.}# #{(melt_application_depth() <
  $MAXDEPTH)}#)

(defprimitive melt_application_count () :long
  :doc #{Count of MELT closures application - significant iff ENABLE_CHECKING.}#
  #{melt_application_count()}#)

(definstance melt_mode_reference class_reference
  :doc #{$MELT_MODE_REFERENCE is a reference dedicated to share data at the mode level.}#)







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; the descriptions of values which are not ctype related.
(defclass class_value_descriptor
  :doc #{The $CLASS_VALUE_DESCRIPTOR describes MELT values which are
  not ctype renated. $VALDESC_OBJMAGIC is the symbol MELTOBMAG_* of
  its magic number. $VALDESC_STRUCT is the GTY-ed struct
  name. $VALDESC_UNIONMEM is the union member name inside union
  melt_un. $VALDESC_MEMBCHUNK is the code chunk of the structure
  members after the discriminant. $VALDESC_DECLCHUNK is the code chunk
  for declarations, e.g. macros, outside of the GTY-ed
  structure. $VALDESC_GTY is the optional GTY
  argument. $VALDESC_COPYCHUNK is the code chunk copying src to an
  allocated dst. $VALDESC_FORWCHUNK is the code chunk formarding
  internal pointers. $VALDESC_CLONECHUNK is the code chunk to clone
  src, default to structure copy if :TRUE, used in the
  $CLONE_WITH_DISCRIMINANT primitive.}#
  :super class_named
  :fields (
	   valdesc_objmagic
	   valdesc_struct
	   valdesc_unionmem
	   valdesc_gty
	   valdesc_membchunk
	   valdesc_declchunk
	   valdesc_copychunk
	   valdesc_forwchunk
	   valdesc_clonechunk
	   )
)

(defclass class_varisized_value_descriptor
  :doc #{The $CLASS_VARISIZED_VALUE_DESCRIPTOR describes variable
  sized MELT values.}#
  :super class_value_descriptor
  :fields (
	   ))

(export_class
 class_value_descriptor 
 class_varisized_value_descriptor)


(defun set_reference (r v)
  :doc #{Safely put in a reference $R instance of $CLASS_REFERENCE 
the field :REFERENCED_VALUE to $V. Obsolete function, use $SET_REF macro.}#
  (put_fields r :referenced_value v))


;;;;;;;;;;;;;;;;
(definstance value_descriptor_list_reference
  class_reference
  :referenced_value (make_list discr_list)
)

(defun install_value_descriptor (vd)
  (assert_msg "check vd" (is_a vd class_value_descriptor) vd)
  (list_append (get_field :referenced_value value_descriptor_list_reference) 
	       vd))

(defun retrieve_value_descriptor_list ()
  (get_field  :referenced_value value_descriptor_list_reference))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;; object value
(definstance valdesc_object class_varisized_value_descriptor
  :doc #{$VALDESC_OBJECT describes object values.}#
  :named_name '"VALDESC_OBJECT"
  :valdesc_objmagic '"MELTOBMAG_OBJECT"
  :valdesc_struct '"meltobject_st"
  :valdesc_unionmem '"u_object"
  :valdesc_membchunk #{$' /* from VALDESC_OBJECT in warmelt-base.melt */
  unsigned obj_hash;		/* hash code of the object */
  unsigned short obj_num;
  unsigned short obj_len;
  melt_ptr_t GTY ((length ("%h.obj_len"))) obj_vartab[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_OBJECT */
#define meltobj_class discr
#define meltobj_magic obj_num
#define MELT_OBJECT_STRUCT(N) {			\
  meltobject_ptr_t meltobj_class;		\
  unsigned obj_hash;				\
  unsigned short obj_num;			\
  unsigned short obj_len;			\
  melt_ptr_t* obj_vartab[N];			\
  long _gap; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_OBJECT */
  /* ggc_alloc_meltobject_st should be gengtype generated for VALDESC_OBJECT */
#ifndef ggc_alloc_meltobject_st
#define ggc_alloc_meltobject_st(SIZE) ((struct meltobject_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif 
    int ix = 0;
    int oblen = (int) (src->obj_len);
    size_t sz = 0;
    /* We don't need to clear at allocation, since the object is
       explicitly filled here! */
    sz = oblen*sizeof(void*)
       + offsetof(struct meltobject_st, obj_vartab);
    dst = ggc_alloc_meltobject_st (sz);
    melt_forwarded_copy_byte_count += sz;
    /* we cannot copy the whole src, because MELT_FLEXIBLE_DIM might be 1 */
    dst->meltobj_class = src->meltobj_class;
    dst->obj_hash = src->obj_hash;
    dst->obj_num = src->obj_num;
    dst->obj_len = oblen;
    for (ix = 0;
	 ix < oblen;
	 ix++)
        dst->obj_vartab[ix] = src->obj_vartab[ix];
#if ENABLE_CHECKING
 /* for low level debugging with gdb, we may want to catch some copy operations */
  if (melt_alptr_1 && (void*) src == melt_alptr_1)
  melt_break_alptr_1 ("copyobj src=alptr1");
  if (melt_alptr_2 && (void*) src == melt_alptr_2)
  melt_break_alptr_2 ("copyobj src=alptr2");
  if (src->obj_hash == melt_objhash_1)
  melt_break_objhash_1("copyobj src with objhash1");
  if (src->obj_hash == melt_objhash_2)
  melt_break_objhash_2("copyobj src with objhash2");
#endif /* ENABLE_CHECKING */
  }#
  :valdesc_clonechunk #{$' /* cloning, from VALDESC_OBJECT */
    unsigned newlen = 0;
    unsigned srclen = src->obj_len;
    unsigned slotix = 0;
    if (melt_is_subclass_of((meltobject_ptr_t)srcdiscrv, 
			    (meltobject_ptr_t)newdiscrv)) {
      newlen = 
        melt_multiple_length ((melt_ptr_t)
			      (((meltobject_ptr_t)newdiscrv)->obj_vartab[MELTFIELD_CLASS_FIELDS]));
      gcc_assert (newlen <= srclen);
      dst =  meltgc_new_raw_object ((meltobject_ptr_t)newdiscrv, newlen);
      for (slotix = 0;
	   slotix < newlen;
	   slotix++)
	dst->obj_vartab[slotix] = src->obj_vartab[slotix];
      dst->obj_num = src->obj_num;
    }
    else if (melt_is_subclass_of((meltobject_ptr_t)newdiscrv,
				 (meltobject_ptr_t)srcdiscrv)) {
      newlen = 
        melt_multiple_length ((melt_ptr_t)
			      (((meltobject_ptr_t)newdiscrv)->obj_vartab[MELTFIELD_CLASS_FIELDS]));      
      gcc_assert (newlen >= srclen);
      dst =  meltgc_new_raw_object ((meltobject_ptr_t)newdiscrv, newlen);
      for (slotix = 0;
	   slotix < srclen;
	   slotix++)
	dst->obj_vartab[slotix] = src->obj_vartab[slotix];
      dst->obj_num = src->obj_num;
    }
#if ENABLE_CHECKING
 /* for low level debugging with gdb, we may want to catch some clone operations */
  if (melt_alptr_1 && (void*) src == melt_alptr_1)
  melt_break_alptr_1 ("cloneobj src=alptr1");
  if (melt_alptr_2 && (void*) src == melt_alptr_2)
  melt_break_alptr_2 ("cloneobj src=alptr2");
  if (src->obj_hash == melt_objhash_1)
  melt_break_objhash_1("cloneobj src with objhash1");
  if (src->obj_hash == melt_objhash_2)
  melt_break_objhash_2("cloneobj src with objhash2");
#endif /* ENABLE_CHECKING */
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_OBJECT */
    int ix = 0;
    int oblen = (int) (src->obj_len);
    for (ix = 0; ix < oblen; ix++)
      MELT_FORWARDED (src->obj_vartab[ix]);
#if ENABLE_CHECKING
 /* for low level debugging with gdb, we may want to catch some forwarding operations */
  if (melt_alptr_1 && (void*) src == melt_alptr_1)
  melt_break_alptr_1 ("forwardobj src=alptr1");
  if (melt_alptr_2 && (void*) src == melt_alptr_2)
  melt_break_alptr_2 ("forwardobj src=alptr2");
  if (src->obj_hash == melt_objhash_1)
  melt_break_objhash_1("forwardobj src with objhash1");
  if (src->obj_hash == melt_objhash_2)
  melt_break_objhash_2("forwardobj src with objhash2");
#endif /* ENABLE_CHECKING */
  }#
)
(install_value_descriptor valdesc_object)



;;;;;;;;;;;;;;;; objects map values

(definstance valdesc_mapobjects class_value_descriptor
  :doc #{$VALDESC_MAPOBJECTS describes object-keyed map values.}#
  :named_name '"VALDESC_MAPOBJECTS"
  :valdesc_objmagic '"MELTOBMAG_MAPOBJECTS"
  :valdesc_struct '"meltmapobjects_st"
  :valdesc_unionmem '"u_mapobjects"
  :valdesc_membchunk #{$' /* from VALDESC_MAPOBJECTS in warmelt-base.melt */
  unsigned count;
  unsigned char lenix;
  melt_ptr_t meltmap_aux;
  struct entryobjectsmelt_st *GTY ((length ("melt_primtab[%h.lenix]")))
    entab;
  /* the following field is usually the value of entab (for
     objects in the young zone), to allocate the object and its fields
     at once; hence its GTY-ed length is zero */
  struct entryobjectsmelt_st GTY ((length ("0"))) map_space[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_MAPOBJECTS in warmelt-base.melt */
    typedef struct meltmapobjects_st* meltmapobjects_ptr_t;
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_MAPOBJECTS in warmelt-base.melt */
/* ggc_alloc_meltmapobjects_st should be gengtype generated for VALDESC_MAPOBJECTS */
#ifndef ggc_alloc_meltmapobjects_st
#define ggc_alloc_meltmapobjects_st() ((struct meltmapobjects_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapobjects_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entryobjectsmelt_st
#define ggc_alloc_vec_entryobjectsmelt_st(N) ((struct entryobjectsmelt_st *) (ggc_internal_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), N MEM_STAT_INFO)))
#endif
#ifndef  ggc_alloc_cleared_vec_entryobjectsmelt_st
#define ggc_alloc_cleared_vec_entryobjectsmelt_st(n) ((struct entryobjectsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), n MEM_STAT_INFO)))
#endif
     int siz = melt_primtab[src->lenix];
     size_t sz = 0;
     dst = 
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapobjects_st ();
     dst->discr = src->discr;
     dst->count = src->count;
     dst->lenix = src->lenix;
     dst->meltmap_aux = src->meltmap_aux;
     sz = sizeof(*dst);
     if (siz > 0 && src->entab)
       {
       /* Don't need a cleared allocation.  */
         dst->entab = ggc_alloc_vec_entryobjectsmelt_st (siz);
         memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	 sz += siz * sizeof(dst->entab[0]);
       }
     else
       dst->entab = NULL;
     melt_forwarded_copy_byte_count += sz;
  }#
  :valdesc_clonechunk #{$' /* cloning, from VALDESC_MAPOBJECTS */
     unsigned srccount = src->count;
     unsigned srclen = melt_primtab[src->lenix];
     unsigned newlen = 4*srccount/3+4;
     dst = (struct meltmapobjects_st*) 
         meltgc_new_mapobjects ((meltobject_ptr_t)newdiscrv, newlen);
     resv = (melt_ptr_t) dst;
     dst->meltmap_aux = src->meltmap_aux;
     for (unsigned srcix = 0;
	  srcix < srclen;
	  srcix++) {
       meltobject_ptr_t curat = NULL;
       melt_ptr_t curva = NULL;
       src = (struct meltmapobjects_st*) srcvalv;
       curat = src->entab[srcix].e_at;
       curva = src->entab[srcix].e_va;
       if (!curat || curat == (meltobject_ptr_t) HTAB_DELETED_ENTRY
		  || !curva) 
         continue;
       meltgc_put_mapobjects((meltmapobjects_ptr_t)resv, curat, curva);
       /* update the dst, since it could have moved */
       dst =  (struct meltmapobjects_st*) resv;
     } /* end cloning, from VALDESC_MAPOBJECTS */
  }#
  :valdesc_forwchunk #{$' /* forwarding from VALDESC_MAPOBJECTS */
    int siz, ix;
    MELT_FORWARDED(src->meltmap_aux);
    if (!src->entab)
      break;
    siz = melt_primtab[src->lenix];
    gcc_assert (siz > 0);
    if (melt_is_young (src->entab))
      {
        struct entryobjectsmelt_st *newtab = 
          /* Don't need a cleared allocation!  */
          ggc_alloc_vec_entryobjectsmelt_st (siz);
        memcpy (newtab, src->entab,
                siz * sizeof (struct entryobjectsmelt_st));
        src->entab = newtab;
      }
      for (ix = 0;
	   ix < siz;
	   ix++)
      {
        meltobject_ptr_t at = src->entab[ix].e_at;
        if (!at || at == (void *) HTAB_DELETED_ENTRY)
          {
            src->entab[ix].e_va = NULL;
            continue;
          }
        MELT_FORWARDED (at);
        src->entab[ix].e_at = at;
        MELT_FORWARDED (src->entab[ix].e_va);
      }
    /* end forwarding from VALDESC_MAPOBJECTS */
  }#
)
(install_value_descriptor valdesc_mapobjects)


;;;;;;;;;;;;;;;; string map values
(definstance valdesc_mapstrings class_value_descriptor
  :doc #{$VALDESC_MAPSTRINGS describes string-keyed map values.}#
  :named_name '"VALDESC_MAPSTRINGS"
  :valdesc_objmagic '"MELTOBMAG_MAPSTRINGS"
  :valdesc_struct '"meltmapstrings_st"
  :valdesc_unionmem '"u_mapstrings"
  :valdesc_membchunk #{$' /* from VALDESC_MAPSTRINGS in warmelt-base.melt */
  unsigned count;
  unsigned char lenix;
  melt_ptr_t meltmap_aux;
  struct entrystringsmelt_st *GTY ((length ("melt_primtab[%h.lenix]")))
    entab;
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_MAPSTRINGS in warmelt-base.melt */
/* ggc_alloc_meltmapstrings_st should be gengtype generated for VALDESC_MAPSTRINGS */
#ifndef ggc_alloc_meltmapstrings_st
#define ggc_alloc_meltmapstrings_st() ((struct meltmapstrings_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapstrings_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entrystringsmelt_st
#define ggc_alloc_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_cleared_vec_entrystringsmelt_st
#define ggc_alloc_cleared_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
        int siz = melt_primtab[src->lenix];
	size_t sz = 0;
	dst = 
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapstrings_st ();
	sz = sizeof (*dst);
        dst->discr = src->discr;
        dst->count = src->count;
        dst->lenix = src->lenix;
        dst->meltmap_aux = src->meltmap_aux;
        if (siz > 0 && src->entab)
          {
          /* Don't need a cleared allocation.  */
            dst->entab = ggc_alloc_vec_entrystringsmelt_st (siz);
            memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	    sz += siz * sizeof(dst->entab[0]);
          }
        else
          dst->entab = NULL;
        melt_forwarded_copy_byte_count += sz;
  }#
  :valdesc_clonechunk #{$' /* cloning from VALDESC_MAPSTRINGS */
     unsigned srccount = src->count;
     unsigned srclen = melt_primtab[src->lenix];
     unsigned newlen = 4*srccount/3+4;
     dst = (struct meltmapstrings_st*) meltgc_new_mapstrings ((meltobject_ptr_t)newdiscrv, newlen);
     resv = (melt_ptr_t) dst;
     dst->meltmap_aux = src->meltmap_aux;
     for (unsigned srcix = 0;
	  srcix < srclen;
	  srcix++) {
       const char* curat = NULL;
       melt_ptr_t curva = NULL;
       src = (struct meltmapstrings_st*) srcvalv;
       dst = (struct meltmapstrings_st*) resv;
       curat = src->entab[srcix].e_at;
       if (!curat || curat == (const char*) HTAB_DELETED_ENTRY || !curat[0])
         continue;
       curva = src->entab[srcix].e_va;
       if (!curva) 
         continue;
       meltgc_put_mapstrings (dst, curat, curva);
       dst = (struct meltmapstrings_st*) resv;
     }
     /* end  cloning from VALDESC_MAPSTRINGS */
  }#
  :valdesc_forwchunk #{$' /* forwarding from VALDESC_MAPSTRINGS */
     int ix, siz;
     MELT_FORWARDED(src->meltmap_aux);
     if (!src->entab)
       break;
     siz = melt_primtab[src->lenix];
     gcc_assert (siz > 0);
     if (melt_is_young (src->entab))
       {
         struct entrystringsmelt_st *newtab
           /* Don't need a cleared allocation!  */
           = ggc_alloc_vec_entrystringsmelt_st (siz);
         memcpy (newtab, src->entab,
                 siz * sizeof (struct entrystringsmelt_st));
         src->entab = newtab;
       }
       for (ix = 0;
	    ix < siz;
	    ix++)
       {
         const char *at = src->entab[ix].e_at;
         if (!at || at == (void *) HTAB_DELETED_ENTRY)
           {
             src->entab[ix].e_va = NULL;
             continue;
           }
         if (melt_is_young ((const void *) at))
           src->entab[ix].e_at = (const char *) ggc_strdup (at);
         MELT_FORWARDED (src->entab[ix].e_va);
       }
    /* end  forwarding from VALDESC_MAPSTRINGS */
  }#
)
(install_value_descriptor valdesc_mapstrings)



;;;;;;;;;;;;;;;; decaying value
(definstance valdesc_decay class_value_descriptor
  :doc #{$VALDESC_DECAY describes decaying values.}#
  :named_name '"VALDESC_DECAY"
  :valdesc_objmagic '"MELTOBMAG_DECAY"
  :valdesc_struct '"meltdecay_st"
  :valdesc_unionmem '"u_decay"
  :valdesc_gty #{$' mark_hook ("melt_mark_decay")}#
  :valdesc_membchunk #{$' /* from VALDESC_DECAY in warmelt-base.melt */
  melt_ptr_t val;
  unsigned remain;		/* remaining number of marking */
  }#
  :valdesc_copychunk #{$' /* from VALDESC_DECAY */
/* ggc_alloc_meltdecay_st should be gengtype generated for VALDESC_DECAY */
#ifndef ggc_alloc_meltdecay_st
#define ggc_alloc_meltdecay_st() ((struct meltdecay_st *)(ggc_internal_alloc_stat (sizeof (struct meltdecay_st) MEM_STAT_INFO)))
#endif
     dst = ggc_alloc_meltdecay_st ();
     *dst = *src;
     melt_forwarded_copy_byte_count += sizeof(*dst);
  }#
  :valdesc_clonechunk :true
  :valdesc_forwchunk #{$' /* from VALDESC_DECAY */
     MELT_FORWARDED (src->val);
  }#
)
(install_value_descriptor valdesc_decay)
  

;;;;;;;;;;;;;;;; multiple value
(definstance valdesc_multiple class_varisized_value_descriptor
  :doc #{$VALDESC_MULTIPLE describes multiple values, i.e. tuples.}#
  :named_name '"VALDESC_MULTIPLE"
  :valdesc_objmagic '"MELTOBMAG_MULTIPLE"
  :valdesc_struct '"meltmultiple_st"
  :valdesc_unionmem '"u_multiple"
  :valdesc_membchunk #{$' /* from VALDESC_MULTIPLE in warmelt-base.melt */
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$'  /* decl VALDESC_MULTIPLE in warmelt-base.melt */
#define MELT_MULTIPLE_STRUCT(N) {               \
    meltobject_ptr_t discr;                     \
    unsigned nbval;                             \
    melt_ptr_t tabval[N+1];  }
  typedef struct meltmultiple_st* meltmultiple_ptr_t;
  }#
  :valdesc_copychunk #{$'  /* copy chunk from VALDESC_MULTIPLE */
  /* ggc_alloc_meltmultiple_st should be gengtype generated for VALDESC_MULTIPLE */
#ifndef ggc_alloc_meltmultiple_st
#define ggc_alloc_meltmultiple_st(SIZE) ((struct meltmultiple_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
    int nbv = (int) src->nbval;
    size_t sz = nbv*sizeof(void*) + offsetof(struct meltmultiple_st, tabval);
    dst = 
      /* Don't need a cleared allocation!  */
      ggc_alloc_meltmultiple_st (sz);
    melt_forwarded_copy_byte_count += sz;
    /* we cannot copy the whole src, because MELT_FLEXIBLE_DIM might be
       1 and nbval could be 0 */
    dst->discr = src->discr;
    dst->nbval = src->nbval;
    for (int ix = 0;
	 ix < nbv;
	 ix++)
      dst->tabval[ix] = src->tabval[ix];
    /* end copy chunk from VALDESC_MULTIPLE */
  }#
  :valdesc_clonechunk #{$' /* cloning from VALDESC_MULTIPLE */
    unsigned srclen = src->nbval;
    dst = 
       (struct meltmultiple_st*) meltgc_new_multiple ((meltobject_ptr_t)newdiscrv, srclen);
    resv = (melt_ptr_t) dst;
    src = (struct meltmultiple_st*) srcvalv; /* could have moved */
    for (unsigned srcix = 0;
	 srcix < srclen;
	 srcix++) 
      dst->tabval[srcix] = src->tabval[srcix];
  /* end cloning from VALDESC_MULTIPLE */
  }#
  :valdesc_forwchunk #{$' /* forwarding chunk from VALDESC_MULTIPLE */
     int nbval = (int) src->nbval;
     for (int ix = 0;
	  ix < nbval;
	  ix++)
       MELT_FORWARDED (src->tabval[ix]);
     /* end forwarding chunk from VALDESC_MULTIPLE */
  }#
)
(install_value_descriptor valdesc_multiple)

;;;;;;;;;;;;;;;; closure value
(definstance valdesc_closure class_varisized_value_descriptor
  :doc #{$VALDESC_CLOSURE describes closure values, i.e. functions.}#
  :named_name '"VALDESC_CLOSURE"
  :valdesc_objmagic '"MELTOBMAG_CLOSURE"
  :valdesc_struct '"meltclosure_st"
  :valdesc_unionmem '"u_closure"
  :valdesc_membchunk #{$' /* from VALDESC_CLOSURE in warmelt-base.melt */
    meltroutine_ptr_t rout;
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_CLOSURE  in warmelt-base.melt */
#define MELT_CLOSURE_STRUCT(N) {                \
    meltobject_ptr_t discr;                     \
    meltroutine_ptr_t rout;			\
    unsigned nbval;                             \
    melt_ptr_t tabval[N+1]; }
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_CLOSURE in warmelt-base.melt  */
/* ggc_alloc_meltclosure_st should be gengtype generated for VALDESC_CLOSURE */
#ifndef ggc_alloc_meltclosure_st
#define ggc_alloc_meltclosure_st(SIZE) ((struct meltclosure_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
     int nbv = (int) src->nbval;
     size_t sz = nbv*sizeof(void*) + offsetof(struct meltclosure_st, tabval);
     dst = 
   /* Don't need a cleared allocation!  */
       ggc_alloc_meltclosure_st  (sz);
     melt_forwarded_copy_byte_count += sz;
     dst->discr = src->discr;
     dst->rout = src->rout;
     dst->nbval = (unsigned) nbv;
     for (int ix = 0;
	  ix < nbv;
	  ix++)
       dst->tabval[ix] = src->tabval[ix];
  }#
  :valdesc_forwchunk #{$' /* forwarding from VALDESC_CLOSURE */
     int nbval = (int) src->nbval;
     MELT_FORWARDED (src->rout);
     for (int ix = 0;
	  ix < nbval;
	  ix++)
       MELT_FORWARDED (src->tabval[ix]);
  }#
  :valdesc_clonechunk  #{$' /* cloning from VALDESC_CLOSURE */
     unsigned nbval = (int) src->nbval;
     dst
        = (struct meltclosure_st*)meltgc_allocate (sizeof(struct meltclosure_st),
						   nbval*sizeof(void*));
     resv = (melt_ptr_t) dst;
     src = (struct meltclosure_st*)srcvalv;
     dst->discr = (meltobject_ptr_t)newdiscrv;
     dst->rout = src->rout;
     for (unsigned ix = 0;
	  ix < nbval;
	  ix++)
       dst->tabval[ix] = src->tabval[ix];
     /* end cloning from VALDESC_CLOSURE */
  }#
)
(install_value_descriptor valdesc_closure)

;;;;;;;;;;;;;;;; routine value
(definstance valdesc_routine class_varisized_value_descriptor
  :doc #{$VALDESC_ROUTINE describes routine values.}#
  :named_name '"VALDESC_ROUTINE"
  :valdesc_objmagic '"MELTOBMAG_ROUTINE"
  :valdesc_struct '"meltroutine_st"
  :valdesc_unionmem '"u_routine"
  :valdesc_membchunk #{$' /* from VALDESC_ROUTINE in warmelt-base.melt */
    char routdescr[MELT_ROUTDESCR_LEN];
    meltroutfun_t* GTY ((skip)) routfunad;
    melt_ptr_t routdata;
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_ROUTINE */
#ifndef meltroutine_ptr_t_TYPEDEFINED
typedef struct meltroutine_st *meltroutine_ptr_t;
#define  meltroutine_ptr_t_TYPEDEFINED
#endif /*meltroutine_ptr_t_TYPEDEFINED from VALDESC_ROUTINE */

/* unsafely set inside the meltroutine_st pointed by Rptr the
   routine function pointer to Rout */
#define MELT_ROUTINE_SET_ROUTCODE(Rptr,Rout) do {	\
  ((struct meltroutine_st*)(Rptr))->routfunad		\
     = reinterpret_cast<meltroutfun_t*> (Rout);		\
} while(0)

#define MELT_ROUTINE_STRUCT(N) {		\
  meltobject_ptr_t discr;			\
  char routdescr[MELT_ROUTDESCR_LEN];		\
  meltroutfun_t* routfunad;			\
  melt_ptr_t routdata;				\
  unsigned nbval;				\
  melt_ptr_t tabval[N+1]; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_ROUTINE */
  /* ggc_alloc_meltroutine_st should be gengtype generated for VALDESC_ROUTINE */
#ifndef ggc_alloc_meltroutine_st
#define ggc_alloc_meltroutine_st(SIZE) ((struct meltroutine_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif 
     int nbv = (int) src->nbval;
     size_t sz = nbv*sizeof(void*) + offsetof(struct meltroutine_st, tabval);
     int ix = 0;
     dst =
       /* Don't need a cleared allocation!  */
       ggc_alloc_meltroutine_st (sz);
     melt_forwarded_copy_byte_count += sz;
     dst->discr = src->discr;
     strncpy (dst->routdescr, src->routdescr, MELT_ROUTDESCR_LEN);
     dst->routdescr[MELT_ROUTDESCR_LEN - 1] = 0;
     dst->nbval = (unsigned) nbv;
     dst->routfunad = src->routfunad;
     for (ix = 0;
	  ix < nbv;
	  ix++)
       dst->tabval[ix] = src->tabval[ix];
     dst->routdata = src->routdata;
  }#
  ;; don't clone routines!
  :valdesc_forwchunk #{$' /* from VALDESC_ROUTINE */
     int nbval = (int) src->nbval;
     for (int ix = 0;
	  ix < nbval;
	  ix++)
       MELT_FORWARDED (src->tabval[ix]);
     MELT_FORWARDED (src->routdata);
  }#
)
(install_value_descriptor valdesc_routine)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(definstance valdesc_hook class_varisized_value_descriptor
  :doc #{$VALDESC_HOOK describes hook values.}#
  :named_name '"VALDESC_HOOK"
  :valdesc_objmagic '"MELTOBMAG_HOOK"
  :valdesc_struct '"melthook_st"
  :valdesc_unionmem '"u_hook"
  :valdesc_membchunk #{$' /* from VALDESC_HOOK in warmelt-base.melt */
    char hookname[MELT_HOOKNAME_LEN];
    void* GTY ((skip)) hookad;
    melt_ptr_t hookdata;
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_HOOK  in warmelt-base.melt */
#ifndef melthook_ptr_t_TYPEDEFINED
typedef struct melthook_st *melthook_ptr_t;
#define  melthook_ptr_t_TYPEDEFINED
#endif /*melthook_ptr_t_TYPEDEFINED from VALDESC_ROUTINE */

/* unsafely set inside the melthook_st pointed by Hptr the
   routine function pointer to Hookroot */
#define MELT_HOOK_SET_ROUTCODE(Hptr,Hookrout) do {	\
  ((struct melthook_st*)(Hptr))->hookad		        \
     = reinterpret_cast<void*> (Hookrout);    		\
} while(0)

#define MELT_HOOK_STRUCT(N) {		        \
  meltobject_ptr_t discr;			\
  char hookname[MELT_HOOKNAME_LEN];		\
  void* hookad;			                \
  melt_ptr_t hookdata;				\
  unsigned nbval;				\
  melt_ptr_t tabval[N+1]; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_HOOK in warmelt-base.melt */
  /* ggc_alloc_melthook_st should be gengtype generated for VALDESC_HOOK */
#ifndef ggc_alloc_melthook_st
#define ggc_alloc_melthook_st(SIZE) ((struct melthook_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif 
     int nbv = (int) src->nbval;
     int ix = 0;
     size_t sz = nbv*sizeof(void*) + offsetof(struct melthook_st, tabval);
     dst =
       /* Don't need a cleared allocation!  */
       ggc_alloc_melthook_st (sz);
     melt_forwarded_copy_byte_count += sz;
     dst->discr = src->discr;
     strncpy (dst->hookname, src->hookname, MELT_HOOKNAME_LEN);
     dst->hookname[MELT_HOOKNAME_LEN - 1] = 0;
     dst->nbval = (unsigned) nbv;
     dst->hookad = src->hookad;
     for (ix = 0;
	  ix < nbv;
	  ix++)
       dst->tabval[ix] = src->tabval[ix];
     dst->hookdata = src->hookdata;
  }#
  ;; don't clone hooks!
  :valdesc_forwchunk #{$' /* from VALDESC_HOOK in warmelt-base.melt */
     int nbval = (int) src->nbval;
     int ix = 0;
     for (ix = 0;
	  ix < nbval;
	  ix++)
       MELT_FORWARDED (src->tabval[ix]);
     MELT_FORWARDED (src->hookdata);
  }#
)
(install_value_descriptor valdesc_hook)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; long bucket values
(definstance valdesc_bucketlongs class_varisized_value_descriptor
  :doc #{$VALDESC_BUCKETLONGS describe internal long-keyed buckets inside long bighashtables.}#
  :named_name '"VALDESC_BUCKETLONGS"
  :valdesc_objmagic '"MELTOBMAG_BUCKETLONGS"
  :valdesc_struct '"meltbucketlongs_st"
  :valdesc_unionmem '"u_bucketlongs"
  ;;;
  :valdesc_membchunk #{$' /* from VALDESC_BUCKETLONGS in warmelt-base.melt */ 
     melt_ptr_t buckl_aux; /* auxiliary data */
     unsigned char buckl_lenix; /* index in melt_primtab for allocated length */
     int buckl_xnum; /* extra number */
     unsigned buckl_ucount;     /* used count of bucket entries */
     struct melt_bucketlongentry_st GTY ((length("melt_primtab[%h.buckl_lenix]")))
        buckl_entab[MELT_FLEXIBLE_DIM]; /* sorted by increasing ebl_at */
  }#
  ;;;
  :valdesc_declchunk #{$' /* decl VALDESC_BUCKETLONGS  in warmelt-base.melt */ 
  typedef struct meltbucketlongs_st* meltbucketlongs_ptr_t;
#ifndef ggc_alloc_meltbucketlongs_st
#define ggc_alloc_meltbucketlongs_st(SIZE) ((struct meltbucketlongs_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
  }#
  ;;;
  :valdesc_copychunk #{$' /* copy chunk from  VALDESC_BUCKETLONGS  in warmelt-base.melt */
  /* ggc_alloc_meltbucketlongs_st should be gengtype generated for VALDESC_BUCKETLONGS */
   unsigned lnix = src->buckl_lenix;
   unsigned len = melt_primtab[lnix];
   unsigned ucnt = 0;
   unsigned ix = 0;
   size_t sz = len*sizeof (struct melt_bucketlongentry_st) 
	       + offsetof(struct meltbucketlongs_st, buckl_entab);
   gcc_assert (lnix > 0);
   gcc_assert (len > 0);
   dst = /* Don't need a cleared allocation! */
     ggc_alloc_meltbucketlongs_st (sz);
   melt_forwarded_copy_byte_count += sz;
   dst->discr = src->discr;
   dst->buckl_lenix = src->buckl_lenix;
   dst->buckl_aux = src->buckl_aux;
   dst->buckl_xnum = src->buckl_xnum;
   ucnt = dst->buckl_ucount = src->buckl_ucount;
   for (ix = 0;
	ix < ucnt;
	ix++)
     dst->buckl_entab[ix] = src->buckl_entab[ix];
   for (ix = ucnt;
	ix < len;
	ix++) {
     dst->buckl_entab[ix].ebl_at = 0L;
     dst->buckl_entab[ix].ebl_va = NULL;
   }
   /* end copy chunk VALDESC_BUCKETLONGS */
  }#
  :valdesc_clonechunk #{$' /* cloning chunk  from VALDESC_BUCKETLONGS in warmelt-base.melt */
   unsigned lnix = src->buckl_lenix;
   unsigned len = melt_primtab[lnix];
   unsigned cnt = src->buckl_ucount;
   unsigned dstlen = 0;
   unsigned ix = 0;
   gcc_assert (lnix > 0);
   gcc_assert (len > 0);
   gcc_assert (cnt <= len);
   dst = (struct meltbucketlongs_st*)
      meltgc_new_longsbucket ((meltobject_ptr_t)newdiscrv, cnt + cnt/8 + 2);
   resv = (melt_ptr_t) dst;
   dstlen = melt_primtab[dst->buckl_lenix];
   dst->buckl_aux = src->buckl_aux;
   dst->buckl_xnum = src->buckl_xnum;
   dst->buckl_lenix = src->buckl_lenix;
   for (ix = 0;
	ix < cnt;
	ix++)
     dst->buckl_entab[ix] = src->buckl_entab[ix];
   for (ix = cnt;
	ix < dstlen;
	ix++) {
     dst->buckl_entab[ix].ebl_at = 0L;
     dst->buckl_entab[ix].ebl_va = NULL;
   }
   /* end clone chunk VALDESC_BUCKETLONGS */
  }#
  ;;
  :valdesc_forwchunk #{$' /* forwarding chunk from VALDESC_BUCKETLONGS in warmelt-base.melt */
   unsigned lnix = src->buckl_lenix;
   unsigned len = melt_primtab[lnix];
   unsigned ucnt = src->buckl_ucount;
   unsigned ix = 0;
   gcc_assert (lnix > 0);
   gcc_assert (len > 0);
   MELT_FORWARDED (src->buckl_aux);
   gcc_assert (ucnt <= len);
   for (ix = 0;
	ix < ucnt;
	ix++)
      MELT_FORWARDED (src->buckl_entab[ix].ebl_va);
  /* end forwarding VALDESC_BUCKETLONGS */
  }#
  )
(install_value_descriptor valdesc_bucketlongs)


;;;;;;;;;;;;;;;; JSONobject value
(definstance valdesc_jsonobject class_varisized_value_descriptor
  :doc #{$VALDESC_JSONOBJECT describes JSON object values. See
  http://json.org/ or RFC7159 for more. Internally represented as a
  sorted array of JSON name->value pairs. A JSON name is either an
  instance of CLASS_NAMED -whose immutable :NAMED_NAME is a string
  value- or a string value. Chaos could happen with instances of
  CLASS_NAMED whose :NAMED_NAME is changing or is not a fixed
  string.}#
  :named_name '"VALDESC_JSONOBJECT"
  :valdesc_objmagic '"MELTOBMAG_JSONOBJECT"
  :valdesc_struct '"meltjsonobject_st"
  :valdesc_unionmem '"u_jsonobject"
  ;;;
  :valdesc_membchunk #{$' /* from VALDESC_JSONOBJECT in warmelt-base.melt */ 
    melt_ptr_t jsob_aux;  /* auxiliary data */
    unsigned jsob_size;   /* size of jsob_entab below */
    struct melt_jsonobentry_st GTY ((length("%h.jsob_size")))
       jsob_entab[MELT_FLEXIBLE_DIM];	/* sorted alphanumerically by names */
  }#
  ;;;
  :valdesc_declchunk #{$' /* decl VALDESC_JSONOBJECT in warmelt-base.melt */
  typedef struct meltjsonobject_st* meltjsonobject_ptr_t;
#ifndef ggc_alloc_meltjsonobject_st
#define ggc_alloc_meltjsonobject_st(SIZE) ((struct meltjsonobject_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif

  // small functions from VALDESC_JSONOBJECT in warmelt-base.melt
  static inline melt_ptr_t 
  melt_jsonobject_aux (melt_ptr_t vjob) { // from VALDESC_JSONOBJECT
    if (melt_magic_discr(vjob) == MELTOBMAG_JSONOBJECT)
      return ((struct meltjsonobject_st*)vjob)->jsob_aux;
    return NULL;
  }

  static inline void 
  melt_jsonobject_putaux (melt_ptr_t vjob, melt_ptr_t vaux) { // from VALDESC_JSONOBJECT
    if (melt_magic_discr(vjob) == MELTOBMAG_JSONOBJECT) {
      ((struct meltjsonobject_st*)vjob)->jsob_aux = vaux;
      meltgc_touch_dest (vjob, vaux);
    }
  }

  static inline unsigned
  melt_jsonobject_size  (melt_ptr_t vjob) { // from VALDESC_JSONOBJECT
    if (melt_magic_discr(vjob) == MELTOBMAG_JSONOBJECT)
      return ((struct meltjsonobject_st*)vjob)->jsob_size;
    return 0;
  }

  static inline melt_ptr_t
  melt_jsonobject_nth_name (melt_ptr_t vjob, int rk) 
  {
    if (melt_magic_discr(vjob) == MELTOBMAG_JSONOBJECT) {
      unsigned sz = ((struct meltjsonobject_st*)vjob)->jsob_size;
      if (rk<0) rk += sz;
      if (rk>=0 && rk < (int) sz) return ((struct meltjsonobject_st*)vjob)->jsob_entab[rk].jsonob_name;
    };
    return NULL;
  }

  static inline melt_ptr_t
  melt_jsonobject_nth_value (melt_ptr_t vjob, int rk) 
  {
    if (melt_magic_discr(vjob) == MELTOBMAG_JSONOBJECT) {
      unsigned sz = ((struct meltjsonobject_st*)vjob)->jsob_size;
      if (rk<0) rk += sz;
      if (rk>=0 && rk < (int) sz) return ((struct meltjsonobject_st*)vjob)->jsob_entab[rk].jsonob_val;
    };
    return NULL;
  }

  // end of small functions in VALDESC_JSONOBJECT from warmelt-base.melt
  }#
  ;;;
  :valdesc_copychunk #{$' /* copy chunk from  VALDESC_JSONOBJECT in warmelt-base.melt */
  /* ggc_alloc_meltjsonobject_st should be gengtype generated for VALDESC_JSONOBJECT */
  unsigned srcsize = src->jsob_size;
  size_t sz = srcsize * sizeof(melt_jsonobentry_st)
     + offsetof(struct meltjsonobject_st, jsob_entab);
  dst = /* Don't need a cleared allocation! */
     ggc_alloc_meltjsonobject_st (sz);
  melt_forwarded_copy_byte_count += sz;
  dst->discr = src->discr;
  dst->jsob_aux = src->jsob_aux;
  dst->jsob_size = srcsize;
  for (unsigned ix = 0; 
       ix < srcsize; 
       ix++) 
    dst->jsob_entab[ix] = src->jsob_entab[ix];
   /* end copy chunk VALDESC_JSONOBJECT */
  }#
  :valdesc_clonechunk #{$' /* cloning chunk from VALDESC_JSONOBJECT in warmelt-base.melt */
  unsigned srcsize = src->jsob_size;
  dst = (struct meltjsonobject_st*)meltgc_allocate(sizeof(struct meltjsonobject_st), 
                                                   srcsize*sizeof(melt_jsonobentry_st));
  dst->discr = (meltobject_ptr_t)newdiscrv;
  dst->jsob_aux = src->jsob_aux;
  for (unsigned ix=0; ix<srcsize; ix++)
    dst->jsob_entab[ix] = src->jsob_entab[ix];
   /* end cloning chunk VALDESC_JSONOBJECT */
  }#
  :valdesc_forwchunk #{$' /* forwarding chunk from VALDESC_JSONOBJECT in warmelt-base.melt */
  unsigned srcsize = src->jsob_size;
  MELT_FORWARDED(src->jsob_aux);
  for (unsigned ix = 0; 
       ix < srcsize; 
       ix++) {
    MELT_FORWARDED(src->jsob_entab[ix].jsonob_name);
    MELT_FORWARDED(src->jsob_entab[ix].jsonob_val);
  };
   /* end forwarding chunk VALDESC_JSONOBJECT */
  }#
)
(install_value_descriptor valdesc_jsonobject)


;;;;;;;;;;;;;;;; string value
(definstance valdesc_string class_varisized_value_descriptor
  :doc #{$VALDESC_STRING describes string values.}#
  :named_name '"VALDESC_STRING"
  :valdesc_objmagic '"MELTOBMAG_STRING"
  :valdesc_struct '"meltstring_st"
  :valdesc_unionmem '"u_string"
  :valdesc_membchunk #{$' /* from VALDESC_STRING in warmelt-base.melt */ 
    unsigned slen;                               
    char val[MELT_FLEXIBLE_DIM];	/* null terminated */
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_STRING from warmelt-base.melt */
#define MELT_STRING_STRUCT(N) {			\
  meltobject_ptr_t discr;			\
  unsigned slen;                                \
  char val[(N)+1];	/* null terminated */	\
  long _gap; }
  }#
  :valdesc_copychunk #{$' /* copy from VALDESC_STRING file warmelt-base.melt*/  
/* ggc_alloc_meltstring_st should be gengtype generated for VALDESC_STRING */
#ifndef ggc_alloc_meltstring_st
#define ggc_alloc_meltstring_st(SIZE) ((struct meltstring_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
     int srclen = (src->val)?strlen (src->val):0;
     size_t sz = offsetof(struct meltstring_st, val) + (srclen+1);
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltstring_st  (sz);
     melt_forwarded_copy_byte_count += sz;
     dst->discr = src->discr;
     memcpy (dst->val, src->val, srclen);
     dst->val[srclen] = (char)0;
     dst->slen = (unsigned) srclen;
      /* end copy from VALDESC_STRING */
  }#
  :valdesc_clonechunk #{$' /* clone from VALDESC_STRING  */
     dst = (struct meltstring_st*)
          meltgc_new_stringdup ((meltobject_ptr_t)newdiscrv, 
				src->val);
     resv = (melt_ptr_t) dst;
     /* end clone from VALDESC_STRING  */
  }#
)
(install_value_descriptor valdesc_string)

;;;;;;;;;;;;;;;; string buffer value
(definstance valdesc_strbuf class_value_descriptor
  :doc #{$VALDESC_STRBUF describes string buffers values}#
  :named_name '"VALDESC_STRBUF"
  :valdesc_objmagic '"MELTOBMAG_STRBUF"
  :valdesc_struct '"meltstrbuf_st"
  :valdesc_unionmem '"u_strbuf"
  :valdesc_membchunk #{$' /* from VALDESC_STRBUF in warmelt-base.melt */
  /* no GTY on bufzn, it a scalar data */  
  char * bufzn;
  unsigned char buflenix;	/* allocated length index of
				   buffer */
  unsigned bufstart;
  unsigned bufend;		/* start & end useful positions */
  /* the following field is usually the value of buf (for
     objects in the young zone), to allocate the object and its fields
     at once; no GTY length on buf_space, since it is a non pointer data. */
  char  buf_space[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_copychunk #{$' /* copy chunk from VALDESC_STRBUF */
/* ggc_alloc_meltstrbuf_st should be gengtype gengtype for VALDESC_STRBUF */
#ifndef ggc_alloc_meltstrbuf_st
#define ggc_alloc_meltstrbuf_st() ((struct meltstrbuf_st *)(ggc_internal_alloc_stat (sizeof (struct meltstrbuf_st) MEM_STAT_INFO)))
#endif
     unsigned blen = melt_primtab[src->buflenix];
     size_t sz = sizeof(*dst);
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltstrbuf_st ();
     dst->discr = src->discr;
     dst->bufstart = src->bufstart;
     dst->bufend = src->bufend;
     dst->buflenix = src->buflenix;
     if (blen > 0)
        {
          dst->bufzn = CONST_CAST (char *, ggc_alloc_string (src->bufzn, blen+1));
          dst->bufzn[blen] = (char)0;
	  sz += blen+1;
        }
      else
        dst->bufzn = NULL;
     melt_forwarded_copy_byte_count += sz;
    /* end copy chunk from VALDESC_STRBUF */
  }#
  :valdesc_clonechunk #{$' /* clone chunk from VALDESC_STRBUF */
    dst = (struct meltstrbuf_st*) 
       meltgc_new_strbuf ((meltobject_ptr_t)newdiscrv, NULL);
    resv = (melt_ptr_t) dst;
    src = (struct meltstrbuf_st*)srcvalv;
    meltgc_add_strbuf ((melt_ptr_t) dst, melt_strbuf_str ((melt_ptr_t)src));
    /* end clone chunk from VALDESC_STRBUF */
  }#
)
(install_value_descriptor valdesc_strbuf)


;;;;;;;;;;;;;;;; pair value
(definstance valdesc_pair class_value_descriptor
  :doc #{$VALDESC_PAIR describes pair values inside lists.}#
  :named_name '"VALDESC_PAIR"
  :valdesc_objmagic '"MELTOBMAG_PAIR"
  :valdesc_struct '"meltpair_st"
  :valdesc_unionmem '"u_pair"
  :valdesc_gty #{$' chain_next ("%h.tl")}#
  :valdesc_declchunk #{$' /* decl VALDESC_PAIR in warmelt-base.melt */
  typedef struct meltpair_st *meltpair_ptr_t;
  }#
  :valdesc_membchunk #{$' /* from VALDESC_PAIR in warmelt-base.melt */
    melt_ptr_t hd;
    struct meltpair_st *tl;
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_PAIR in warmelt-base.melt */
  /* ggc_alloc_meltpair_st should be gengtype gengtype for VALDESC_PAIR */
#ifndef ggc_alloc_meltpair_st
#define ggc_alloc_meltpair_st() ((struct meltpair_st *)(ggc_internal_alloc_stat (sizeof (struct meltpair_st) MEM_STAT_INFO)))
#endif
    dst = /* Don't need a cleared allocation.  */
	  ggc_alloc_meltpair_st ();
    *dst = *src;
    melt_forwarded_copy_byte_count += sizeof(*dst);
  }#
  :valdesc_clonechunk :true
  :valdesc_forwchunk #{$' /* forward VALDESC_PAIR in warmelt-base.melt */
     MELT_FORWARDED (src->hd);
     MELT_FORWARDED (src->tl);
  }#
)
(install_value_descriptor valdesc_pair)
  

;;;;;;;;;;;;;;;; list value
(definstance valdesc_list class_value_descriptor
  :doc #{$VALDESC_LIST describes list values containing pairs.}#
  :named_name '"VALDESC_LIST"
  :valdesc_objmagic '"MELTOBMAG_LIST"
  :valdesc_struct '"meltlist_st"
  :valdesc_unionmem '"u_list"
  :valdesc_membchunk #{$' /* from VALDESC_LIST in warmelt-base.melt */
    struct meltpair_st *first;
    struct meltpair_st *last;
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_LIST in warmelt-base.melt */
  typedef struct meltlist_st *meltlist_ptr_t;
  }#
  :valdesc_copychunk #{$' /* copy chunk from VALDESC_LIST */
/* ggc_alloc_meltlist_st should be gengtype gengtype for VALDESC_LIST */
#ifndef ggc_alloc_meltlist_st
#define ggc_alloc_meltlist_st() ((struct meltlist_st *)(ggc_internal_alloc_stat (sizeof (struct meltlist_st) MEM_STAT_INFO)))
#endif
     dst = 
	  /* Don't need a cleared allocation!  */
	 ggc_alloc_meltlist_st ();
     *dst = *src;
     melt_forwarded_copy_byte_count += sizeof(*dst);
     /* end chunk from VALDESC_LIST */
  }#
  :valdesc_clonechunk #{$' /* cloning from VALDESC_LIST */
     struct meltpair_st* curpair = NULL;
     dst = (struct meltlist_st*) meltgc_new_list ((meltobject_ptr_t)newdiscrv);
     resv = (melt_ptr_t) dst;
     src = (struct meltlist_st*) srcvalv;
     for (curpair = ((struct meltlist_st *) src)->first;
          melt_magic_discr ((melt_ptr_t) curpair) == MELTOBMAG_PAIR; 
          curpair = (struct meltpair_st *) (curpair->tl)) {
     src = (struct meltlist_st*) srcvalv; 
     dst = (struct meltlist_st*) resv;
     compv = (melt_ptr_t) curpair;
     meltgc_append_list ((melt_ptr_t) resv, curpair->hd);
     /* copy, because GC might have moved values. */
     curpair = (struct meltpair_st*) compv;
     src = (struct meltlist_st*) srcvalv; 
     dst = (struct meltlist_st*) resv;
    }
     /* end cloning from VALDESC_LIST */
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_LIST */
     MELT_FORWARDED (src->first);
     MELT_FORWARDED (src->last);
  }#

)
(install_value_descriptor valdesc_list)

;;;;;;;;;;;;;;;; int value
(definstance valdesc_int class_value_descriptor
  :doc #{$VALDESC_INT describes int values boxing long integers.}#
  :named_name '"VALDESC_INT"
  :valdesc_objmagic '"MELTOBMAG_INT"
  :valdesc_struct '"meltint_st"
  :valdesc_unionmem '"u_int"
  :valdesc_membchunk #{$' /* from VALDESC_INT in warmelt-base.melt */
    long val;
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_INT in warmelt-base.melt */
  typedef struct meltint_st *meltint_ptr_t;
  #define melt_unsafe_boxed_int_value(V) (((meltint_ptr_t)(V))->val)
  static inline long melt_boxed_int_value(melt_ptr_t v)
  { return (melt_magic_discr(v)==MELTOBMAG_INT)? melt_unsafe_boxed_int_value(v) : 0L; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_INT */
/* ggc_alloc_meltint_st should be gengtype generated for VALDESC_INT */
#ifndef ggc_alloc_meltint_st
#define ggc_alloc_meltint_st() ((struct meltint_st *)(ggc_internal_alloc_stat (sizeof (struct meltint_st) MEM_STAT_INFO)))
#endif
     dst = 
        /* Don't need a cleared allocation.  */
	  ggc_alloc_meltint_st ();
     melt_forwarded_copy_byte_count += sizeof(*dst);
     *dst = *src;
  }#
  :valdesc_clonechunk :true
)
(install_value_descriptor valdesc_int)

;;;;;;;;;;;;;;;; double value
(definstance valdesc_double class_value_descriptor
  :doc #{$VALDESC_DOUBLE describes double values boxing long integers.}#
  :named_name '"VALDESC_DOUBLE"
  :valdesc_objmagic '"MELTOBMAG_DOUBLE"
  :valdesc_struct '"meltdouble_st"
  :valdesc_unionmem '"u_double"
  :valdesc_membchunk #{$' /* from VALDESC_DOUBLE in warmelt-base.melt */
    long val;
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_DOUBLE in warmelt-base.melt */
  typedef struct meltdouble_st *meltdouble_ptr_t;
  #define melt_unsafe_boxed_double_value(V) (((meltdouble_ptr_t)(V))->val)
  static inline long melt_boxed_double_value(melt_ptr_t v)
  { return (melt_magic_discr(v)==MELTOBMAG_DOUBLE)? melt_unsafe_boxed_double_value(v) : 0L; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_DOUBLE */
/* ggc_alloc_meltdouble_st should be gengtype generated for VALDESC_DOUBLE */
#ifndef ggc_alloc_meltdouble_st
#define ggc_alloc_meltdouble_st() ((struct meltdouble_st *)(ggc_doubleernal_alloc_stat (sizeof (struct meltdouble_st) MEM_STAT_INFO)))
#endif
     dst = 
        /* Don't need a cleared allocation.  */
	  ggc_alloc_meltdouble_st ();
     melt_forwarded_copy_byte_count += sizeof(*dst);
     *dst = *src;
  }#
  :valdesc_clonechunk :true
)
(install_value_descriptor valdesc_double)

;;;;;;;;;;;;;;;; mixint value
(definstance valdesc_mixint class_value_descriptor
  :doc #{$VALDESC_MIXINT describes mixint values mixing integers with a value.}#
  :named_name '"VALDESC_MIXINT"
  :valdesc_objmagic '"MELTOBMAG_MIXINT"
  :valdesc_struct '"meltmixint_st"
  :valdesc_unionmem '"u_mixint"
  :valdesc_membchunk #{$' /* from VALDESC_MIXINT in warmelt-base.melt */
    melt_ptr_t ptrval;
    long intval;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXINT */
/* ggc_alloc_meltmixint_st should be gengtype generated for VALDESC_MIXINT */
#ifndef ggc_alloc_meltmixint_st
#define ggc_alloc_meltmixint_st() ((struct meltmixint_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixint_st) MEM_STAT_INFO)))
#endif
    dst = 
      /* Don't need a cleared allocation.  */
        ggc_alloc_meltmixint_st ();
    melt_forwarded_copy_byte_count += sizeof(*dst);
    *dst = *src;
  }#
  :valdesc_clonechunk :true
  :valdesc_forwchunk #{$' /* from VALDESC_MIXINT */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixint)

;;;;;;;;;;;;;;;; mixloc value
(definstance valdesc_mixloc class_value_descriptor
  :doc #{$VALDESC_MIXLOC describes mixloc values mixing locations with a value.}#
  :named_name '"VALDESC_MIXLOC"
  :valdesc_objmagic '"MELTOBMAG_MIXLOC"
  :valdesc_struct '"meltmixloc_st"
  :valdesc_unionmem '"u_mixloc"
  :valdesc_membchunk #{$' /* from VALDESC_MIXLOC in warmelt-base.melt.melt */
    melt_ptr_t ptrval;
    long intval;
    location_t locval;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXLOC */
/* ggc_alloc_meltmixloc_st should be gengtype generated for VALDESC_MIXLOC */
#ifndef ggc_alloc_meltmixloc_st
#define ggc_alloc_meltmixloc_st() ((struct meltmixloc_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixloc_st) MEM_STAT_INFO)))
#endif
    dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltmixloc_st ();
    *dst = *src;
    melt_forwarded_copy_byte_count += sizeof(*dst);
  }#
  :valdesc_clonechunk :true
  :valdesc_forwchunk #{$' /* from VALDESC_MIXLOC */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixloc)

;;;;;;;;;;;;;;;; mixbigint value
(definstance valdesc_mixbigint class_varisized_value_descriptor
  :doc #{$VALDESC_MIXBIGINT describes mixbigint values.}#
  :named_name '"VALDESC_MIXBIGINT"
  :valdesc_objmagic '"MELTOBMAG_MIXBIGINT"
  :valdesc_struct '"meltmixbigint_st"
  :valdesc_unionmem '"u_mixbigint"
  :valdesc_membchunk #{$' /* from VALDESC_MIXBIGINT in warmelt-base.melt */
/* an exported array mpz compatible; since we use an exported mpz format, 
   the value can be copied and trashed by MELT garbage collector without 
   harm. */
    melt_ptr_t ptrval;
    bool negative;
    unsigned biglen;
    /* no GTY on tabig, it is a array of non-pointer data */
    long tabig[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXBIGINT */
/* ggc_alloc_meltmixbigint_st should be gengtype generated for VALDESC_MIXBIGINT */
#ifndef ggc_alloc_meltmixbigint_st
#define ggc_alloc_meltmixbigint_st(SIZE) ((struct meltmixbigint_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
     unsigned blen = src->biglen;
     size_t sz = blen*sizeof(long) + offsetof(struct meltmixbigint_st, tabig);
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltmixbigint_st   (sz);
     dst->discr = src->discr;
     dst->ptrval = src->ptrval;
     dst->negative = src->negative;
     dst->biglen = blen;
     memcpy (dst->tabig, src->tabig, blen*sizeof(dst->tabig[0]));
     melt_forwarded_copy_byte_count += sz;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_MIXBIGINT */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixbigint)

;;;;;;;;;;;;;;;; real value
(definstance valdesc_real class_value_descriptor
  :doc #{$VALDESC_REAL describes real values.}#
  :named_name '"VALDESC_REAL"
  :valdesc_objmagic '"MELTOBMAG_REAL"
  :valdesc_struct '"meltreal_st"
  :valdesc_unionmem '"u_real"
  :valdesc_membchunk #{$' /* from VALDESC_REAL in warmelt-base.melt */
    REAL_VALUE_TYPE val;
  }#
  :valdesc_clonechunk :true
  :valdesc_copychunk #{$' /* from VALDESC_REAL */
/* ggc_alloc_meltreal_st should be gengtype generated for VALDESC_REAL */
#ifndef ggc_alloc_meltreal_st
#define ggc_alloc_meltreal_st() ((struct meltreal_st *)(ggc_internal_alloc_stat (sizeof (struct meltreal_st) MEM_STAT_INFO)))
#endif
    dst =
        /* Don't need a cleared allocation.  */
	ggc_alloc_meltreal_st ();
    melt_forwarded_copy_byte_count += sizeof(*dst);
    *dst = *src;
  }#
)
(install_value_descriptor valdesc_real)

;;;;;;;;;;;;;;;; special data
(definstance valdesc_special_data class_value_descriptor
  :doc #{$VALDESC_SPECIAL_data describes special finalized data.}#
  :named_name '"VALDESC_SPECIAL_DATA"
  :valdesc_objmagic '"MELTOBMAG_SPECIAL_DATA"
  :valdesc_struct '"meltspecialdata_st"
  :valdesc_unionmem '"u_special_data"
  :valdesc_gty #{$' mark_hook ("melt_mark_specialdata")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_DATA in warmelt-base.melt */
    int meltspec_mark;
    unsigned meltspec_kind;
    struct meltspecialdata_st *GTY ((skip)) meltspec_next;
    melt_ptr_t meltspec_value;
    struct meltspecialpayload_st GTY ((skip)) meltspec_payload;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_DATA */
/* ggc_alloc_meltspecialdata_st should be gengtype generated for VALDESC_SPECIAL_DATA */
#ifndef ggc_alloc_meltspecialdata_st
#define ggc_alloc_meltspecialdata_st() ((struct meltspecialdata_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialdata_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialdata_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->meltspec_mark = 1;
    /* add the new copy to the old (major) special list */
    dst->meltspec_next = melt_oldspecdatalist;
    melt_oldspecdatalist = dst;
    melt_forwarded_copy_byte_count += sizeof(*dst);
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_DATA */
    src->meltspec_mark = 1;
    MELT_FORWARDED (src->meltspec_value);
  }#
)
(install_value_descriptor valdesc_special_data)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; extra list utilities
(defun list_remove_last_element (lis)
  :doc #{$LIST_REMOVE_LAST_ELEMENT is a costly function to remove and
  return the last element of a list $LIS. It runs in a time proportional to
  the length of the list $LIS and truncates it.}#
  (if (not (is_list lis))
      (return ()))
  (let ( (lastpair (list_last lis))
	 (prevpair ())
	 )
    (if lastpair (assert_msg "check lastpair" (is_pair lastpair)) lastpair)
    (foreach_pair_component_in_list
     (lis)
     (curpair curelem)
     (assert_msg "check curpair" (is_pair curpair) curpair)
     (when (== curpair lastpair)
       (setq curpair ())
       (if (is_pair prevpair)
	   (code_chunk updatepair_chk 
		       #{ /* list_remove_last_element $UPDATEPAIR_CHK */
		       ((struct meltpair_st*)$PREVPAIR)->tl = NULL;
		       ((struct meltlist_st*)$LIS)->last
		           = (struct meltpair_st*) $PREVPAIR;
		       meltgc_touch_dest ($LIS, $PREVPAIR);
		       }#)
	 (code_chunk emptylist_chk
		     #{ /* list_remove_last_element $EMPTYLIST_CHK */
		     ((struct meltlist_st*)$LIS)->first = NULL;
		     ((struct meltlist_st*)$LIS)->last = NULL;
		     meltgc_touch ($LIS);
		     }#))
       (return curelem))
     (setq prevpair curpair))
    ))

;;;
(defun complete_sequence_as_tuple (src :rest) 
  :doc #{If $SRC is a list, complete it with the rest of arguments and return a fresh tuple,
  If $SRC is a tuple, make a bigger tuple with the rest of arguments.
  Otherwise, make a tuple of all the arguments, including the first $SRC}#
  (let ( (newlist (make_list discr_list)) )
    (cond 
     ( (is_multiple src)
       (foreach_in_multiple
	(src)
	(comp :long ix)
	(list_append newlist comp))
       )
     ( (is_list src)
       (foreach_pair_component_in_list 
	(src)
	(curpair curcomp)
	(list_append newlist curcomp))
	)
     (:else
      (list_append newlist src)))
    (forever 
     argloop
     (variadic
      ( ()
	(exit argloop))
      ( (:value v)
	(list_append newlist v))
      (:else
      (let ( (vcty (variadic_ctype 0))
	     )
	(errormsg_strv "COMPLETE_SEQUENCE_AS_TUPLE with unsupported ctype"
		       (get_field :named_name vcty))
	(assert_msg "invalid variadic argument to COMPLETE_SEQUENCE_AS_TUPLE" () vcty)))
      ))
    (let ( (res (list_to_multiple newlist))
	   )
      (return res))))
 

;;;
(defun complete_sequence_as_list (src :rest) 
  :doc #{If $SRC is a list, complete it with the rest of arguments and return a fresh list,
  If $SRC is a tuple, make a bigger list with its components and the rest of arguments.
  Otherwise, make a list of all the arguments, including the first $SRC}#
  (let ( (newlist (make_list discr_list)) )
    (cond 
     ( (is_multiple src)
       (foreach_in_multiple
	(src)
	(comp :long ix)
	(list_append newlist comp))
       )
     ( (is_list src)
       (foreach_pair_component_in_list 
	(src)
	(curpair curcomp)
	(list_append newlist curcomp))
	)
     (:else
      (list_append newlist src)))
    (forever 
     argloop
     (variadic
      ( ()
	(exit argloop))
      ( (:value v)
	(list_append newlist v))
      (:else
      (let ( (vcty (variadic_ctype 0))
	     )
	(errormsg_strv "COMPLETE_SEQUENCE_AS_LIST with unsupported ctype"
		       (get_field :named_name vcty))
	(assert_msg "invalid variadic argument to COMPLETE_SEQUENCE_AS_LIST" () vcty)))
      ))
    (return newlist)))
 



(defprimitive increment (:long left incr) :void
  :doc #{Increment $LEFT (when variable) with $INCR.}#
  #{ /*increment*/ $LEFT += $INCR; 
  }#)



(defprimitive melt_argument (:cstring nam) :cstring
  :doc #{Retrieve a MELT program argument as a raw :cstring}#
  #{melt_argument($NAM)}#)

(defprimitive melt_error_counter () :long 
  :doc #{Count the number of MELT errors.}#
  #{melt_error_counter}#)


(defprimitive melt_predefined_by_name (:cstring nam) :value
  :doc #{Retrieve the predefined by a constant name string $NAM}#
  #{/* melt_predefined_by_name */ melt_fetch_predefined
        (melt_predefined_index_by_name ($NAM))}#)


(defun melt_predefined_get (namv)
  :doc #{Retrieve the predefined by a name value $NAMV. Use with caution, because some predefined are really internal.}#
  (cond ( (is_string namv)
	  (expr_chunk predefstr_chk :value #{ /*melt_predefined_get $PREDEFSTR_CHK */
		     melt_fetch_predefined (melt_predefined_index_by_name (melt_string_str ((melt_ptr_t)($NAMV)))) }#))
	( (is_a namv class_named)
	  (let ( (namstr (get_field :named_name namv))
		 )
	  (expr_chunk predefnam_chk :value #{ /*melt_predefined_get $PREDEFNAM_CHK */
		     melt_fetch_predefined (melt_predefined_index_by_name (melt_string_str ((melt_ptr_t)($NAMSTR)))) }#)
	  ))
	( (is_integerbox namv)
	  (let ( (:long num (get_int namv))
		 )
	  (expr_chunk predefnam_chk :value #{ /*melt_predefined_get $PREDEFNAM_CHK */
		     melt_fetch_predefined ($NUM) }#)))
	(:else
	 ())))


(defun symbol_cname (sy) 
  :doc #{Give the cname of a symbol, keyword or else NULL}#
  (cond ( (is_a sy class_cloned_symbol)
	  (let ( (sbuf (make_strbuf discr_strbuf)) )
	    (add2sbuf_cident sbuf (get_field :named_name sy))
	    (add2out sbuf "cl" (get_field :csym_urank sy))
	    (strbuf2string discr_verbatim_string sbuf)
	    ))
	( (is_a sy class_keyword)
	  (let ( (sbuf (make_strbuf discr_strbuf)) )
	    (add2sbuf_cident sbuf (get_field :named_name sy))
	    (add2sbuf_strconst sbuf "kw")
	    (strbuf2string discr_verbatim_string sbuf)
	    ))
	( (is_a sy class_symbol)
	  (let ( (sbuf (make_strbuf discr_strbuf)) )
	    (add2sbuf_cident sbuf (get_field :named_name sy))
	    (strbuf2string discr_verbatim_string sbuf)
	    ))
	(:else
	 ())))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; dynamically make a MELT s-expression, notably useful for macros and
;; quotes this function is used for quotes and backquotes macro, so
;; should appear early, so before warmelt-macro.melt; we cannot use
;; error_at here so we use code chunks instead. And we cannot use
;; debug here...
(defun melt_make_sexpr (loc :rest)
  :doc #{Dynamically build an s-expression of $CLASS_SEXPR with
  location $LOC and other arguments. Also used by $BACKQUOTE and
  $QUOTE macros.}#
  (let ( (cont (make_list discr_list))
	 (vloc (cond ( (is_mixint loc)
		       loc
		       )
		     ( (is_mixloc loc)
		       loc)
		     ( (is_a loc class_located)
		       (unsafe_get_field :loca_location loc))
		     (:else ())))
	 (sexpr (instance class_sexpr
			  :loca_location vloc
			  :sexp_contents cont))
	 )
    (forever 
     argloop
     (variadic 
      ( ()
	(exit argloop))
      ( (:cstring str)
	(let ( (bs (constant_box str))
	       )
	  (list_append cont bs)))
      ( (:long num)
	(let ( (bs (constant_box num))
	       )
	  (list_append cont bs)))
      ( (:value v)
	(cond ( (null v)
		(list_append cont v))
	      ( (is_object v)
		(list_append cont v))
	      ( (is_integerbox v)
		(list_append cont v))
	      ( (is_string v)
		(list_append cont v))
	      ( (is_multiple v)
		(foreach_in_multiple
		 (v)
		 (comp :long ix)
		 (list_append cont comp)))
	      ( (is_list v)
		(foreach_pair_component_in_list
		 (v)
		 (curpair curcomp)
		 (list_append cont curcomp)))
	      ;; try to reify locations
	      ( (is_mixloc v)
		(let ( (:long locline (mixloc_locline v))
		       (:cstring locfile (mixloc_locfile v))
		       )
		  (if (and (>i locline 0)
			   (cstring_non_empty locfile))
		      (list_append cont (instance class_sexpr
						  :loca_location loc
						  :sexp_contents (list 'hook_melt_make_location 
								       (constant_box locfile) 
								       (constant_box locline))))
		    (list_append cont ())))
		)
	      ( (and (is_mixint v)
		     (is_string (mixint_val v))
		     )
		(let ( (:long locline (get_int v))
		       )
		  (list_append cont (instance class_sexpr
					      :loca_location loc
					      :sexp_contents (list 'hook_melt_make_location 
								   (mixint_val v) 
								   (constant_box locline))))
		  (list_append cont ()))
		)
	      ( (is_closure v)
		(v cont))
	      (:else
	       (let ( (discrname (get_field :named_name (discrim v)))
		      (:long vix (variadic_index))
		      )
		 ;; we cannot use error_at in this warmelt-base.melt file
		 (error_strv vloc "in MELT_MAKE_SEXPR unexpected value of discriminant" discrname)
		 (code_chunk errbadval_chk 
			     #{ /* melt_make_sexpr $ERRBADVAL_CHK */
			     inform (UNKNOWN_LOCATION, 
				     "unexpected value index in MELT_MAKE_SEXPR is %d", (int) $VIX) ;
			     }#)
		 (return ())
		 ))))
      (:else
       (let ( (ctyname (get_field :named_name (variadic_ctype 0)))
	      (:long vix (variadic_index))
	      )
	 (error_strv vloc "in MELT_MAKE_SEXPR unexpected thing of ctype" ctyname)
	 (code_chunk errbadthing_chk 
		     #{ /* melt_make_sexpr $ERRBADTHING_CHK */
		     inform (UNKNOWN_LOCATION, 
			     "unexpected thing index in MELT_MAKE_SEXPR is %d", (int) $VIX) ;
		     }#)
	 (return ())
	 )))
     )
    (return sexpr)
    ))

;; it is also called make_sexpr for simplicity
(export_values melt_make_sexpr)
(export_synonym make_sexpr melt_make_sexpr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defhook hook_sort_compare_less
  (:value left right cmp)
  ()
  :long
  :predef HOOK_SORT_COMPARE_LESS
  :doc #{The internal $HOOK_SOURCE_COMPARE_LESS is for sorting
  tuples. It should return boolean true if $LEFT is strictly less
  than $RIGHT using the $CMP function. This $CMP function should return
  @code{:TRUE} when $LEFT is strictly less than $RIGHT. If $CMP
  returns a boxed number, it should be strictly negative iff $LEFT is
  strictly less than $RIGHT.}#
  (if (== left right)
      (return 0))
  (let ( (cmpres (cmp left right))
	 )
    (cond ( (null cmpres)
	    (return 0)
	    (void))
	  ( (== cmpres :true)
	    (return 1)
	    (void))
	  ( (is_integerbox cmpres)
	    (let ( (:long cmpl (get_int cmpres))
		   )
	      (if (<i cmpl 0)
		  (return 1)
		(return 0)))
	    (void)
	    )
	  )
    (return 1)	    
    )
  )					;end hook_sort_compare_less

;;;;

(cheader
 #{
 /* A compare structure used in multiple_sort for std::stable_sort;
    it has to be a compilation-unit global type;
    it cannot be a struct inside multiple_sort;
    see http://stackoverflow.com/q/21201685/841108
    and ISO/IEC 14882 C++03 standard section 14.3.1
  */
  class Melt_Sort_Compare_Index {
       struct meltmultiple_st** melttup_ad;
       melt_ptr_t* meltcmp_ad;
    public:
       Melt_Sort_Compare_Index (struct meltmultiple_st**tup_ad, melt_ptr_t* cmp_ad)
          : melttup_ad(tup_ad), meltcmp_ad(cmp_ad) {};
       ~Melt_Sort_Compare_Index() { meltcmp_ad=NULL; melttup_ad=NULL; };
       bool operator () (int meltleftix, int meltrightix) {
         return (bool)
            melthookproc_HOOK_SORT_COMPARE_LESS((*melttup_ad)->tabval[meltleftix],
				                (*melttup_ad)->tabval[meltrightix],
				                *meltcmp_ad);
       };
     }; /* end class Melt_Sort_Compare_Index */
 }#)

;;;;;;;; our "re-entrant" tuple sorter using std::stable_sort
(defun multiple_sort (mul cmp dis) 
  :doc #{Returns a sorted tuple from the tuple $MUL, the compare
  function $CMP, see $HOOK_SORT_COMPARE_LESS for details about it, using the
  optional tuple discriminant $DIS (using $DISCR_MULTIPLE if null).
  If $MUL is not a tuple, or $CMP is not a closure or $DIS is not a
  tuple discriminant or null, then a null value is returned. If the
  closure $CMP does not define an order the behavior is undefined.
  The $CMP function can be simple or complex, perhaps even [recursively] calling
  $MULTIPLE_SORT itself (but that is probably unusual). The sorting is stable.}#
  ;(melt_low_debug "multiple_sort start mul==" mul)
  (if (is_multiple mul)
      (void)
    (return ()))
  (if (is_closure cmp)
      (void)
    (return ()))
  (if (null dis)
      (setq dis discr_multiple))
  (if (is_a dis class_discriminant)
      (void)
    (return ()))
  (if (expr_chunk checkmagic_chk :long
		  #{ /* multiple_sort $CHECKMAGIC_CHK */
		  (((meltobject_ptr_t)($DIS))->meltobj_magic == MELTOBMAG_MULTIPLE) }#)
      (void)
    (return ()))
  (let ( (:long tuplen (multiple_length mul))
	 )
    (let (
	  (res (make_multiple dis tuplen))
	  (:long reslen (multiple_length res))
	  )
      (code_chunk 
       sortres_chk 
       #{ /* multiple_sort $SORTRES_CHK start */
       melt_assertmsg ("check that MUL is multiple when starting multiple_sort",
		       melt_magic_discr ($MUL) == MELTOBMAG_MULTIPLE) ;
       if ($RESLEN >= (long)INT_MAX/2)
         melt_fatal_error("too big sized %ld tuple to sort", $RESLEN) ;
       melt_assertmsg ("check that RESLEN == TUPLEN in multiple_sort", $RESLEN == $TUPLEN) ;
       Melt_Sort_Compare_Index meltixsorter_$SORTRES_CHK ((meltmultiple_st**)(&($MUL)), &($CMP)) ;
       std::vector<int> meltixvect_$SORTRES_CHK	;
       meltixvect_$SORTRES_CHK.resize($RESLEN)	;
       for (long meltix=0;
	    meltix<$RESLEN;
	    meltix++)
         meltixvect_$SORTRES_CHK[meltix] = meltix ;
         /* do the sort $SORTRES_CHK */
         std::stable_sort (meltixvect_$SORTRES_CHK.begin(),
                           meltixvect_$SORTRES_CHK.end(), 
                           meltixsorter_$SORTRES_CHK) ;
	 melt_assertmsg ("check that RES is multiple in multiple_sort", melt_magic_discr ($RES) == MELTOBMAG_MULTIPLE) ;
	 melt_assertmsg ("check that MUL is multiple in multiple_sort", melt_magic_discr ($MUL) == MELTOBMAG_MULTIPLE) ;
	 for (long meltix=0;
	      meltix<$RESLEN;
	      meltix++) {
		 int sortix_$SORTRES_CHK = meltixvect_$SORTRES_CHK[meltix] ;
		 melt_assertmsg ("check index in multiple_sort", sortix_$SORTRES_CHK>=0 && (long)sortix_$SORTRES_CHK < $RESLEN) ;
		 ((meltmultiple_st*)($RES))->tabval[meltix]
		    = ((meltmultiple_st*)($MUL))->tabval[sortix_$SORTRES_CHK] ;	       
	  } ;
	  meltgc_touch ($RES) ;
	  /* multiple_sort $SORTRES_CHK end */
	  }#)
      (assert_msg "check res" (is_multiple res) res)
      ;(melt_low_debug "multiple_sort end result res==" res)
      (return res))))

;;;;;

;; utility to give a "sorted" tuple of attributes in a mapobject
(defun mapobject_sorted_attribute_tuple (mapo)
  :doc #{Give the alphabetically sorted tuple of attributes in a 
given object map $MAPO}#
  (let ( 
	(:long mapcount (mapobject_count mapo)) 
	(countbox (make_integerbox discr_integer 0))
	(boxedone (make_integerbox discr_integer 1))
	(boxedzero (make_integerbox discr_integer 0))
	(boxedminusone (make_integerbox discr_integer -1))
	(tupl (make_multiple discr_multiple mapcount))
	)
    ;; fill the tupl with (attribute value rank) entries
    (mapobject_every
     mapo
     (lambda (at va)
       (let ( (:long curcount (get_int countbox)) 
	      (ent (tuple at va 
			  (make_integerbox discr_integer curcount)))
	      )
	 (multiple_put_nth tupl curcount ent)
	 (put_int countbox (+i curcount 1))
	 )))
;;; sort the tuple and output in sorted order
    (let ( (sortupl 
	    (multiple_sort 
	     tupl
	     (lambda (e1 e2)
	       (let ( (e1at (multiple_nth e1 0))
		      (e1va (multiple_nth e1 1))
		      (e1rk (multiple_nth e1 2))
		      (e2at (multiple_nth e2 0))
		      (e2va (multiple_nth e2 1))
		      (e2rk (multiple_nth e2 2))
		      )
		 (return 
		  (compare_obj_ranked e1at e1rk e2at e2rk boxedminusone boxedzero boxedone) ())
		 ))
	     discr_multiple
	     ))
	   )
      (multiple_map sortupl (lambda (el) (multiple_nth el 0)))
      )
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun json_name_less (lv rv)
  (let ( (lname (cond ((is_string lv) lv) 
		      ((is_a lv class_named) (get_field :named_name lv))))
	 (rname (cond ((is_string rv) rv) 
		      ((is_a rv class_named) (get_field :named_name rv))))
	 )
    (if (string< lname rname) :true)))

(defun json_name_equal (lv rv)
  (let ( (lname (cond ((is_string lv) lv) 
		      ((is_a lv class_named) (get_field :named_name lv))))
	 (rname (cond ((is_string rv) rv) 
		      ((is_a rv class_named) (get_field :named_name rv))))
	 )
    (if (==s lname rname) :true)))

(defun make_jsonobject (dis :rest)   
  :doc #{Dynamically build a JSON object of discriminant
  $DIS. Variadic arguments are alternatively name and value entries; a
  name entry is a named object or a string value or a list or tuple of
  named objects or strings; a value entry is a named object, a string,
  null, or a list or tuple.}#
  (if (null dis) (setq dis discr_jsonobject))
  (when (is_not_a dis class_discriminant)
    (return ()))
  (when (expr_chunk testdis_chk :long #{/*melt_make_jsonobject $TESTDIS_CHK*/
		    !$DIS || ((meltobject_ptr_t)$DIS)->meltobj_magic != MELTOBMAG_JSONOBJECT}#)
    (return ()))
  (let ( (listentries (make_list discr_list))
	 )
    (forever 
     argloop
     (let ( (curname ())
	    (curval ())
	    (nametup ())
	    (valtup ())
	    )
       (variadic 
	( () (exit argloop))
	( (:cstring csname) (setq curname (make_stringconst discr_string csname)) (void))
	( (:long lname) (setq curname (string4out discr_string lname)))
	( (:value vname)
	  (cond ( (is_a vname class_named) (setq curname vname))
		( (is_string vname) (setq curname vname))
		( (is_multiple vname) (setq nametup vname))
		( (is_list vname) (setq nametup (list_to_multiple vname)))
		(:else (void)))
	  )
	(:else (void)))
       (variadic 
	( () (exit argloop)
	  )
	( (:cstring cs) (setq curval (constant_box cs)) (void))
	( (:long l) (setq curval (constant_box l)))
	( (:value v)
	  (cond ( (is_a v class_named) (setq curval v))
		( (is_string v) (setq curval v))
		( (is_integerbox v) (setq curval v))
		( (is_jsonobject v) (setq curval v))
		( (is_multiple v) (if nametup (setq valtup v) (setq curval v)))
		( (is_list v) (let ( (vtup (list_to_multiple v)) )
				(if nametup (setq valtup v) (setq curval v))))
		(:else (void))))
	(:else (void))
	)
       (cond (curname 
	      (list_append listentries (tuple curname curval)))
	     (nametup 
	      (foreach_in_multiple 
	       (nametup)
	       (curnamelem :long nix)
	       (let ( (curvalelem (multiple_nth valtup nix)) )
		 (if (or (is_string curnamelem) (is_a curnamelem class_named))
		     (list_append listentries (tuple curnamelem curvalelem)))))))
       )
     )
    (let ( (tupentries (list_to_multiple listentries))
	   (sortedtupentries 
	    (multiple_sort tupentries 
			   (lambda (e1 e2) (json_name_less (multiple_nth e1 0) (multiple_nth e2 0)))
			   discr_multiple))
	   (uniqlistentries 
	    (let ( (ul (make_list discr_list))
		   )
	      (foreach_in_multiple
	       (sortedtupentries)
	       (curent :long ix)
	       (let ( (nextent (multiple_nth sortedtupentries (+i ix 1)))
		      )
		 (if (json_name_less (multiple_nth curent 0) (multiple_nth nextent 0))
		     (list_append ul curent))))
	      (list_to_multiple ul)))
	   (:long nbuniqentries (multiple_length uniqlistentries))
	   (resj ())			        
	   )
      ;; this is the only place where jsonobject are allocated! ;
      (code_chunk makejson_chk 
		  #{ /* melt_make_jsonobject $MAKEJSON_CHK */
		  // the only place where jsonobjects are allocated
                  struct meltjsonobject_st* mj_$MAKEJSON_CHK 
			  = (struct meltjsonobject_st*) meltgc_allocate (sizeof (struct meltjsonobject_st),
					   $NBUNIQENTRIES * sizeof(struct melt_jsonobentry_st)); 
		  mj_$MAKEJSON_CHK->discr = (meltobject_ptr_t) $DIS; 
		  mj_$MAKEJSON_CHK->jsob_aux = NULL; 
		  mj_$MAKEJSON_CHK->jsob_size = $NBUNIQENTRIES;
		  $RESJ = (melt_ptr_t) mj_$MAKEJSON_CHK;
		  mj_$MAKEJSON_CHK = NULL;
		  }#)
      (foreach_in_multiple
       (uniqlistentries)
       (curent :long ix)
       (let ( (curnam (multiple_nth curent 0))
	      (curval (multiple_nth curent 1))
	      )
	 (assert_msg "check curnam" (or (is_string curnam) (is_a curnam class_named)) curnam curent)
	 (code_chunk filljson_chk 
		     #{ /* melt_make_jsonobject $FILLJSON_CHK */
		     // the only place where jsonobjects are filled
		     ((struct meltjsonobject_st*)$RESJ)->jsob_entab[$IX].jsonob_name = $CURNAM; 
		     meltgc_touch_dest ($RESJ, $CURNAM); 
		     ((struct meltjsonobject_st*)$RESJ)->jsob_entab[$IX].jsonob_val = $CURVAL; 
		     meltgc_touch_dest ($RESJ, $CURVAL); 
		     // done melt_make_jsonobject $FILLJSON_CHK 
		     }#)
	 ))
      (return resj)
      )
  )
  )

(defprimitive jsonobject_aux (:value vj) :value 
  :doc #{retrieve the auxiliary value in a JSONobject $VJ or else null.}#
  #{ /* jsonobject_aux */ melt_jsonobject_aux($VJ) }#)

(defprimitive jsonobject_auxput (:value vj aux) :void
  :doc #{In JSONobject $VJ safely put the auxiliary data $AUX.}#
  #{ /* jsonobject_auxput */
   melt_jsonobject_putaux ($VJ, $AUX); }#) 

(defprimitive jsonobject_size (:value vj) :long
  :doc #{size of JSONobject $VJ or else 0.}#
  #{ /* jsonobject_size */ melt_jsonobject_size($VJ) }#)

(defprimitive jsonobject_nth_name (:value vj :long rk) :value
  :doc #{in JSONobject $VJ retrieve the name of rank $RK - starting from end if $RK is negative - or else nil.}#
  #{ /* jsonobject_nth_name */ melt_jsonobject_nth_name ($VJ, (int)$RK) }#)

(defprimitive jsonobject_nth_value (:value vj :long rk) :value
  :doc #{in JSONobject $VJ retrieve the value of rank $RK - starting from end if $RK is negative - or else nil.}#
  #{ /* jsonobject_nth_value */ melt_jsonobject_nth_value ($VJ, (int)$RK) }#)


(defun jsonobject_get_named (:value vj name)
:doc #{Dichotomically get in JSONobject $VJ the value associated to name $NAME 
which should be a string or an instance of $CLASS_NAMED, or else nil.}#
  (if (not (is_jsonobject vj)) (return ()))
  (let ( (vname (cond 
		 ((is_string name) name)
		 ((is_a name class_named) (unsafe_get_field :named_name name))
		 (:else ())))
	 (:long sz (jsonobject_size vj))
	 (:long lo 0)
	 (:long hi (-i sz 1))
	 )
    (if (not (is_string vname)) (return ()))
    (forever 
     getloop
     (if (>i (+i lo 2) hi) (exit getloop))
     (let ( (:long mi (/iraw (+i lo hi) 2))
	    (midname (jsonobject_nth_name vj mi))
	    )
       (if (json_name_less vname midname)
	   (setq hi mi)
	 (setq lo mi))))
    (foreach_long_upto 
     (lo hi)
     (:long ix)
     (let ( (curname (jsonobject_nth_name vj ix))
	    )
       (if (json_name_equal name vname)
	   (return (jsonobject_nth_value vj ix)))
       )
     )
    )
  )

(defciterator foreach_entry_in_jsonobject 
  (:value vj)
  eachjson
  (:value curname curval :long ix)
  :doc #{Iterate inside JSONobject $VJ with current name $CURNAME value $CURVAL and index $IX.}#
  #{ /* foreach_entry_in_jsonobject start $EACHJSON */
    unsigned sz_$EACHJSON =  melt_jsonobject_size($VJ);
    for ($IX = 0L; 
	 $IX < (long) sz_$EACHJSON && $VJ;
         $IX++) {
      $CURNAME = melt_jsonobject_nth_name ($VJ, $IX);
      if (!$CURNAME) continue;
      $CURVAL = melt_jsonobject_nth_value ($VJ, $IX);
    /* begin inside foreach_entry_in_jsonobject $EACHJSON */ 
  }#
  #{ /* foreach_entry_in_jsonobject end $EACHJSON */
     $CURNAME = NULL;
     $CURVAL = NULL;
  } }#
)

(defun outjson_jsonobj_method (jsob out)
  (assert_msg "check out" (is_out out) out)
  (assert_msg "check jsob" (is_jsonobject jsob) jsob)
  (add2out out "{")
  (foreach_entry_in_jsonobject
   (jsob)
   (curat curval :long ix)
   (if ix (add2out out ","))
   (cond ((is_string curat)
	  (add2out_cencstring out curat))
	 ((is_a curat class_named)
	  (let ( (atnam (get_field :named_name curat))
		 )
	    (assert_msg "check atnam" (is_string atnam) atnam)
	    (add2out out "\"")
	    (code_chunk addname_chk 
			#{ /* output_jsonobj_method $ADDNAME_CHK */
			long namelen = strlen(melt_string_str($ATNAM));
			for (long ix=0; 
			     ix<namelen; 
                             ix++) {
			  char curc = melt_string_str($ATNAM)[ix];
			  char buf[4];
			  memset(buf, 0, sizeof(buf));
			  buf[0] = tolower(curc);
			  buf[1] = (char)0;
			  meltgc_add_out_raw ($OUT, buf);
			}
			}#)
	    (add2out out "\"")
	    ))
	 (:else
	  (assert_msg "invalid JSON attr" () curat)))
   (add2out out ":")
   (output_json out curval)
   )
  (add2out out "}")
  (return ()))
(install_method discr_jsonobject output_as_json outjson_jsonobj_method)


(defun outjson_multiple_method (tup out)
  (assert_msg "check out" (is_out out) out)
  (assert_msg "check tup" (is_multiple tup) tup)
  (add2out out "[")
  (foreach_in_multiple
   (tup)
   (curcomp :long ix)
   (if ix (add2out out ","))
   (output_json out curcomp))
  (add2out out "]")
)
(install_method discr_multiple output_as_json outjson_multiple_method)

(export_values make_jsonobject 
	       output_as_json
	       output_json
	       jsonobject_aux 
	       jsonobject_auxput 
	       jsonobject_size
	       jsonobject_nth_name
	       jsonobject_nth_value
	       json_name_less
	       json_name_equal
	       foreach_entry_in_jsonobject
	       jsonobject_get_named
	       )

;;;;;;;;;;;;;;;;

(export_values
 ;; keep the alphanumerical order
		
 !=i
 *i
 -i
 <=i
 ==i

 +iv
 -iv
 *iv
 /iv
 %iv

 <iv
 <=iv
 =iv
 !=iv
 >iv 
 >=iv

 <ivi
 <=ivi
 =ivi
 !=ivi
 >ivi
 >=ivi

 +ivi
 -ivi
 *ivi
 /ivi
 %ivi

 add2out
 add2out_ccomconst
 add2out_ccomstrbuf
 add2out_ccomstring 
 add2out_cencstrbuf
 add2out_cencstring
 add2out_cenconst 
 add2out_cencsubstring
 add2out_cident
 add2out_cidentprefix
 add2out_indent
 add2out_indentnl
 add2out_longdec
 add2out_longhex
 add2out_mixloc
 add2out_routinedescr
 add2out_sbuf
 add2out_strconst
 add2out_string
 add2sbuf_ccomconst
 add2sbuf_ccomstrbuf
 add2sbuf_ccomstring 
 add2sbuf_cencstrbuf
 add2sbuf_cencstring
 add2sbuf_cident
 add2sbuf_cidentprefix
 add2sbuf_dynloaded_suffix
 add2sbuf_indent
 add2sbuf_indentnl
 add2sbuf_longdec
 add2sbuf_longhex
 add2sbuf_mixloc
 add2sbuf_routinedescr
 add2sbuf_sbuf
 add2sbuf_short_mixloc
 add2sbuf_strconst
 add2sbuf_string
 add2sbuf_texi_mixloc
 add_to_out
 andi
 c_clock
 c_time
 cbreak_msg
 checkcallstack_msg
 checkval_dbg
 compare_named_alpha
 complete_sequence_as_list
 complete_sequence_as_tuple
 cstring_containing
 cstring_length
 cstring_prefixed
 cstring_same
 debugcstring
 debuglong
 error_plain
 error_strv
 errormsg_plain
 errormsg_strv
 foreach_long_upto
 foreach_in_string
 full_garbcoll
 generate_flavored_melt_module
 get_globpredef
 hook_melt_make_location
 increment
 inform_plain
 inform_strv
 informsg_plain
 is_file
 is_mixbigint
 is_mixint
 is_mixloc
 is_multiple_or_null
 is_not_object
 is_out
 is_strbuf
 is_stringconst
 list_nth_element
 list_remove_last_element
 longbacktrace_dbg
 make_mixint
 make_mixloc
 make_pair
 make_strbuf
 make_string
 make_string_generated_cc_filename
 make_string_mixloc_file
 make_string_nakedbasename
 make_string_real_access_path
 make_string_real_access_path_value 
 make_string_tempname_suffixed
 make_string_without_dynloaded_suffix
 make_string_without_suffix
 mapobject_sorted_attribute_tuple
 mapstring_count
 mapstring_every
 mapstring_iterate_test	
 mapstring_rawget
 mapstring_rawput
 mapstring_rawremove
 mapstring_size
 maxi
 melt_application_count
 melt_application_depth
 melt_application_shallower
 melt_argument
 melt_error_counter
 melt_call_deeper_than
 melt_call_depth
 melt_increment_dbgcounter
 melt_is_bootstrapping
 melt_mode_reference
 melt_predefined_by_name
 melt_predefined_get
 melt_version_str
 melt_make_fresh_environment_reference
 message_dbg
 messagenum_dbg 
 mini
 minor_garbcoll
 mixbigint_val
 mixint_val
 mixloc_location
 mixloc_locbasefile 
 mixloc_locfile
 mixloc_locline
 mixloc_val
 multiple_backward_every
 multiple_every
 multiple_every_both
 multiple_sort
 negi
 nonzero_hash
 noti
 notnull
 obj_hash
 obj_len
 obj_num
 object_length
 object_nth_field
 ori
 outcstring_dbg
 outcstring_err	
 outnewline_dbg
 outnewline_err
 outnum_dbg
 outnum_err
 output_length
 output_sbuf_no_overwrite_strconst
 output_sbuf_no_overwrite_strval
 output_sbuf_strconst
 output_sbuf_strval
 outstr_dbg
 outstr_err
 outstrbuf_dbg
 outstrbuf_err
 pair_listlength
 pair_set_head 
 ppstrbuf_mixbigint
 read_file
 read_strv
 read_strv_loc
 relative_time_millisec
 register_pragma_handler
 retrieve_value_descriptor_list
 set_reference
 set_real_timer_millisec
 some_hook_with_data
 some_integer_between
 some_integer_different_from
 some_integer_equal_to
 some_integer_greater_or_equal_to
 some_integer_greater_than
 some_integer_lower_or_equal_to
 some_integer_lower_than
 some_integer_multiple
 some_string_value
 some_string_value_containing
 split_string_colon
 split_string_comma
 split_string_equal
 split_string_space 
 start_melt_module_of_flavor 
 strbuf2string
 strbuf_consume
 strbuf_peek
 strbuf_reserve
 strbuf_usedlength
 string4out
 string_dynloaded_suffixed
 string_ends
 string_hex_md5sum_constpath 
 string_hex_md5sum_path_sequence
 string_hex_md5sum_pathstrv
 string_length
 string_nth
 string_prefixed
 string_starts
 string_suffixed
 subclass_of
 subclass_or_eq
 subseq_multiple
 symbol_cname
 tuple_nth
 tuple_sized
 valdesc_bucketlongs
 valdesc_closure
 valdesc_double
 valdesc_decay
 valdesc_hook
 valdesc_int
 valdesc_jsonobject
 valdesc_list
 valdesc_mapobjects
 valdesc_mapstrings
 valdesc_mixbigint
 valdesc_mixint
 valdesc_mixloc
 valdesc_multiple
 valdesc_object
 valdesc_pair
 valdesc_real
 valdesc_routine
 valdesc_special_data
 valdesc_strbuf
 valdesc_string
 warning_plain
 warning_strv
 warningmsg_plain
 warningmsg_strv
 xori
 zerop
 )


(export_synonym melt_mode_container melt_mode_reference)


(export_synonym set_content set_reference)
(export_synonym some_integer_!= some_integer_different_from)
(export_synonym some_integer_= some_integer_equal_to)
(export_synonym some_integer_>= some_integer_greater_or_equal_to)
(export_synonym some_integer_> some_integer_greater_than)
(export_synonym some_integer_<= some_integer_lower_or_equal_to)
(export_synonym some_integer_< some_integer_lower_than)
;;;; eof warmelt-base.melt
